{"posts":[{"title":"【题解】AtCoder Regular Contest 163 A-D","text":"E 太过于 adhoc，F 太过于神仙，就不做了。 A.Divide String 题目描述： 多组数据。 给出一个长为 NNN 的字符串，问能否将其划分为多段，使字典序严格上升，保证 ∑N≤2000\\sum{N}\\le2000∑N≤2000。 $ 2\\ \\le\\ N\\ \\le\\ 2000 $ 题目分析： 考虑如果划分为三段，使得其满足 S1&lt;S2&lt;S3S_1 &lt; S_2 &lt; S_3S1​&lt;S2​&lt;S3​，则必然满足 S1&lt;S2+S3S_1 &lt; S_2 + S_3S1​&lt;S2​+S3​ 所以我们完全没必要划分为三段及以上，划分为两段就足够了。 可以直接枚举划分的分界点，然后 O(n)O(n)O(n) 判断是否合法。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2005;char s[N];bool chk(int l,int mid,int r){ int len1 = mid - l + 1; int len2 = r - (mid+1) + 1; int posl = l,posr = mid+1; while(posl &lt;= mid &amp;&amp; posr &lt;= r &amp;&amp; s[posl] == s[posr]){ ++posl,++posr; } if(posl &gt; mid || posr &gt; r) return len1 &lt; len2; return s[posl] &lt; s[posr]; }int main(){ int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n;scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1); bool flag = false; for(int i=1; i&lt;n; i++){ if(chk(1,i,n)){ flag = true; break; } } if(flag) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); } return 0;} B.Favorite Game 题目描述： 给定 N,MN,MN,M 和数列 AN{A_N}AN​。定义一次操作为任取一个 Ai(1≤i≤N)A_i(1\\le i\\le N)Ai​(1≤i≤N) 加一或减一。求经过几次操作后可以使得至少有 MMM 个 i(3≤i≤N)i(3\\le i\\le N)i(3≤i≤N) 满足 A1≤Ai≤A2A_1\\le A_i \\le A_2A1​≤Ai​≤A2​。 $ 3\\ \\le\\ N\\ \\le\\ 2\\ \\times\\ 10^5 ， 1\\ \\le\\ M\\ \\le\\ N-2 ， 1\\ \\le\\ A_i\\ \\le\\ 10^9 $ 题目分析： 首先我们一定是只会操作 a1,a2a_1,a_2a1​,a2​，因为操作 a1,a2a_1,a_2a1​,a2​ 相当于对其余值整体的一个操作，这样做显然优于只操作一个。 最后满足条件的数一定在 aaa 排序后的数组上是一个连续的区间，所以可以直接枚举这个区间是什么，设左右端点分别为 al,ara_l,a_ral​,ar​ 则我们就是要通过操作让 a1≤ala_1 \\le a_la1​≤al​ 且 a2≥ara_2 \\ge a_ra2​≥ar​，这个就可以随便做了。 代码： 点击查看代码 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1e6+5;const int INF = 1e11+5;vector&lt;int&gt; v1,v2;int a[N],n,m;signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); int tmp = INF; int l = a[1],r = a[2]; sort(a+3,a+n+1); for(int i=3; i + m - 1&lt;=n; i++){ int res = 0; if(l &gt; a[i]) res += l - a[i]; if(r &lt; a[i + m - 1]) res += a[i + m - 1] - r; tmp = min(tmp,res); } printf(&quot;%lld\\n&quot;,tmp); return 0;} C.Harmonic Mean 题目描述： 给定正整数 NNN，你需要构造一个正整数序列 AiA_iAi​，满足： ∑i=1n1Ai=1\\displaystyle\\sum_{i=1}^n\\frac{1}{A_i}=1i=1∑n​Ai​1​=1 AiA_iAi​ 互不相同； 1≤Ai≤1091\\le A_i\\le 10^91≤Ai​≤109 多组数据，1≤T,N≤5001\\le T,N\\le 5001≤T,N≤500。 题目分析： 看到这个 1Ai\\frac{1}{A_i}Ai​1​ 一个能想到的东西就是 1k(k+1)=1k−1k+1\\frac{1}{k(k+1)} = \\frac{1}{k} - \\frac{1}{k+1}k(k+1)1​=k1​−k+11​。 会发现这个相当于一个裂项的形式，也就是我们可以直接： 11×2+12×3+23×4+⋯+1(n−1)×n+1n=1−1n+1n=1\\frac{1}{1 \\times 2} + \\frac{1}{2 \\times 3} + \\frac{2}{3 \\times 4} + \\cdots + \\frac{1}{(n-1) \\times n} + \\frac{1}{n} = 1 - \\frac{1}{n} + \\frac{1}{n} = 1 1×21​+2×31​+3×42​+⋯+(n−1)×n1​+n1​=1−n1​+n1​=1 这个时候发现其实就基本能构造出来了，就是当 n=k×(k+1)n = k \\times (k+1)n=k×(k+1) 的时候这种做法就寄了。 但是如果 nnn 满足这个形式，则 n−1n-1n−1 一定不满足这个形式，所以我们可以按 n−1n-1n−1 构造出一种方案，然后将所有数乘 222 后再加上数 222 就好了。 其实就是让 ∑i=1n−11Bi=12\\sum_{i=1}^{n-1} \\frac{1}{B_i} = \\frac{1}{2}∑i=1n−1​Bi​1​=21​ 然后再加 12\\frac{1}{2}21​ 就好了。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; v;void solve(int n){ for(int i=1; i&lt;=n-1; i++) v.push_back(i * (i + 1)); v.push_back(n);}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n;scanf(&quot;%d&quot;,&amp;n); if(n == 2){ printf(&quot;No\\n&quot;); continue; } bool flag = false; for(int i=1; i&lt;=n; i++){ if(i * (i + 1) == n) flag = true; } if(flag){ solve(n-1); for(int i=0; i&lt;v.size(); i++) v[i] *= 2; v.push_back(2); } else solve(n); printf(&quot;Yes\\n&quot;); for(auto i : v) printf(&quot;%d &quot;,i); v.clear(); printf(&quot;\\n&quot;); } return 0;} D.Sum of SCC 题目描述： 考虑一张竞赛图 GGG，其中有 NNN 个节点，节点编号为 1,2,…,N1,2,\\dots,N1,2,…,N，且 GGG 满足： 对于 GGG 中的所有边 u→vu\\to vu→v，恰好有 MMM 条边满足 u&lt;vu&lt;vu&lt;v。 设 f(G)f(G)f(G) 表示图 GGG 中的强连通分量数量。请你求出所有满足条件的 GGG 的 f(G)f(G)f(G) 之和。 答案对 998244353998244353998244353 取模。 1≤N≤301\\le N\\le301≤N≤30，0≤M≤N(N−1)20\\le M\\le\\frac{N(N-1)}20≤M≤2N(N−1)​。 题目分析： 之前不大知道竞赛图的性质，下面稍微罗列一下： **性质一：**竞赛图缩点之后成链状。 注意这里不是一条链而是链状，就如下图所示： **性质二：**竞赛图的每一个强连通分量必然存在哈密顿回路 **性质三：**竞赛图必然存在哈密顿回路 因为缩点之后每一个点代表一个 SCC，所以可以推出下面这个结论： 一个竞赛图的 SCC 个数为将其点集划分为两个集合 A,BA,BA,B（可以为空）并满足以下限制的方案数减 111： 对于 u∈A，v∈Bu \\in A，v \\in Bu∈A，v∈B 的边 (u,v)(u,v)(u,v)，其方向必然为 u→vu \\to vu→v 有了这个结论也就是说我们可以直接对于每一个点 dpdpdp 求其属于 AAA 还是 BBB，就是直接求这个限制下划分的方案数。 因为题目里要求我们的统计的存在一个大小关系，所以不让从小到大插入点，也就是设 dp[i][j][k]dp[i][j][k]dp[i][j][k] 表示插入了编号为 [1,i+j][1,i+j][1,i+j] 的点，∣A∣=i，∣B∣=j|A| = i，|B| = j∣A∣=i，∣B∣=j，满足题目条件的边数为 kkk 的方案数。 转移的话就是枚举 i+j+1i+j+1i+j+1 这个点插入到 AAA 还是 BBB，如下： ∑x=0idp[i][j][k]×(xi)→dp[i+1][j][k+x]∑x=0jdp[i][j][k]×(xj)→dp[i][j+1][k+i+x]\\begin{aligned} \\sum_{x=0}^i dp[i][j][k] \\times \\binom{x}{i} &amp;\\to dp[i+1][j][k + x] \\\\ \\sum_{x=0}^j dp[i][j][k] \\times \\binom{x}{j} &amp;\\to dp[i][j+1][k+i+x] \\\\ \\end{aligned} x=0∑i​dp[i][j][k]×(ix​)x=0∑j​dp[i][j][k]×(jx​)​→dp[i+1][j][k+x]→dp[i][j+1][k+i+x]​ 考虑放在 AAA，对于跨集合的边必然是 i+j+1→Bi+j+1 \\to Bi+j+1→B 而因为 i+j+1i + j + 1i+j+1 必然是最大值也就是说这样的连边一定不满足条件，也就不用管；对于在集合内部的边就是枚举多少个满足条件即可。 考虑放在 BBB，对于跨集合的边必然是 A→i+j+1A \\to i+j+1A→i+j+1，也就是一定满足条件，直接全加上就好；对于在集合内部的边就是枚举多少个满足条件即可。 也要注意最后把减 111 这个贡献也算上。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 35;const int MOD = 998244353;int f[N][N][N*N],C[N*N][N*N]; signed main(){ int n,m;scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); C[0][0] = 1; for(int i=1; i&lt;=n * n; i++){ C[i][0] = 1; for(int j=1; j&lt;=i; j++){ C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD; } } f[0][0][0] = 1; for(int i=0; i&lt;n; i++){ for(int j=0; i + j &lt; n; j++){ for(int k=0; k&lt;=m; k++){ for(int x=0; x&lt;=i; x++) if(k + x &lt;= m) f[i+1][j][k+x] = (f[i+1][j][k+x] + f[i][j][k] * C[i][x])%MOD; for(int x=0; x&lt;=j; x++) if(k + i + x &lt;= m) f[i][j+1][k+i+x] = (f[i][j+1][k+i+x] + f[i][j][k] * C[j][x])%MOD; } } } int ans = 0; for(int i=0; i&lt;=n; i++) ans = (ans + f[i][n-i][m])%MOD; ans = (ans - C[n * (n-1) / 2][m] + MOD)%MOD; //最后的 -1 产生的贡献 printf(&quot;%lld\\n&quot;,ans); return 0;}","link":"/2023/09/14/ARC%20163%20A-D/"},{"title":"aaa","text":"","link":"/2023/09/14/aaa/"},{"title":"轻重链剖分","text":"对算法本身的部分理解 12345678if (son[now]) dfs2(son[now], topf)for (int i = head[now] i; i = e[i].nxt) { int to = e[i].to; if (to != fa[now] &amp;&amp; to != son[now]) { dfs2(to, to); }} 这是第二遍 dfsdfsdfs，定义：son[now]son[now]son[now] 为 nownownow 点的重儿子，topftopftopf 为当前的重链上深度最小的一个点也就是开始的点。我们在遍历整棵树的时候，会选择先去遍历这个点的左儿子然后再去管其他的点。我们在这一遍遍历其实就是在给他们分配线段树上的基本信息以及记录轻重链的基本信息，在我们的轻重链剖分的时候，是会将重链看作是线段树上维护的的一段连续区间，先访问重儿子可以使得其的重儿子在线段树上的维护的下标为它加一，也就是说是连续的，也就是一条重链对应连续的一段。 这是寻找 x,yx,yx,y 树上路径的相关信息，定义：top[x]top[x]top[x] 为 xxx 节点所在的重链的深度最小的节点（这里节点均为树上的编号），也就是这条重链的开始，dep[x]dep[x]dep[x] 为 xxx 节点在树上的深度，id[x]id[x]id[x] 为节点 xxx 在线段树上的编号。也就是这几行代码是在查询树上 x,yx,yx,y 节点之间的路径上经过的节点的权值和。我们一点点地去看。 首先看循环内部，第一个判断条件就是寻找一个重链的起点深度最大的一个，也就是树上最靠下的一个，然后查询这条重链的信息后就直接跳出这条重链，我们考虑跳深度大的一条链一定不会跳过头，而跳深度小的一条链可能会跳过头了，如下图所示： 我们以红色边代表重边，以黑色边代表轻边，我们看在这样的情况下如果直接去跳过 yyy 所在的这条重链，那么就会跳到节点 111 很明显这不正确，所以就会选择跳 xxx 所在的这条重链，这样不可能会跳出去我们的正确路径。 再看下边的线段树的询问，因为我们的分配线段树上的基本信息是自根到底，所以深度小的节点在线段树上的编号就小，深度大的节点在线段树上的深度就大，所以查询的区间左端点是这条重链的开始，右端点是它本身。 再看下边关于跳过这条重链的情况，我们的 xxx 跳要跳到其重链的开始的父亲节点，因为如果我们不是跳到父亲结点的话，我们一是会将其重链开始的节点的信息重复计算，二是我们可能下一次跳还是选择这一条重链，但是它的起点就是当前的 xxx 节点，所以就死循环了。 翻过来看一眼循环条件，这个循环条件相当于是在约束 x,yx,yx,y 不在同一条重链上，因为我们循环是在跳重链，所以如果它们在同一条重链上那么这条重链肯定不能直接跳过了，就应该直接在这条重链上去询问 x,yx,yx,y 的线段树上的相关信息，因为他们在同一重链，所以编号一定是连续的，直接询问那一段就可以了。 最后三行，因为深度大的节点线段树上的编号也大，所以线段树上的区间就是从深度小的节点到深度大的节点。 注意： 我们所给他们分配的线段树上维护的下标或者叫编号就相当于 dfsdfsdfs 序，所以满足 dfsdfsdfs 具有的性质。","link":"/2023/09/14/heavy-light-decomp/"},{"title":"数学知识","text":"大概就是一个数学知识的梳理，可能会有一些地方写的并不是很全很好，未来可能会补。 模意义下的数论 欧几里得算法 gcd⁡(a,b)=gcd⁡(b,a%b)\\gcd(a,b) = \\gcd(b,a\\% b) gcd(a,b)=gcd(b,a%b) 扩展欧几里得算法 求解： ax+by=gcd⁡(a,b)ax + by = \\gcd(a,b) ax+by=gcd(a,b) 分析： 设 ax1+by1=gcd⁡(a,b)ax_1 + by_1 = \\gcd(a,b)ax1​+by1​=gcd(a,b)，bx2+(a%b)y2=gcd⁡(b,a%b)bx_2 + (a\\%b)y_2 = \\gcd(b,a\\%b)bx2​+(a%b)y2​=gcd(b,a%b)。 根据欧几里得算法则 gcd⁡(a,b)=gcd⁡(b,a%b)\\gcd(a,b) = \\gcd(b,a\\%b)gcd(a,b)=gcd(b,a%b)，也就是说： ax1+by1=bx2+(a%b)y2ax_1 + by_1 = bx_2 + (a\\%b)y_2 ax1​+by1​=bx2​+(a%b)y2​ 根据 a%b=a−⌊ab⌋×ba \\% b = a - \\lfloor \\frac{a}{b} \\rfloor \\times ba%b=a−⌊ba​⌋×b，则有： ax1+by1=bx2+(a−⌊ab⌋×b)y2ax_1 + by_1 = bx_2 + (a - \\lfloor \\frac{a}{b} \\rfloor \\times b)y_2 ax1​+by1​=bx2​+(a−⌊ba​⌋×b)y2​ 化简一下就有： ax1+by1=ay2+b(x2−⌊ab⌋×b×y2)ax_1 + by_1 = ay_2 + b(x_2 - \\lfloor \\frac{a}{b} \\rfloor \\times b \\times y_2) ax1​+by1​=ay2​+b(x2​−⌊ba​⌋×b×y2​) 必然存在一组解为 x1=y2,y1=x2−⌊ab⌋×b×y2x_1 = y_2,y_1 = x_2 - \\lfloor \\frac{a}{b} \\rfloor \\times b \\times y_2x1​=y2​,y1​=x2​−⌊ba​⌋×b×y2​ 不断递归下去，当 b=0b = 0b=0 时使用 x=1,y=0x=1,y=0x=1,y=0 作为一组解然后回溯即可。 费马小定理 对于素数 ppp，若 gcd⁡(a,p)=1\\gcd(a,p) = 1gcd(a,p)=1，则有： ap−1≡1mod pa^{p-1} \\equiv 1 \\mod p ap−1≡1modp 欧拉定理 若 gcd⁡(a,p)=1\\gcd(a,p) = 1gcd(a,p)=1，则有： aφ(p)≡1mod pa^{\\varphi(p)} \\equiv 1 \\mod p aφ(p)≡1modp 扩展欧拉定理 ab={abmod φ(p)gcd⁡(b,p)=1abgcd⁡(b,p)≠1,b&lt;φ(p)a[b%φ(p)+φ(p)]%φ(p)gcd⁡(b,p)≠1,b≥φ(p)a^b = \\begin{cases} a^{b \\mod \\varphi(p)} &amp; \\gcd(b,p) = 1\\\\ a^b &amp; \\gcd(b,p) \\not= 1,b &lt; \\varphi(p) \\\\ a^{[b \\% \\varphi(p) + \\varphi(p)]\\% \\varphi(p)} &amp; \\gcd(b,p) \\not= 1,b \\ge \\varphi(p) \\end{cases} ab=⎩⎪⎪⎨⎪⎪⎧​abmodφ(p)aba[b%φ(p)+φ(p)]%φ(p)​gcd(b,p)=1gcd(b,p)=1,b&lt;φ(p)gcd(b,p)=1,b≥φ(p)​ 中国剩余定理 问题描述： 求一组解： {x≡a1mod m1x≡a2mod m2⋯x≡anmod mn\\begin{cases} x \\equiv a_1 \\mod m_1 \\\\ x \\equiv a_2 \\mod m_2 \\\\ \\cdots \\\\ x \\equiv a_n \\mod m_n \\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​x≡a1​modm1​x≡a2​modm2​⋯x≡an​modmn​​ 其实满足 m1,m2,⋯ ,mnm_1,m_2,\\cdots,m_nm1​,m2​,⋯,mn​ 两两互质 问题分析： 令 M=∏i=1naiM = \\prod_{i=1}^n a_iM=∏i=1n​ai​。 对于第 iii 个方程，令 pi=Mmip_i = \\frac{M}{m_i}pi​=mi​M​，计算 pip_ipi​ 在模 mim_imi​ 意义下的逆元 pi−1p_i^{-1}pi−1​，令 ci=pipi−1c_i = p_ip_i^{-1}ci​=pi​pi−1​（不对 mim_imi​ 取模）。 则答案为 x=∑i=1nciaimod Mx = \\sum_{i=1}^n c_ia_i \\mod Mx=∑i=1n​ci​ai​modM 扩展中国剩余定理 考虑合并两个方程： x≡a1mod m1x≡a2mod m2x \\equiv a_1 \\mod m_1 \\\\ x \\equiv a_2 \\mod m_2 x≡a1​modm1​x≡a2​modm2​ 可以将它们转化为不定方程即： x=m1p+a1=m2q+a2x = m_1p + a_1 = m_2q + a_2 x=m1​p+a1​=m2​q+a2​ 转化一下即 m1p−m2q=a2−a1m_1p - m_2q = a_2 - a_1m1​p−m2​q=a2​−a1​，根据裴蜀定理当 a2−a1a_2 - a_1a2​−a1​ 不能被 m1−m2m_1 - m_2m1​−m2​ 整除时无解，否则可以通过扩展欧几里得算法得到一组解 p,qp,qp,q。 这样的话就可以将原方程组合并为：x≡bmod Mx \\equiv b \\mod Mx≡bmodM，其中 b=m1p+a1，M=lcm(m1,m2)b = m_1p + a_1，M = \\text{lcm}(m_1,m_2)b=m1​p+a1​，M=lcm(m1​,m2​) Wilson 定理 ppp 为素数的充要条件为 (p−1)!≡−1mod p(p-1)! \\equiv -1 \\mod p(p−1)!≡−1modp Kummer 定理 形式一：ppp 在 (nm)\\binom{n}{m}(mn​) 中的幂次，等于 ppp 进制下 n−mn - mn−m 需要的借位次数 形式二：ppp 在 (n+mm)\\binom{n+m}{m}(mn+m​) 中的幂次，等于 ppp 进制下 n+mn+mn+m 的进位次数 Lucas 定理 若有两个正整数 n,mn,mn,m 和一个素数 ppp，则有： (nm)=(nmod pmmod p)×(⌊np⌋⌊mp⌋)\\binom{n}{m} = \\binom{n \\mod p}{m \\mod p} \\times \\binom{\\lfloor \\frac{n}{p} \\rfloor}{\\lfloor \\frac{m}{p} \\rfloor} (mn​)=(mmodpnmodp​)×(⌊pm​⌋⌊pn​⌋​) 感性的理解就是拆到 ppp 进制下，然后每一位单独考虑。 阶 定义： 对于 a∈Z，m∈N∗a \\in \\mathbb{Z}，m \\in \\mathbb{N}^*a∈Z，m∈N∗，若 (a,m)=1(a,m) = 1(a,m)=1，则满足 an≡1(modm)a^n \\equiv 1 \\pmod man≡1(modm) 的最小正整数 nnn 称为 aaa 模 mmm 的阶，记为 δm(a)\\delta_m(a)δm​(a) 或 ordm(a)\\text{ord}_m(a)ordm​(a)。 性质一： a1,a2,⋯ ,aδm(a)a^1,a^2,\\cdots,a^{\\delta_m(a)}a1,a2,⋯,aδm​(a) 模 mmm 两两不同余。 证明：考虑使用反证法，若存在 i≠ji \\not= ji=j 满足 ai≡aj(modm)a^i \\equiv a^j \\pmod mai≡aj(modm)，则必然有 a∣i−j∣≡1(modm)a^{|i-j|} \\equiv 1 \\pmod ma∣i−j∣≡1(modm)，而 0&lt;∣i−j∣&lt;δm(a)0 &lt; |i-j| &lt; \\delta_m(a)0&lt;∣i−j∣&lt;δm​(a) 与定义冲突。 性质二： 若 an≡1(modm)a^n \\equiv 1 \\pmod man≡1(modm)，则必然有 δm(a)∣n\\delta_m(a) | nδm​(a)∣n。以及据此可以推出若 ap≡aqa^p \\equiv a^qap≡aq，则 p≡q(modδm(a))p \\equiv q \\pmod{\\delta_m(a)}p≡q(modδm​(a)) 性质三： δm(ab)=δm(a)δm(b)\\delta_m(ab) = \\delta_m(a) \\delta_m(b)δm​(ab)=δm​(a)δm​(b) 的充要条件为 (δm(a),δm(b))=1(\\delta_m(a),\\delta_m(b)) = 1(δm​(a),δm​(b))=1。 性质四： δm(ak)=δm(a)(δm(a),k)\\delta_m(a^k) = \\dfrac{\\delta_m(a)}{(\\delta_m(a),k)}δm​(ak)=(δm​(a),k)δm​(a)​ 所以根据上面这些性质，阶就给了人一种“循环节”的感觉。 原根 若 δm(g)=φ(m)\\delta_m(g) = \\varphi(m)δm​(g)=φ(m)，则称 ggg 为模 mmm 意义下的原根。 性质一： ggg 是模 mmm 意义下的原根的充要条件为，对于 φ(m)\\varphi(m)φ(m) 的每个质因数 ppp，都有 gφ(m)p≢1(modm)g^{\\frac{\\varphi(m)}{p}} \\not\\equiv 1 \\pmod mgpφ(m)​≡1(modm) 性质二： 若模 mmm 意义下有原根，则原根个数为 φ(φ(m))\\varphi(\\varphi(m))φ(φ(m)) 性质三： 数 mmm 存在原根当且仅当 m=2,4,pα,2pαm = 2,4,p^{\\alpha},2p^{\\alpha}m=2,4,pα,2pα，其中 ppp 为奇质数，α∈N∗\\alpha \\in \\mathbb{N}^*α∈N∗ 性质四： 最小原根的值为 O(n0.25)O(n^{0.25})O(n0.25)，可以暴力。 BSGS 满足 (a,p)=1(a,p) = 1(a,p)=1，求解下列方程的解： ax≡b(modp)a^x \\equiv b \\pmod p ax≡b(modp) 考虑按 ttt 分块，也就是将上述式子改写为： ait+j≡b(modp)a^{it + j} \\equiv b \\pmod p ait+j≡b(modp) 移一下项也就是： aj≡b×a−it(modp)a^j \\equiv b \\times a^{-it} \\pmod p aj≡b×a−it(modp) 所以就可以直接预处理 a0,a1,⋯ ,at−1a^0,a^1,\\cdots,a^{t-1}a0,a1,⋯,at−1，然后枚举 iii，通过 hash 判断预处理的数里面是否存在 b×a−itb \\times a^{-it}b×a−it 即可。 显然当 t=pt = \\sqrt{p}t=p​ 时复杂度最优，为 O(p)O(\\sqrt{p})O(p​)。 exBSGS 不满足 (a,p)=1(a,p) = 1(a,p)=1，求解下列方程的解： ax≡b(modp)a^x \\equiv b \\pmod p ax≡b(modp) 想法就是将这个方程转化为 (a,p)=1(a,p) = 1(a,p)=1。 首先这个方程显然可以转化为： ax+kp=ba^x + kp = b ax+kp=b 设 (a,p)=d(a,p) = d(a,p)=d，根据裴蜀定理这个式子有解当且仅当 d∣bd \\mid bd∣b，所以不合法直接判无解。 这样的话这个式子就可以转化为： ax−1⋅ad+k⋅pd=bda^{x-1}\\cdot \\frac{a}{d} + k\\cdot \\frac{p}{d} = \\frac{b}{d} ax−1⋅da​+k⋅dp​=db​ 此时可以令 ax−1→ax,pd→p,bd→ba^{x-1} \\to a^x,\\frac{p}{d} \\to p,\\frac{b}{d} \\to bax−1→ax,dp​→p,db​→b，这样一直递归下去，直到 (a,p)=1(a,p) = 1(a,p)=1。 设总共递归了 cntcntcnt 次，递归过程中 ddd 的乘积为 d′d'd′，则显然原式为： ax−cnt⋅acntd′≡bd′(modpd′)a^{x-cnt}\\cdot \\frac{a^{cnt}}{d'} \\equiv \\frac{b}{d'} \\pmod{\\frac{p}{d'}} ax−cnt⋅d′acnt​≡d′b​(modd′p​) 此时直接令 a′=a,b′=bd′,p′=pd′a' = a,b' = \\frac{b}{d'},p'= \\frac{p}{d'}a′=a,b′=d′b​,p′=d′p​，跑一遍 BSGS 然后将答案加 cntcntcnt 即可。 要注意此时左边式子会多一个 acntd′\\frac{a_{cnt}}{d'}d′acnt​​ 的系数，要记得乘上。 二次剩余 定义： 若 ppp 为奇质数，且 (n,p)=1(n,p) = 1(n,p)=1，使得存在一个 xxx 满足： x2≡n(modp)x^2 \\equiv n \\pmod p x2≡n(modp) 则称 nnn 为模 ppp 意义下的二次剩余，简称二次剩余，默认 n≥1n \\ge 1n≥1。（顾名思义就是二次方后剩余的数） 二次剩余的数量： 考虑对于一个二次剩余 nnn，考虑 x2≡n(modp)x^2 \\equiv n \\pmod px2≡n(modp) 有多少个解。 若存在多个解，设其中两个解为 x0,x1x_0,x_1x0​,x1​ 且满足 x0≠x1x_0 \\not= x_1x0​=x1​，则有： x02≡x12(modp)x_0^2 \\equiv x_1^2 \\pmod p x02​≡x12​(modp) 化简一下就是： (x0−x1)(x0+x1)≡0(modp)(x_0-x_1)(x_0+x_1) \\equiv 0 \\pmod p (x0​−x1​)(x0​+x1​)≡0(modp) 因为 x0≠x1x_0 \\not= x_1x0​=x1​，所以 x0−x1≠0x_0 - x_1 \\not= 0x0​−x1​=0，即要让上述式子为 000 则必然存在 x0+x1=0(modp)x_0 + x_1 = 0\\pmod px0​+x1​=0(modp) 也就是模 ppp 意义下的一对相反数对应一个二次剩余，因为 ppp 为奇质数所以任意一对 x0,x1x_0,x_1x0​,x1​ 若满足 x0+x1=0x_0 + x_1 = 0x0​+x1​=0，则必然满足 x0≠x1x_0 \\not= x_1x0​=x1​，也就是说任意一对相反数都可以对应一个二次剩余。 还可以知道的是任意两对相反数所对应的两个二次剩余均不同，所以二次剩余的数量就是 p−12\\frac{p-1}{2}2p−1​，故非二次剩余的数量就是 p−12\\frac{p-1}{2}2p−1​ 欧拉准则： 考虑怎么快速判断一个数 nnn 是不是二次剩余。 考虑费马小定理，np−1≡1(modp)n^{p-1} \\equiv 1 \\pmod pnp−1≡1(modp)，因为 ppp 为奇质数，所以有 n2⋅p−12≡1(modp)n^{2\\cdot \\frac{p-1}{2} } \\equiv 1 \\pmod pn2⋅2p−1​≡1(modp)，也就是说 np−12n^{\\frac{p-1}{2}}n2p−1​ 是 111 的开根，因为 111 的开根只有 111 或 −1-1−1，所以 np−12n^{\\frac{p-1}{2}}n2p−1​ 只可以为 111 或者 −1-1−1。 下面考虑证明 np−12≡1(modp)n^{\\frac{p-1}{2}} \\equiv 1 \\pmod pn2p−1​≡1(modp) 与 nnn 为二次剩余等价，也就是证明充分性和必要性。 充分性，也就是已知 np−12≡1(modp)n^{\\frac{p-1}{2}} \\equiv 1 \\pmod pn2p−1​≡1(modp)，设 ggg 表示模 ppp 意义下的原根，则可以令 n=gkn = g^kn=gk，则有 gk⋅p−12≡1(modp)g^{k\\cdot \\frac{p-1}{2}} \\equiv 1 \\pmod pgk⋅2p−1​≡1(modp)，有原根的性质可得 (p−1)∣k⋅p−12(p-1) \\mid k\\cdot \\frac{p-1}{2}(p−1)∣k⋅2p−1​，也就是说 kkk 一定是偶数，即我们可以将 kkk 除以 222，所以 nnn 就是可以开根的，开根后的结果就是 x=gk2x = g^{\\frac{k}{2}}x=g2k​ 必要性，也就是已知 nnn 是二次剩余，np−12=(x2)p−12=xp−1n^{\\frac{p-1}{2}} = (x^2)^{\\frac{p-1}{2}} = x^{p-1}n2p−1​=(x2)2p−1​=xp−1，因为 xφ(p)≡1(modp)x^{\\varphi(p)} \\equiv 1 \\pmod pxφ(p)≡1(modp)，所以 xp−1≡1(modp)x^{p-1} \\equiv 1 \\pmod pxp−1≡1(modp)，即 np−12≡1(modp)n^{\\frac{p-1}{2}} \\equiv 1 \\pmod pn2p−1​≡1(modp) 所以就证明了 np−12≡1(modp)n^{\\frac{p-1}{2}} \\equiv 1 \\pmod pn2p−1​≡1(modp) 与 nnn 为二次剩余等价，所以当 np−12≡−1(modp)n^{\\frac{p-1}{2}} \\equiv -1 \\pmod pn2p−1​≡−1(modp) 时 nnn 就是非二次剩余。 Cipolla： 考虑求解 x2≡n(modp)x^2 \\equiv n \\pmod px2≡n(modp) 首先找到一个 aaa 使得 a2−na^2 - na2−n 是非二次剩余，因为非二次剩余的数的个数接近 p2\\frac{p}{2}2p​ 所以期望两次找到。 定义 i2=a2−ni^2 = a^2 - ni2=a2−n，下面就是关于怎么找到这个 iii。 可以类似复数域，定义这样的一个 iii，使得每一个数都可以被表示为 A+BiA + BiA+Bi，其中 A,BA,BA,B 都是模 ppp 意义下的。 下面考虑证明下面这个结论： (a+i)p+1≡n(modp)(a+i)^{p+1} \\equiv n \\pmod p (a+i)p+1≡n(modp) 引理 111： ip≡−i(modp)i^p \\equiv -i \\pmod pip≡−i(modp) 证明：ip=i(i2)p−12=i(a2−n)p−12=−ii^p = i(i^2)^{\\frac{p-1}{2}} = i(a^2 - n)^{\\frac{p-1}{2}} = -iip=i(i2)2p−1​=i(a2−n)2p−1​=−i 引理 222： (A+B)p≡Ap+Bp(modp)(A+B)^p \\equiv A^p + B^p \\pmod p(A+B)p≡Ap+Bp(modp) 证明：(A+B)p≡∑i=0p(pi)AiBp−i≡(pp)Ap+(p0)Bp≡Ap+Bp(modp)(A+B)^p \\equiv \\sum_{i=0}^p \\binom{p}{i} A^iB^{p-i} \\equiv \\binom{p}{p} A^p + \\binom{p}{0}B^p \\equiv A^p + B^p \\pmod p(A+B)p≡∑i=0p​(ip​)AiBp−i≡(pp​)Ap+(0p​)Bp≡Ap+Bp(modp) 有了这两个引理就可以证明了： (a+i)p+1≡(ap+ip)(a+i)≡(a−i)(a+i)≡a2−i2≡n(modp)(a+i)^{p+1} \\equiv (a^p + i^p)(a+i) \\equiv (a-i)(a+i) \\equiv a^2 - i^2 \\equiv n \\pmod p (a+i)p+1≡(ap+ip)(a+i)≡(a−i)(a+i)≡a2−i2≡n(modp) 第二个等于号 ap≡a(modp)a^p \\equiv a \\pmod pap≡a(modp) 就是扩展欧拉定理。 因为 ppp 为奇质数，所以 p+1p+1p+1 为偶数，因此 nnn 开方后的数就是 (a+i)p+12(a+i)^{\\frac{p+1}{2}}(a+i)2p+1​，即 xxx 就是 (a+i)p+12(a+i)^{\\frac{p+1}{2}}(a+i)2p+1​ 可以证明 (a+i)p+12(a+i)^{\\frac{p+1}{2}}(a+i)2p+1​ 的 “虚部” 一定为 000。 使用反证法来证明这个结论，若存在 (A+Bi)2≡n(modp)(A+Bi)^2 \\equiv n \\pmod p(A+Bi)2≡n(modp) 且 B≠0B \\not= 0B=0，那么展开之后就是 A2+B2i2+2ABi≡n(modp)A^2 + B^2i^2 + 2ABi \\equiv n \\pmod pA2+B2i2+2ABi≡n(modp)，因为右边&quot;虚部&quot;为 000 所以显然左边&quot;虚部&quot;为 000，即 AB=0AB = 0AB=0，因为 B≠0B \\not= 0B=0，所以 A=0A = 0A=0，上面式子就可以化为 B2i2≡n(modp)B^2i^2 \\equiv n \\pmod pB2i2≡n(modp)，即 i2≡nB−2(modp)i^2 \\equiv nB^{-2} \\pmod pi2≡nB−2(modp)，显然 B−2B^{-2}B−2 是一个二次剩余，而 nnn 也是一个二次剩余，所以 nB−2nB^{-2}nB−2 就是一个二次剩余，即 i2i^2i2 是一个二次剩余，这与我们的假设 i2i^2i2 不是一个二次剩余违背，故此这个结论不成立。 正整数中的数论 算术基本定理 内容： 对于任意一个大于 111 的自然数 NNN，其一定可以被唯一分解为有限个质数的乘积。 标准分解式： N=∏i=1mpikiN = \\prod_{i=1}^m p_i^{k_i}N=∏i=1m​piki​​，满足 p1&lt;p2&lt;p3⋯&lt;pmp_1 &lt; p_2 &lt; p_3 \\cdots &lt; p_mp1​&lt;p2​&lt;p3​⋯&lt;pm​ 且 p1,p2,p3,⋯ ,pmp_1,p_2,p_3,\\cdots,p_mp1​,p2​,p3​,⋯,pm​ 均为质数，kik_iki​ 均为正整数，将这样的分解称为 NNN 的标准分解式。 p 进赋值序列： 记 vp(n)=max⁡{k∈n∣pk∣n}v_p(n) = \\max\\{k \\in \\mathbb{n}\\mid p^k \\mid n\\}vp​(n)=max{k∈n∣pk∣n}，则 nnn 的 ppp 进赋值序列为 {v2(n),v3(n),v5(n),v7(n),⋯ }\\{v_2(n),v_3(n),v_5(n),v_7(n),\\cdots\\}{v2​(n),v3​(n),v5​(n),v7​(n),⋯}，即要求 ppp 均为质数。 ppp 进赋值序列可以帮助我们在数论的角度下刻画正整数，在 ppp 进赋值序列下任何一个正整数都唯一对应一个高维平面上的点，该平面每一维对应一个素数。 gcd⁡\\gcdgcd 与 lcm\\text{lcm}lcm 就可以转化为高维平面上的 min⁡\\minmin 与 max⁡\\maxmax。 狄利克雷前缀和就对应高维前缀和，狄利克雷卷积就对应着高维和卷积。 莫比乌斯函数相当于高维差分的容斥系数。 素性检测和因数分解 素性检测就是在不对给定数进行质因数分解的情况下判断这个数是否为质数。 Miller–Rabin 素性测试 引理一：费马小定理 若 ppp 为素数，aaa 为整数，若 (a,p)=1(a,p) = 1(a,p)=1，则有 ap−1≡1(modp)a^{p-1} \\equiv 1 \\pmod pap−1≡1(modp) 费马小定理只是 ppp 为素数的充分条件，如不成立则 ppp 一定为合数，若成立则 ppp 不一定为素数。 引理二：二次检测定理 若 ppp 为素数，且 0&lt;x&lt;p0 &lt; x &lt; p0&lt;x&lt;p，则 x2≡1(modp)x^2 \\equiv 1 \\pmod px2≡1(modp) 的解为 x=1x=1x=1 或 x=p−1x=p-1x=p−1 证明： x2≡1(modp)⟹x2−1≡0(modp)⟹(x+1)(x−1)≡0(modp)⟹p∣(x+1)(x−1)x^2 \\equiv 1 \\pmod p \\Longrightarrow x^2 - 1 \\equiv 0 \\pmod p \\Longrightarrow (x+1)(x-1) \\equiv 0 \\pmod p \\Longrightarrow p \\mid (x+1)(x-1)x2≡1(modp)⟹x2−1≡0(modp)⟹(x+1)(x−1)≡0(modp)⟹p∣(x+1)(x−1)。 因为 ppp 为质数，所以只有 x=1x = 1x=1 或 x=p−1x = p-1x=p−1。 下面考虑给定 ppp 判断其是否为素数。 我们将 p−1p-1p−1 写成 2k×t2^k \\times t2k×t 的形式，可以考虑随机一个数 aaa，然后计算 at(modp)a^t \\pmod pat(modp) 的值。 将这个数不断自乘，然后使用二次检测定理判断，也就是若当前的数为 AAA 满足 A×A=1A \\times A = 1A×A=1 且 A≠1A \\not= 1A=1 且 A≠p−1A \\not= p-1A=p−1，则 ppp 不是素数。 这样乘 kkk 次的结果就是 ap−1a^{p-1}ap−1，这个时候只需要判断 ap−1≡1(modp)a^{p-1} \\equiv 1 \\pmod pap−1≡1(modp) 是否满足即可，如果不满足则一定不是素数。 这样检测的正确率是不低的，可以验证的是如果我们取前 121212 个素数作为 aaa 进行检测则在 [1,264)[1,2^{64})[1,264) 内的数都不会出现问题。 时间复杂度就是 O(∣a∣log3n)O(|a|log^3n)O(∣a∣log3n) 代码实现如下： 点击查看代码 12345678910111213141516bool Miller(int P) { if(P == 1) return 0; int t = P - 1, k = 0; while(!(t &amp; 1)) k++, t &gt;&gt;= 1; for(int i = 0; i &lt; 12; i++) { if(P == Test[i]) return 1; LL a = pow(Test[i], t, P), nxt = a; for(int j = 1; j &lt;= k; j++) { nxt = (a * a) % P; if(nxt == 1 &amp;&amp; a != 1 &amp;&amp; a != P - 1) return 0; a = nxt; } if(a != 1) return 0; } return 1;} Pollard-Rho 算法 首先要明确这个算法的功能就是在 O(n14)O(n^{\\frac{1}{4}})O(n41​) 的时间内找到数 nnn 的一个因子。 一个暴力的想法就是我们每次随机一个数，判断这个数是不是因子，如果是就返回如果不是就继续随机，但是这样的复杂度就炸了。 考虑构造如下的随机数序列： 定义 f(x)=(x2+c)(modN)f(x) = (x^2 + c) \\pmod Nf(x)=(x2+c)(modN)，那么我们构造的随机数序列就是 x,f(x),f(f(x)),⋯x,f(x),f(f(x)),\\cdotsx,f(x),f(f(x)),⋯。 这个序列的样子大概就是下面这个样子： 也就是一个 ρ\\rhoρ 的形状，而根据生日悖论期望随机 O(n14)O(n^{\\frac{1}{4}})O(n41​) 个数可以找到相同的数，所以这里期望环长为 O(n14)O(n^{\\frac{1}{4}})O(n41​)。 那么如果快速判环，可以使用类似龟兔赛跑的算法，也就是设置两个变量 t,rt,rt,r，每次判断是否有 gcd(∣t−r∣,n)≠1gcd(|t-r|,n) \\not= 1gcd(∣t−r∣,n)=1 且 gcd(∣t−r∣,n)≠ngcd(|t-r|,n) \\not= ngcd(∣t−r∣,n)=n，若有则 ∣t−r∣|t-r|∣t−r∣ 就是 nnn 的一个因数，如果没有我们就令 t=f(t),r=f(f(r))t = f(t),r=f(f(r))t=f(t),r=f(f(r))，可以发现这样的话 rrr 比 ttt 跑的快也就是它们在环上一定可以相遇。 这个时候就能体现出我们这个随机序列的优势了： 若 ∣i−j∣≡0(modp)|i-j| \\equiv 0 \\pmod p∣i−j∣≡0(modp)，则有 ∣fi−fj∣=(i2−j2)=(i−j)(i+j)≡0(modp)|f_i - f_j| = (i^2 - j^2) = (i-j)(i+j) \\equiv 0 \\pmod p∣fi​−fj​∣=(i2−j2)=(i−j)(i+j)≡0(modp)，所以我们只需要对两个点之间的距离 ddd 进行判断就好，不在于哪两个点而在于他们的距离，而我们上面的龟兔赛跑也显然是枚举到了每一种距离。 直接这样做就是 O(n14log⁡n)O(n^{\\frac{1}{4}}\\log n)O(n41​logn)。 优化就是减小求 gcdgcdgcd 的次数，可以考虑设一个固定的距离 CCC 然后每隔 CCC 个求一个公因数然后判断，这样的话期望的时间复杂度就是 O(n14)O(n^\\frac{1}{4})O(n41​)。 代码实现： 点击查看代码 1234567891011121314151617181920212223242526ll Pollard_Rho(ll N){ if (N == 4) return 2; if (is_prime(N)) return N; while (1) { ll c = randint(1, N - 1); auto f = [=](ll x) { return ((lll)x * x + c) % N; }; ll t = 0, r = 0, p = 1, q; do { for (int i = 0; i &lt; 128; ++i) // 令固定距离C=128 { t = f(t), r = f(f(r)); if (t == r || (q = (lll)p * abs(t - r) % N) == 0) // 如果发现环，或者积即将为0，退出 break; p = q; } ll d = gcd(p, N); if (d &gt; 1) return d; } while (t != r); }} 数论函数和筛法 此处可以查看如下几篇 blog，推荐按顺序观看： 【学习笔记】数论入门基础 【学习笔记】欧拉函数 【学习笔记】莫比乌斯反演 【学习笔记】数论之筛法 本文只在此基础上补充几个知识点。 区间筛 给定区间 [l,r][l,r][l,r] 要求区间 [l,r][l,r][l,r] 中的素数的数量。 考虑若 x≤rx \\le rx≤r 且 xxx 不为素数，则 xxx 必然拥有一个小于等于 r\\sqrt{r}r​ 的质因子，所以只需要用 [2,r][2,\\sqrt{r}][2,r​] 筛一遍区间 [l,r][l,r][l,r] 留下来的就是素数。 一些小 tip amod b=a−a×⌊ab⌋a \\mod b = a - a\\times \\lfloor \\frac{a}{b} \\rflooramodb=a−a×⌊ba​⌋ ⌊⌊ab⌋c⌋=⌊abc⌋\\lfloor {\\frac{\\lfloor\\frac{a}{b}\\rfloor}{c}} \\rfloor = \\lfloor {\\frac{a}{bc}} \\rfloor⌊c⌊ba​⌋​⌋=⌊bca​⌋ 整除分块中如果式子中多个数整除，复杂度是加而不是乘。 集合幂级数 FWT 与 FMT FWT 与 FMT 是解决如下问题的工具： ck=∑i⊕j=kaibjc_k = \\sum_{i\\oplus j = k}a_ib_j ck​=i⊕j=k∑​ai​bj​ 其中 ⊕\\oplus⊕ 为二进制下的 and or xor 三种运算之一。 下面将 FWT 与 FMT 统称为 FWT。 其解决这个问题的思路也类似 FFT，就是将序列 a,ba,ba,b 转化为某种变换 FWT(a),FWT(b)\\text{FWT}(a),\\text{FWT}(b)FWT(a),FWT(b) 然后乘起来得到 FWT(c)\\text{FWT}(c)FWT(c) 后反演得到 ccc。 OR 要求： ck=∑i∣j=kaibjc_k = \\sum_{i | j = k} a_ib_j ck​=i∣j=k∑​ai​bj​ 考虑若 i∣k=ki \\mid k = ki∣k=k 且 j∣k=kj \\mid k = kj∣k=k 则 (i∣j)∣k=k(i\\mid j) \\mid k = k(i∣j)∣k=k，就使用这个来设计变换。 即 FWTor(A)k=∑i∣k=kAi\\text{FWT}_{or}(A)_k = \\sum_{i\\mid k = k} A_iFWTor​(A)k​=∑i∣k=k​Ai​ 也就是 iii 为 kkk 的子集才可以转移。 那考虑为什么这样是对的： FWTor(A)=∑k(∑i∣k=kAi)×(∑j∣k=kBj)=∑k∑i∣k=k∑j∣k=kAiBj=∑k∑(i∣j)∣k=kAiBj\\begin{aligned} \\text{FWT}_{or}(A) &amp;= \\sum_{k} (\\sum_{i \\mid k = k}A_i) \\times (\\sum_{j \\mid k = k} B_j) \\\\ &amp;= \\sum_{k} \\sum_{i \\mid k = k}\\sum_{j \\mid k = k} A_iB_j \\\\ &amp;= \\sum_{k} \\sum_{(i \\mid j) \\mid k = k} A_iB_j \\end{aligned} FWTor​(A)​=k∑​(i∣k=k∑​Ai​)×(j∣k=k∑​Bj​)=k∑​i∣k=k∑​j∣k=k∑​Ai​Bj​=k∑​(i∣j)∣k=k∑​Ai​Bj​​ 所以这个变换就是正确的。 那么考虑如何快速进行这个变换，类似 FFT 每次合并两个长度为 2n2^n2n 的段，设不同的最高位为 111 的序列为 A1A_1A1​，为 000 的序列为 A0A_0A0​，则根据 ororor 的性质 A0A_0A0​ 可以转移到 A1A_1A1​，而 A1A_1A1​ 不能转移到 A0A_0A0​，也就是形如下面这样： FWTor(A)=(FWTor(A0),FWTor(A0)+FWTor(A1))\\text{FWT}_{or}(A) = (\\text{FWT}_{or}(A_0),\\text{FWT}_{or}(A_0) + \\text{FWT}_{or}(A_1)) FWTor​(A)=(FWTor​(A0​),FWTor​(A0​)+FWTor​(A1​)) 其中 A+BA + BA+B 是对应系数相加，(A,B)(A,B)(A,B) 就是按顺序写下 A,BA,BA,B。 逆变换就是逆着做这个操作就好了，即： IFWTor(A)=(IFWTor(A0),IFWTor(A1)−IFWTor(A0))\\text{IFWT}_{or}(A) = (\\text{IFWT}_{or}(A_0),\\text{IFWT}_{or}(A_1) - \\text{IFWT}_{or}(A_0)) IFWTor​(A)=(IFWTor​(A0​),IFWTor​(A1​)−IFWTor​(A0​)) 代码： 点击查看代码 123456789101112void Or(ll *x,int n,int op){ for(int l=1;l&lt;n;l&lt;&lt;=1){ for(int st=0;st&lt;n;st+=l*2){ for(int i=0;i&lt;l;i++){ ll u=x[st+i],v=x[st+l+i]; if(op==1) x[st+i]=u,x[st+l+i]=(v+u)%mod; else x[st+i]=u,x[st+l+i]=(v+mod-u)%mod; } } }} AND 要求： ck=∑i&amp;j=kaibjc_k = \\sum_{i \\&amp; j = k} a_ib_j ck​=i&amp;j=k∑​ai​bj​ 考虑若 i&amp;k=ki \\&amp; k = ki&amp;k=k 且 j&amp;k=kj \\&amp; k = kj&amp;k=k 则 (i&amp;j)&amp;k=k(i\\&amp;j) \\&amp; k = k(i&amp;j)&amp;k=k，所以可以构造如下的变换：FWTand(A)k=∑i&amp;k=kAi\\text{FWT}_{and}(A)_k = \\sum_{i\\&amp;k=k} A_iFWTand​(A)k​=∑i&amp;k=k​Ai​ 也就是 iii 为 kkk 的超集时产生贡献。 变化的与上文同理： FWTand(A)=(FWTand(A0)+FWTand(A1),FWTand(A1))IFWTand(A)=(IFWTand(A0)−IFWTand(A1),IFWTand(A1))\\text{FWT}_{and}(A) = (\\text{FWT}_{and}(A_0)+\\text{FWT}_{and}(A_1),\\text{FWT}_{and}(A_1)) \\\\ \\text{IFWT}_{and}(A) = (\\text{IFWT}_{and}(A_0)-\\text{IFWT}_{and}(A_1),\\text{IFWT}_{and}(A_1)) FWTand​(A)=(FWTand​(A0​)+FWTand​(A1​),FWTand​(A1​))IFWTand​(A)=(IFWTand​(A0​)−IFWTand​(A1​),IFWTand​(A1​)) 代码： 点击查看代码 123456789101112void And(ll *x,int n,int op){ for(int l=1;l&lt;n;l&lt;&lt;=1){ for(int st=0;st&lt;n;st+=l*2){ for(int i=0;i&lt;l;i++){ ll u=x[st+i],v=x[st+l+i]; if(op==1) x[st+i]=(u+v)%mod,x[st+l+i]=v; else x[st+i]=(u+mod-v)%mod,x[st+l+i]=v; } } }} XOR 要求： ck=∑i⊕j=kaibjc_k = \\sum_{i \\oplus j = k} a_ib_j ck​=i⊕j=k∑​ai​bj​ 设 d(x)d(x)d(x) 表示二进制下 xxx 的 111 的个数的奇偶性，则有如下性质：d(i&amp;k)⊕d(j&amp;k)=d((i⊕j)&amp;k)d(i\\&amp;k)\\oplus d(j\\&amp;k) = d((i\\oplus j) \\&amp; k)d(i&amp;k)⊕d(j&amp;k)=d((i⊕j)&amp;k)。 证明：因为我们是与操作，所以可以只考虑 kkk 为 111 的位。若某一位上 i,ji,ji,j 同时为 000 或 111 则显然不会有什么影响，若某一位上 i,ji,ji,j 分别为 0,10,10,1 那么左右两边都是同步变化的，所有也是一样的。 所以可以设计出以下的变换： FWTxor(A)k=∑i(−1)d(i&amp;k)Ai\\text{FWT}_{xor}(A)_k = \\sum_{i} (-1)^{d(i\\&amp;k)} A_i FWTxor​(A)k​=i∑​(−1)d(i&amp;k)Ai​ 可以乘一下看看是不是对的： FWTxor(C)=∑k(∑i(−1)d(i&amp;k)Ai)(∑j(−1)d(j&amp;k)Bj)=∑k∑i∑j(−1)d(i&amp;k)+d(j&amp;k)AiBj=∑k∑i,j(−1)d(i&amp;k)⊕d(j&amp;k)AiBj=∑k∑i,j(−1)d((i⊕j)&amp;k)AiBj\\begin{aligned} \\text{FWT}_{xor}(C) &amp;= \\sum_{k} (\\sum_{i} (-1)^{d(i\\&amp;k)} A_i) (\\sum_{j} (-1)^{d(j\\&amp;k)} B_j) \\\\ &amp;= \\sum_{k} \\sum_{i} \\sum_{j} (-1)^{d(i\\&amp;k) + d(j\\&amp;k)} A_iB_j \\\\ &amp;= \\sum_{k} \\sum_{i,j} (-1)^{d(i\\&amp;k)\\oplus d(j\\&amp;k)} A_iB_j \\\\ &amp;= \\sum_{k} \\sum_{i,j} (-1)^{d((i\\oplus j)\\&amp;k)} A_iB_j \\end{aligned} FWTxor​(C)​=k∑​(i∑​(−1)d(i&amp;k)Ai​)(j∑​(−1)d(j&amp;k)Bj​)=k∑​i∑​j∑​(−1)d(i&amp;k)+d(j&amp;k)Ai​Bj​=k∑​i,j∑​(−1)d(i&amp;k)⊕d(j&amp;k)Ai​Bj​=k∑​i,j∑​(−1)d((i⊕j)&amp;k)Ai​Bj​​ 这样就形式化对了，所以这个就是正确的。 考虑怎么快速求解，其实就是新加一位，而新加一位只有 111 贡献到 111 会导致奇偶性改变，也就是取负，其它的都没有变化。 即： FWTxor(A)=(FWTxor(A0)+FWTxor(A1),FWTxor(A0)−FWTxor(A1))\\text{FWT}_{xor}(A) = (\\text{FWT}_{xor}(A_0) + \\text{FWT}_{xor}(A_1),\\text{FWT}_{xor}(A_0) - \\text{FWT}_{xor}(A_1)) FWTxor​(A)=(FWTxor​(A0​)+FWTxor​(A1​),FWTxor​(A0​)−FWTxor​(A1​)) 逆变换其实就是考虑 A0,A1A_0,A_1A0​,A1​ 已经变成上面那个东西了，怎么还原回来的，就是： IFWTxor(A)=(IFWTxor(A0)+IFWTxor(A1)2,IFWTxor(A0)−IFWTxor(A1)2)\\text{IFWT}_{xor}(A) = (\\frac{\\text{IFWT}_{xor}(A_0) + \\text{IFWT}_{xor}(A_1)}{2},\\frac{\\text{IFWT}_{xor}(A_0) - \\text{IFWT}_{xor}(A_1)}{2}) IFWTxor​(A)=(2IFWTxor​(A0​)+IFWTxor​(A1​)​,2IFWTxor​(A0​)−IFWTxor​(A1​)​) 代码： 点击查看代码 1234567891011void Xor(ll *x,int n,int op){ for(int l=1;l&lt;n;l&lt;&lt;=1){ for(int st=0;st&lt;n;st+=l*2){ for(int i=0;i&lt;l;i++){ ll u=x[st+i],v=x[st+l+i]; if(op==1) x[st+i]=(u+v)%mod,x[st+l+i]=(u+mod-v)%mod; else x[st+i]=(u+v)%mod*inv2%mod,x[st+l+i]=(u+mod-v)%mod*inv2%mod; } } }} FWT 的一些性质 FWT 的本质是一个线性变换，也就是： FWT(A+B)=FWT(A)+FWT(B)\\text{FWT}(A+B) = \\text{FWT}(A) + \\text{FWT}(B)FWT(A+B)=FWT(A)+FWT(B)，FWT(cA)=cFWT(A)\\text{FWT}(cA) = c\\text{FWT}(A)FWT(cA)=cFWT(A) 集合幂级数 位运算是 OI 中的常考知识点，因为位运算中每一位的独立性，所以可以将其看作两个 {0,1}n\\{0,1\\}^n{0,1}n 上的向量的运算。 生成函数是刻画序列的有力工具，而集合幂级数就是处理集合（位运算）的一种特殊形式。对于序列 a0,a1,⋯ ,a2n−1a_0,a_1,\\cdots,a_{2^n-1}a0​,a1​,⋯,a2n−1​ 我们可以定义其集合幂级数 A(x)=∑i=02n−1aixiA(x) = \\sum \\limits_{i=0}^{2^n-1}a_ix^iA(x)=i=0∑2n−1​ai​xi。 定义集合幂级数的乘法操作，也就是子集卷积为如下的形式； ci=∑j∣k=ij&amp;k=0ajbk\\begin{aligned} c_i = \\sum_{j \\mid k = i \\quad j \\&amp; k = 0} a_jb_k \\end{aligned} ci​=j∣k=ij&amp;k=0∑​aj​bk​​ 组合意义就是选择两个不交的集合，可以直接枚举子集就可以做到 O(3n)O(3^n)O(3n)。 可以构造占位函数 w(x)=popcount(x)w(x) = \\text{popcount}(x)w(x)=popcount(x)，这样上述条件可以等价为 j xor k=ij \\ \\text{xor} \\ k = ij xor k=i 且 w(j)+w(k)=w(i)w(j) + w(k) = w(i)w(j)+w(k)=w(i)，这样就可以以 w(x)w(x)w(x) 来构造一个二元集合幂级数 A(x,y)=∑i=02n−1aixiyw(i)A(x,y) = \\sum \\limits_{i=0}^{2^n-1} a_ix^iy^{w(i)}A(x,y)=i=0∑2n−1​ai​xiyw(i)，而子集卷积就相当于对于第一维异或卷积，第二维和卷积，都是可以做的，所以就可以一维维来做，时间复杂度 O(n22n)O(n^22^n)O(n22n)。 因为不出意外的话我们第二维都为 O(log⁡n)O(\\log n)O(logn) 级别，所以直接暴力做和卷积就没问题，不用再写 FFT 了。 代码： 点击查看代码 1234567891011121314int main(){ m=read();n=(1&lt;&lt;m); for (int i=1;i&lt;n;i++)c[i]=c[i&gt;&gt;1]+(i&amp;1); for (int i=0;i&lt;n;i++)F[i].a[c[i]]=read(); for (int i=0;i&lt;n;i++)G[i].a[c[i]]=read(); FWT(F,n);FWT(G,n); for (int i=0;i&lt;n;i++) F[i]=F[i]*G[i]; IFWT(F,n); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,(F[i].a[c[i]]+mod)%mod); return 0;} 这个技巧就被称为占位多项式，有了这个占位多项式我们就可以对集合幂级数做各种多项式的操作，但是那东西我完全不会，就不说了。 组合计数 计数原理 加法原理： 若完成某道工序有两种方法，第一种方法的实现方式有 aaa 种，第二种方法的实现方式有 bbb 种，则完成这道工序的实现方法有 a+ba+ba+b 种。 乘法原理： 若完成某道工序有两个步骤，第一个步骤有 aaa 种实现方式，第二个步骤有 bbb 种实现方式，则完成这道工序的实现方法有 ababab 种。 其实只需要观察它们是不是相互独立的就可以判断出应使用加法原理还是乘法原理。 算两次原理（富比尼原理）： 将同一个量同两个不同角度计算两次，从而建立等量关系。 这东西看上去很玄乎，但是其实放在 OI 中就是：维度的变换（枚举下标/权值）、贡献的计算（直接计算/增量计算）等，从不同的角度解决问题，并在选取了合适的角度之后通过其它的方法解决问题。 例题 P8557 炼金术： 有 kkk 个熔炉，每个熔炉可以随机炼出 nnn 种金属中的一些，当 nnn 种金属都被炼制出来过该方案就是合法的，询问有多少种合法的方案。 考虑按每一种金属考虑，其在每一个熔炉中都可以出现或者不出现，所以方案数为 222，而其在 kkk 个熔炉中出现的情况相互独立，所以方案数为 2k2^k2k，但是这个金属必须要在某一个熔炉中出现，所以真实的方案数为 2k−12^k-12k−1。 对于不同的金属之间相互独立，所以总方案数为 (2k−1)n(2^k-1)^n(2k−1)n。 鸽巢原理： nnn 个小球放到 mmm 个抽屉中，至少有一个抽屉放了大于等于 ⌈nm⌉\\lceil \\frac{n}{m} \\rceil⌈mn​⌉ 个。 这个原理常用于结论的证明，以及一些极端情况的求解等。 组合数 组合数的计算 递推形式：(nm)=(n−1m)+(n−1m−1)\\binom{n}{m} = \\binom{n-1}{m} + \\binom{n-1}{m-1}(mn​)=(mn−1​)+(m−1n−1​)。 阶乘形式：(nm)=n!m!(n−m)!=nm‾m!\\binom{n}{m} = \\frac{n!}{m!(n-m)!} = \\frac{n^{\\underline{m}}}{m!}(mn​)=m!(n−m)!n!​=m!nm​​ Lucas 定理：(nm)=(nmod pmmod p)×(⌊np⌋⌊mp⌋)\\binom{n}{m} = \\binom{n \\mod p}{m \\mod p} \\times \\binom{\\lfloor \\frac{n}{p} \\rfloor}{\\lfloor \\frac{m}{p} \\rfloor}(mn​)=(mmodpnmodp​)×(⌊pm​⌋⌊pn​⌋​) 组合恒等式： 吸收恒等式： (nm)=nm(n−1m−1)\\binom{n}{m} = \\frac{n}{m} \\binom{n-1}{m-1}(mn​)=mn​(m−1n−1​)，移项得 m(nm)=n(n−1m−1)m\\binom{n}{m} = n\\binom{n-1}{m-1}m(mn​)=n(m−1n−1​) 证明：根据组合数的阶乘形式易得 行求和：∑i=0n(ni)=2n\\sum_{i=0}^n \\binom{n}{i} = 2^n∑i=0n​(in​)=2n 证明：根据二项式定理 (1+1)n=∑i=0n(ni)=2n(1+1)^n = \\sum_{i=0}^n \\binom{n}{i} = 2^n(1+1)n=∑i=0n​(in​)=2n 列求和：∑i=nm(in)=(m+1n+1)\\sum_{i=n}^m \\binom{i}{n} = \\binom{m+1}{n+1}∑i=nm​(ni​)=(n+1m+1​) 证明：(nn)+(n+1n)+(n+2n)+⋯+(mn)=(n+1n+1)+(n+1n)+(n+2n)+⋯+(mn)=(n+2n+1)+(n+2n)+⋯+(mn)=(mn+1)+(mn)=(m+1n+1)\\binom{n}{n} + \\binom{n+1}{n} + \\binom{n+2}{n} + \\cdots + \\binom{m}{n} = \\binom{n+1}{n+1} + \\binom{n+1}{n} + \\binom{n+2}{n} + \\cdots + \\binom{m}{n} = \\binom{n+2}{n+1} + \\binom{n+2}{n} + \\cdots + \\binom{m}{n} = \\binom{m}{n+1} + \\binom{m}{n} = \\binom{m+1}{n+1}(nn​)+(nn+1​)+(nn+2​)+⋯+(nm​)=(n+1n+1​)+(nn+1​)+(nn+2​)+⋯+(nm​)=(n+1n+2​)+(nn+2​)+⋯+(nm​)=(n+1m​)+(nm​)=(n+1m+1​)，主要是使用了组合数的递推形式。 范德蒙德卷积：∑i=0k(ni)×(mk−i)=(n+mk)\\sum_{i=0}^k \\binom{n}{i}\\times\\binom{m}{k-i} = \\binom{n+m}{k}∑i=0k​(in​)×(k−im​)=(kn+m​) 证明：考虑我们枚举的其实就是 nnn 个里面选 iii 个和 mmm 个里面选 k−ik-ik−i 个，显然可以合并起来。 组合数的应用： 隔板法：nnn 个相同的小球放到 mmm 个不同的盒子里，每个盒子里必须至少放一个小球，方案数为 (n−1m−1)\\binom{n-1}{m-1}(m−1n−1​)。 证明：考虑将 nnn 个小球放到一排，这样中间就出现了 n−1n-1n−1 个缝隙，放到 kkk 个不同的盒子中相当于划分为 kkk 段也就是选择 k−1k-1k−1 个缝隙放上隔板，方案数就是 (n−1m−1)\\binom{n-1}{m-1}(m−1n−1​)。 扩展： 如果将要求改为每个盒子可以不放小球，那么方案数就是 (n+m−1m−1)\\binom{n+m-1}{m-1}(m−1n+m−1​)，可以理解为先将所有的盒子提前放上一个小球，这样就必须至少放 111 个了。 捆绑法：有 nnn 个不同的人站队，要求其中两个人必须相邻，方案数为 (n−1)!×2!(n-1)! \\times 2!(n−1)!×2!。 证明：将这两个人视为一个人去站队方案数为 (n−1)!(n-1)!(n−1)!，而两个人内部也可以随便站方案数为 2!2!2!。 格路计数：给定一个 n×mn \\times mn×m 的网格，每次可以从 (x,y)(x,y)(x,y) 走到 (x+1,y)(x+1,y)(x+1,y) 或者 (x,y+1)(x,y+1)(x,y+1)，从 (1,1)(1,1)(1,1) 走到 (n,m)(n,m)(n,m) 的方案数为 (n+mn)\\binom{n+m}{n}(nn+m​)。 证明：我们总共要走 n+mn+mn+m 步才能走到 (n,m)(n,m)(n,m) 这其中有 nnn 步是执行 (x,y)→(x+1,y)(x,y) \\to (x+1,y)(x,y)→(x+1,y)，而且这 nnn 步可以在任意位置。 卡特兰数：见数论之生成函数基础。 prufer 序列 对于一棵有 nnn 个节点的带标号树，其 prufer 序列一定是一个长度为 n−2n-2n−2 值域为 [1,n][1,n][1,n] 的序列。 树转化为 prufer 序列： 选择树上编号最小的叶子节点，将其父亲插入到序列的末尾 删除这个选择的叶子节点 重复上述步骤直到树中只剩下两个节点 注意到我们的 prufer 序列与树构成一个双射，所以我们可以由 prufer 序列还原对应的树。 选择编号最小的一个叶子节点（即从未在序列中出现的点），其父亲就是序列第 iii 个数。（iii 初始为 111） 点 xxx 的度数为 xxx 的出现次数加 111，所以可以删除这个叶子节点，然后将其父亲的度数减 111，直到其父亲度数变为 111 就成为了叶子节点。 重复上述两步，直到序列全部被用完。 可以发现这样构造出的 prufer 序列有如下的性质： 剩下的两个节点中，一定有一个为 nnn 号节点 对于一个 nnn 度点，其会在 prufer 序列中出现 n−1n-1n−1 次 应用： 无向完全图生成树计数：若该完全图点数为 nnn，则任意一个长度为 n−2n-2n−2 的值域为 [1,n][1,n][1,n] 的序列都可以还原出一棵生成树，所以方案数即 nn−2n^{n-2}nn−2，与 Cayley 定理的结论一致。 Cayley 定理：假设图中有 mmm 个连通块，连通块内的点数为 a1,a2,⋯ ,ama_1,a_2,\\cdots,a_ma1​,a2​,⋯,am​，且满足 a1+a2+⋯+am=na_1 + a_2 + \\cdots + a_m = na1​+a2​+⋯+am​=n，则选择 m−1m-1m−1 条边将图联通的方案数为 nm−2∏i=1main^{m-2}\\prod_{i=1}^m a_inm−2∏i=1m​ai​ 广义 Cayley 定理：nnn 个有标号的点形成的包含 kkk 棵树的森林，要求给定的 kkk 个点没有两个点属于同一棵树的方案数为 k×nn−k−1k \\times n^{n-k-1}k×nn−k−1。 nnn 个点的有根树计数：因为每个点都可以作为根，所以答案为 n×nn−2=nn−1n \\times n^{n-2} = n^{n-1}n×nn−2=nn−1 容斥原理 最基本的式子就是交集与并集的转化： 设 SSS 为有限集，Ai⊆S（i∈[1,n]）A_i \\subseteq S（i \\in [1,n]）Ai​⊆S（i∈[1,n]），则有： ∣⋃i=1nAi∣=∑T⊆[1,n](−1)∣T∣−1∣⋂j∈TAj∣=∑k=1n(−1)k−1∑b1&lt;b2&lt;b3&lt;⋯&lt;bk∣⋂j=1kAbj∣\\left| \\bigcup\\limits_{i=1}^n A_i \\right| = \\sum_{T \\subseteq [1,n]} (-1)^{|T|-1} \\left| \\bigcap\\limits_{j \\in T} A_j \\right| = \\sum_{k=1}^{n} (-1)^{k-1} \\sum_{b_1 &lt; b_2 &lt; b_3 &lt; \\cdots &lt; b_k} \\left| \\bigcap\\limits_{j=1}^k A_{b_j} \\right| ∣∣∣∣∣∣​i=1⋃n​Ai​∣∣∣∣∣∣​=T⊆[1,n]∑​(−1)∣T∣−1∣∣∣∣∣∣∣​j∈T⋂​Aj​∣∣∣∣∣∣∣​=k=1∑n​(−1)k−1b1​&lt;b2​&lt;b3​&lt;⋯&lt;bk​∑​∣∣∣∣∣∣​j=1⋂k​Abj​​∣∣∣∣∣∣​ 证明：考虑元素 xxx 属于 mmm 个 AAA，则其产生的贡献就是这个式子 ∑i=1m(−1)i−1(mi)=−(∑i=1m(−1)i(mi))=−(−1+∑i=0m(−1)i(mi))=−(−1+(1−1)m)=1\\sum_{i=1}^m (-1)^{i-1} \\binom{m}{i} = -(\\sum_{i=1}^m (-1)^i \\binom{m}{i}) = -(-1 + \\sum_{i=0}^m (-1)^i \\binom{m}{i}) = -(-1 + (1-1)^m) = 1∑i=1m​(−1)i−1(im​)=−(∑i=1m​(−1)i(im​))=−(−1+∑i=0m​(−1)i(im​))=−(−1+(1−1)m)=1 直观理解这个式子就是将满足 A1A_1A1​ 或满足 A2A_2A2​ 或 ⋯\\cdots⋯ 的元素个数转化为了强制同时满足某些条件的元素个数。 当然有的时候也要有一些直观的理解，比如 [a,b][a,b][a,b] 中满足 AAA 的数的个数可以转化为 [1,b][1,b][1,b] 中满足的个数减去 [1,a−1][1,a-1][1,a−1] 中满足的个数；满足 AAA 的个数可以转化为无所谓的个数减去不满足 AAA 的个数等。 在容斥以及反演过程中常使用二项式定理证明结论。 反演 反演其实就是容斥原理的代数形式，下面就简单介绍几种反演。 通过这些反演推导的练习，相信你一定会学会如何推导容斥系数。 二项式反演 形式一： F(n)=∑i=0n(−1)i(ni)G(i) ⟺ G(n)=∑i=0n(−1)i(ni)F(i)F(n) = \\sum_{i=0}^n (-1)^i \\binom{n}{i} G(i) \\iff G(n) = \\sum_{i=0}^n (-1)^i \\binom{n}{i} F(i) F(n)=i=0∑n​(−1)i(in​)G(i)⟺G(n)=i=0∑n​(−1)i(in​)F(i) 证明： 这里只证明充分性，必要性显然成立。 也就是得到在计算 G(n)G(n)G(n) 的时候 G(i)G(i)G(i) 的系数是多少，要证明的就是后面这个式子 G(n)G(n)G(n) 的系数为 111，其余的系数为 000。 下面就是考虑计算 G(i)G(i)G(i) 的系数，一个想法就是枚举所有的 F(j)F(j)F(j) 然后将 F(j)F(j)F(j) 中 G(i)G(i)G(i) 的系数求和。 ans=∑j=in(−1)j(nj)(−1)i(ji)=(−1)i∑j=in(−1)jn!j!j!(n−j)!i!(j−i)!=(−1)i∑j=in(−1)jn!i!(n−i!)×(n−i)!(n−j)!(j−i)!=(−1)i(ni)∑j=in(−1)j(n−in−j)=(−1)i(ni)∑j=0n−i(−1)j+1(n−jn−j−i)=(−1)2i(ni)∑j=0n−i(−1)j(n−ij)=(−1)2i(ni)(1−1)n−i=[n=i]\\begin{aligned} ans &amp;= \\sum_{j=i}^n (-1)^j \\binom{n}{j} (-1)^i \\binom{j}{i} \\\\ &amp;= (-1)^i \\sum_{j=i}^n (-1)^j \\frac{n!j!}{j!(n-j)!i!(j-i)!} \\\\ &amp;= (-1)^i \\sum_{j=i}^n (-1)^j \\frac{n!}{i!(n-i!)} \\times \\frac{(n-i)!}{(n-j)!(j-i)!} \\\\ &amp;= (-1)^i \\binom{n}{i} \\sum_{j=i}^n (-1)^j \\binom{n-i}{n-j} \\\\ &amp;= (-1)^i \\binom{n}{i} \\sum_{j=0}^{n-i} (-1)^{j+1} \\binom{n-j}{n-j-i} \\\\ &amp;= (-1)^{2i} \\binom{n}{i} \\sum_{j=0}^{n-i} (-1)^j \\binom{n-i}{j} \\\\ &amp;= (-1)^{2i} \\binom{n}{i} (1-1)^{n-i} \\\\ &amp;= [n = i] \\end{aligned} ans​=j=i∑n​(−1)j(jn​)(−1)i(ij​)=(−1)ij=i∑n​(−1)jj!(n−j)!i!(j−i)!n!j!​=(−1)ij=i∑n​(−1)ji!(n−i!)n!​×(n−j)!(j−i)!(n−i)!​=(−1)i(in​)j=i∑n​(−1)j(n−jn−i​)=(−1)i(in​)j=0∑n−i​(−1)j+1(n−j−in−j​)=(−1)2i(in​)j=0∑n−i​(−1)j(jn−i​)=(−1)2i(in​)(1−1)n−i=[n=i]​ 所以系数就正确了，得证。 形式二： F(n)=∑i=0n(ni)G(i) ⟺ G(n)=∑i=0n(−1)n−i(ni)F(i)F(n) = \\sum_{i=0}^n \\binom{n}{i} G(i) \\iff G(n) = \\sum_{i=0}^n (-1)^{n-i} \\binom{n}{i}F(i) F(n)=i=0∑n​(in​)G(i)⟺G(n)=i=0∑n​(−1)n−i(in​)F(i) 证明： 考虑使用 EGF 证明； F(n)=∑i=0nn!(n−i)!i!G(i)F(n)n!=∑i=0n1(n−i)!G(i)i!F(n) = \\sum_{i=0}^n \\frac{n!}{(n-i)!i!}G(i) \\\\ \\frac{F(n)}{n!} = \\sum_{i=0}^n \\frac{1}{(n-i)!} \\frac{G(i)}{i!} F(n)=i=0∑n​(n−i)!i!n!​G(i)n!F(n)​=i=0∑n​(n−i)!1​i!G(i)​ 这个式子显然就是一个卷积的形式也就是： F=G∗ex ⟺ G=F∗e−xF = G * e^x \\iff G = F * e^{-x} F=G∗ex⟺G=F∗e−x 所以： G(n)n!=∑i=0n(−1)n−i(n−i)!F(i)i!\\frac{G(n)}{n!} = \\sum_{i=0}^n \\frac{(-1)^{n-i}}{(n-i)!} \\frac{F(i)}{i!} n!G(n)​=i=0∑n​(n−i)!(−1)n−i​i!F(i)​ 移项之后就是： G(n)=∑i=0n(−1)n−i(ni)F(i)G(n) = \\sum_{i=0}^n (-1)^{n-i} \\binom{n}{i} F(i) G(n)=i=0∑n​(−1)n−i(in​)F(i) 得证。 形式三： F(n)=∑i=n(in)G(i) ⟺ G(n)=∑i=n(−1)i−n(in)F(i)F(n) = \\sum_{i=n} \\binom{i}{n} G(i) \\iff G(n) = \\sum_{i=n} (-1)^{i-n} \\binom{i}{n} F(i) F(n)=i=n∑​(ni​)G(i)⟺G(n)=i=n∑​(−1)i−n(ni​)F(i) 形式四： F(n)=∑i=n(−1)i(in)G(i) ⟺ G(n)=∑i=n(−1)i(in)F(i)F(n) = \\sum_{i=n} (-1)^i \\binom{i}{n} G(i) \\iff G(n) = \\sum_{i=n} (-1)^i \\binom{i}{n} F(i) F(n)=i=n∑​(−1)i(ni​)G(i)⟺G(n)=i=n∑​(−1)i(ni​)F(i) 这两种形式都可以通过慢慢推的方式证明，因为形式一已经类似证明过了就不证明了。 莫比乌斯反演 请查看： 【学习笔记】数论入门基础 【学习笔记】莫比乌斯反演 Min-Max 容斥 定义全集 U={a1,a2,a3,⋯ ,an}U = \\{a_1,a_2,a_3,\\cdots,a_n\\}U={a1​,a2​,a3​,⋯,an​}，有一个集合 SSS，则 max⁡(S)=max⁡ai∈Sai\\max(S) = \\max \\limits_{a_i \\in S} a_imax(S)=ai​∈Smax​ai​，min⁡(S)=min⁡ai∈Sai\\min(S) = \\min \\limits_{a_i\\in S} a_imin(S)=ai​∈Smin​ai​。 则有如下结论： max⁡(S)=∑T⊆S(−1)∣T∣+1min⁡(T)min⁡(S)=∑T⊆S(−1)∣T∣+1max⁡(T)\\max(S) = \\sum_{T \\subseteq S} (-1)^{|T|+1} \\min(T) \\\\ \\min(S) = \\sum_{T \\subseteq S} (-1)^{|T|+1} \\max(T) max(S)=T⊆S∑​(−1)∣T∣+1min(T)min(S)=T⊆S∑​(−1)∣T∣+1max(T) 下面考虑证明第一个式子。 一样的套路，假设元素 xxx 为第 kkk 大，钦定 xxx 为集合中的最小值，那么它在后面的式子里对答案贡献的系数是什么，可以枚举大于 xxx 的数选择多少个。 =∑i=0k−1(k−1i)(−1)i+2=∑i=0k−1(k−1i)(−1)i=(1−1)k−1=[k=1]\\begin{aligned} &amp;= \\sum_{i=0}^{k-1} \\binom{k-1}{i} (-1)^{i+2} \\\\ &amp;= \\sum_{i=0}^{k-1} \\binom{k-1}{i} (-1)^i \\\\ &amp;= (1-1)^{k-1} \\\\ &amp;= [k=1] \\end{aligned} ​=i=0∑k−1​(ik−1​)(−1)i+2=i=0∑k−1​(ik−1​)(−1)i=(1−1)k−1=[k=1]​ 所以只有最大值会产生 111 的贡献，其他都会产生 000 的贡献，得证。 要注意的一点就是 Min-Max 容斥在期望意义下依然成立，即： E(max⁡(S))=∑T⊆S(−1)∣T∣+1min⁡(T)E(\\max(S)) = \\sum_{T \\subseteq S} (-1)^{|T|+1} \\min(T) E(max(S))=T⊆S∑​(−1)∣T∣+1min(T) 如果我们要求第 kkk 大也是可以容斥出来的： Kthmax⁡(S)=∑T⊆S(−1)∣T∣−k(∣T∣−1k−1)min⁡(T)K_{th}\\max(S) = \\sum_{T \\subseteq S} (-1)^{|T| - k} \\binom{|T|-1}{k-1} \\min(T) Kth​max(S)=T⊆S∑​(−1)∣T∣−k(k−1∣T∣−1​)min(T) 这个容斥系数我们是可以很简单推导出来的。 考虑设： Kthmax⁡(S)=∑T⊆SF(∣T∣)min⁡(T)K_{th}\\max(S) = \\sum_{T \\subseteq S} F(|T|) \\min(T) Kth​max(S)=T⊆S∑​F(∣T∣)min(T) 考虑若 xxx 为第 ppp 大，则由上文可知其贡献即： ∑i=0p−1(p−1i)F(i+1)\\sum_{i=0}^{p-1} \\binom{p-1}{i} F(i+1) i=0∑p−1​(ip−1​)F(i+1) 我们的目的就要让这个式子的值等于 [p=k][p=k][p=k]，也就是： ∑i=0p(pi)F(i+1)=[p=k−1]\\sum_{i=0}^{p} \\binom{p}{i} F(i+1) = [p=k-1] i=0∑p​(ip​)F(i+1)=[p=k−1] 这个就是一个二项式反演的形式，所以就有： F(p+1)=∑i=0p(−1)p−i(pi)[i=k−1]=(−1)p−k+1(pk−1)F(p+1) = \\sum_{i=0}^p (-1)^{p-i} \\binom{p}{i} [i=k-1] = (-1)^{p-k+1} \\binom{p}{k-1} F(p+1)=i=0∑p​(−1)p−i(ip​)[i=k−1]=(−1)p−k+1(k−1p​) 因此 F(∣T∣)=(−1)∣T∣−k(∣T∣−1k−1)F(|T|) = (-1)^{|T|-k}\\binom{|T|-1}{k-1}F(∣T∣)=(−1)∣T∣−k(k−1∣T∣−1​) 子集反演 莫比乌斯反演相当于在因子多重集上的子集反演，所以本质也是子集反演。 现有一个满足某些条件的元素集合 AAA。 设 f(S)f(S)f(S) 表示 A=SA=SA=S 时的答案，g(S)g(S)g(S) 表示 S⊆AS \\subseteq AS⊆A 时的答案，则有如下结论： g(S)=∑T⊆Sf(T) ⟺ f(S)=∑T⊆S(−1)∣S∣−∣T∣g(T)g(S) = \\sum_{T \\subseteq S} f(T) \\iff f(S) = \\sum_{T \\subseteq S} (-1)^{|S|-|T|}g(T) g(S)=T⊆S∑​f(T)⟺f(S)=T⊆S∑​(−1)∣S∣−∣T∣g(T) 设 f(s)f(s)f(s) 表示满足 A=SA=SA=S 时的答案，g(S)g(S)g(S) 表示 A⊆SA \\subseteq SA⊆S 时的答案，则有如下结论： g(S)=∑S⊆Tf(T) ⟺ f(S)=∑S⊆T(−1)∣T∣−∣S∣g(T)g(S) = \\sum_{S \\subseteq T} f(T) \\iff f(S) = \\sum_{S \\subseteq T} (-1)^{|T|-|S|}g(T) g(S)=S⊆T∑​f(T)⟺f(S)=S⊆T∑​(−1)∣T∣−∣S∣g(T) 斯特林反演 定义第一类斯特林数 [nm]\\begin{bmatrix}n \\\\ m\\end{bmatrix}[nm​] 表示 nnn 个不同元素形成 mmm 个圆排列的方案数。 注意 (1,2,3,4)(1,2,3,4)(1,2,3,4) 与 (2,3,4,1)(2,3,4,1)(2,3,4,1) 为同一个圆排列，但 (1,2,3,4)(1,2,3,4)(1,2,3,4) 与 (4,3,2,1)(4,3,2,1)(4,3,2,1) 不是同一个圆排列。 其满足如下递推式： [nm]=[n−1m−1]+(n−1)[n−1m]\\begin{bmatrix}n\\\\m\\end{bmatrix} = \\begin{bmatrix} n-1 \\\\ m-1 \\end{bmatrix} + (n-1) \\begin{bmatrix} n-1 \\\\ m \\end{bmatrix} [nm​]=[n−1m−1​]+(n−1)[n−1m​] 这个递推式就是考虑元素 nnn 是自己单独变成一个圆排列还是放到前 n−1n-1n−1 个数的前面。 对于任意一个排列我们如果将其变成置换的形式，就相当于划分成了若干圆排列，也就是说： ∑i=0n[ni]=n!\\sum_{i=0}^n \\begin{bmatrix} n \\\\ i \\end{bmatrix} = n! i=0∑n​[ni​]=n! 定义第二类斯特林数 {nm}\\begin{Bmatrix} n \\\\ m\\end{Bmatrix}{nm​} 表示将 nnn 个不同的元素划分到 mmm 个相同的集合中，要求集合非空的方案数。 则有如下的递推式： {nm}={n−1m−1}+m{n−1m}\\begin{Bmatrix} n \\\\ m \\end{Bmatrix} = \\begin{Bmatrix} n-1 \\\\ m-1 \\end{Bmatrix} + m\\begin{Bmatrix} n-1 \\\\ m \\end{Bmatrix} {nm​}={n−1m−1​}+m{n−1m​} 就是考虑元素 nnn 是自己新建一个集合，还是放在前面已有的集合中。 可以显然发现这个结论： [nm]≥{nm}\\begin{bmatrix} n \\\\ m\\end{bmatrix} \\ge \\begin{Bmatrix} n \\\\ m \\end{Bmatrix} [nm​]≥{nm​} 因为一个圆排列只对应一个集合，而一个集合可以对应多个圆排列。 斯特林数最关键的应用就是：普通幂、上升幂、下降幂之间的转换。 定义下降幂：xn‾=x×(x−1)×(x−2)×⋯×(x−n+1)x^{\\underline{n}} = x\\times (x-1) \\times (x-2) \\times \\cdots \\times (x-n+1)xn​=x×(x−1)×(x−2)×⋯×(x−n+1)。 定义上升幂：xn‾=x×(x+1)×(x+2)×⋯×(x+n−1)x^{\\overline{n}} = x \\times (x+1) \\times (x+2) \\times \\cdots \\times (x+n-1)xn=x×(x+1)×(x+2)×⋯×(x+n−1)。 显然若 x&lt;nx &lt; nx&lt;n，则 xn‾=0x^{\\underline{n}} = 0xn​=0。 普通幂转下降幂： xn=∑i=0n{ni}xi‾x^n = \\sum_{i=0}^n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x^{\\underline{i}} xn=i=0∑n​{ni​}xi​ 证明： 考虑使用数学归纳法，显然 n=0n=0n=0 时成立，考虑假设 [0,n−1][0,n-1][0,n−1] 成立，证明 nnn 时成立。 ∑i=0n{ni}xi‾=∑i=0n{n−1i−1}xi‾+∑i=0ni×{n−1i}xi‾=∑i=0n−1{n−1i}xi+1‾+∑i=0n−1i×{n−1i}xi‾=∑i=0n−1(x−i)×{n−1i}xi‾+∑i=0n−1i×{n−1i}xi‾=x×∑i=0n{ni}xi‾=x×xn−1=xn\\begin{aligned} &amp;\\sum_{i=0}^{n} \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= \\sum_{i=0}^{n} \\begin{Bmatrix} n-1 \\\\ i-1 \\end{Bmatrix}x^{\\underline{i}} + \\sum_{i=0}^n i \\times \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= \\sum_{i=0}^{n-1} \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i+1}} + \\sum_{i=0}^{n-1} i \\times \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= \\sum_{i=0}^{n-1} (x-i) \\times \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i}} + \\sum_{i=0}^{n-1} i \\times \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= x \\times \\sum_{i=0}^n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= x \\times x^{n-1} \\\\ &amp;= x^n \\end{aligned} ​i=0∑n​{ni​}xi​=i=0∑n​{n−1i−1​}xi​+i=0∑n​i×{n−1i​}xi​=i=0∑n−1​{n−1i​}xi+1​+i=0∑n−1​i×{n−1i​}xi​=i=0∑n−1​(x−i)×{n−1i​}xi​+i=0∑n−1​i×{n−1i​}xi​=x×i=0∑n​{ni​}xi​=x×xn−1=xn​ 上升幂转通常幂： xn‾=∑i=0n[ni]xix^{\\overline{n}} = \\sum_{i=0}^n \\begin{bmatrix} n \\\\ i \\end{bmatrix} x^i xn=i=0∑n​[ni​]xi 证明同上。 下降幂转通常幂： xn‾=∑i=0n(−1)n−i{ni}xix^{\\underline{n}} = \\sum_{i=0}^n (-1)^{n-i} \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x^i xn​=i=0∑n​(−1)n−i{ni​}xi 通常幂转上升幂： xn=∑i=0n(−1)n−i[ni]xi‾x^{n} = \\sum_{i=0}^n (-1)^{n-i} \\begin{bmatrix} n \\\\ i \\end{bmatrix} x^{\\overline{i}} xn=i=0∑n​(−1)n−i[ni​]xi 上述两个式子的证明： 首先这个式子成立： xn‾=(−1)n×(−x)n‾x^{\\underline{n}} = (-1)^n \\times (-x)^{\\overline{n}} xn​=(−1)n×(−x)n 将这个式子分别带入第一、二个公式即可得到这两个式子。 反转公式： ∑i=mn{ni}[im](−1)n−i=[m=n]∑i=mn[ni]{im}(−1)n−i=[m=n]\\sum_{i=m}^n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} \\begin{bmatrix} i \\\\ m \\end{bmatrix} (-1)^{n-i} = [m = n] \\\\ \\sum_{i=m}^n \\begin{bmatrix} n \\\\ i \\end{bmatrix} \\begin{Bmatrix} i \\\\ m \\end{Bmatrix} (-1)^{n-i}= [m = n] \\\\ i=m∑n​{ni​}[im​](−1)n−i=[m=n]i=m∑n​[ni​]{im​}(−1)n−i=[m=n] 证明： 将第三、四个公式，分别带入第一、二个公式就可以得到这个公式。 斯特林反演： f(n)=∑i=0n[ni]g(i) ⟺ g(n)=∑i=0n(−1)n−i{ni}f(i)f(n)=∑i=0n{ni}g(i) ⟺ g(n)=∑i=0n(−1)n−i[ni]f(i)f(n)=∑i=n[in]g(i) ⟺ g(n)=∑i=n(−1)i−n{in}f(i)f(n)=∑i=n{in}g(i) ⟺ g(n)=∑i=n(−1)i−n[in]f(i)f(n) = \\sum_{i=0}^n \\begin{bmatrix} n \\\\ i \\end{bmatrix} g(i) \\iff g(n) = \\sum_{i=0}^n (-1)^{n-i} \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} f(i) \\\\ f(n) = \\sum_{i=0}^n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} g(i) \\iff g(n) = \\sum_{i=0}^n (-1)^{n-i} \\begin{bmatrix} n \\\\ i \\end{bmatrix} f(i) \\\\ f(n) = \\sum_{i=n} \\begin{bmatrix} i \\\\ n \\end{bmatrix} g(i) \\iff g(n) = \\sum_{i=n} (-1)^{i-n} \\begin{Bmatrix} i \\\\ n \\end{Bmatrix} f(i) \\\\ f(n) = \\sum_{i=n} \\begin{Bmatrix} i \\\\ n \\end{Bmatrix} g(i) \\iff g(n) = \\sum_{i=n} (-1)^{i-n} \\begin{bmatrix} i \\\\ n \\end{bmatrix} f(i) \\\\ f(n)=i=0∑n​[ni​]g(i)⟺g(n)=i=0∑n​(−1)n−i{ni​}f(i)f(n)=i=0∑n​{ni​}g(i)⟺g(n)=i=0∑n​(−1)n−i[ni​]f(i)f(n)=i=n∑​[in​]g(i)⟺g(n)=i=n∑​(−1)i−n{in​}f(i)f(n)=i=n∑​{in​}g(i)⟺g(n)=i=n∑​(−1)i−n[in​]f(i) 下面只证明一下第一个式子的充分性，其余的都可以类比地推出。 g(n)=∑i=0n[i=n]g(i)=∑i=0n(∑j=in{nj}[ji](−1)n−jg(i))=∑j=0n(−1)n−j{nj}(∑i=0j[ji]g(i))=∑j=0n(−1)n−j{nj}f(j)\\begin{aligned} g(n) &amp;= \\sum_{i=0}^n [i=n] g(i) \\\\ &amp;= \\sum_{i=0}^n \\left(\\sum_{j=i}^n \\begin{Bmatrix} n \\\\ j \\end{Bmatrix} \\begin{bmatrix} j \\\\ i \\end{bmatrix} (-1)^{n-j} g(i)\\right) \\\\ &amp;= \\sum_{j=0}^n (-1)^{n-j} \\begin{Bmatrix} n \\\\ j \\end{Bmatrix} \\left(\\sum_{i=0}^j \\begin{bmatrix} j \\\\ i \\end{bmatrix} g(i)\\right) \\\\ &amp;= \\sum_{j=0}^n (-1)^{n-j} \\begin{Bmatrix} n \\\\ j \\end{Bmatrix}f(j) \\end{aligned} g(n)​=i=0∑n​[i=n]g(i)=i=0∑n​(j=i∑n​{nj​}[ji​](−1)n−jg(i))=j=0∑n​(−1)n−j{nj​}(i=0∑j​[ji​]g(i))=j=0∑n​(−1)n−j{nj​}f(j)​ 线性代数 矩阵乘法 若给定矩阵 A,BA,BA,B，使得 C=A×BC = A \\times BC=A×B，则满足：ci,j=∑k(Ai,k×Bk,j)c_{i,j} = \\sum_{k} (A_{i,k} \\times B_{k,j})ci,j​=∑k​(Ai,k​×Bk,j​) 也就是说若 A,BA,BA,B 可以进行矩阵乘法则必须要满足：AAA 的列数等于 BBB 的行数。 矩阵乘法之后的 CCC 矩阵 (i,j)(i,j)(i,j) 位置的元素，相当于 AAA 的第 iii 行与 BBB 的第 jjj 列对应相乘再相加后的结果。 矩阵乘法之后的 CCC 矩阵的行数等于 AAA 的行数，列数等于 BBB 的列数。 矩阵乘法满足结合律，但不满足交换律，即若我们要计算 AkA^kAk 也可以用类似快速幂的方法进行计算。 我们可以将矩阵乘法中的运算更换，比如换成：ci,j=max⁡k(Ai,k+Bk,j)c_{i,j} = \\max_{k} (A_{i,k} + B_{k,j})ci,j​=maxk​(Ai,k​+Bk,j​)，这个东西叫做 max⁡+\\max+max+矩乘，可以证明这种形式的矩阵乘法也满足结合律。 而我们的许多 dpdpdp 中的转移方程就可以用这种矩阵表示出来，所以就可以通过矩阵乘法在 O(log⁡n)O(\\log n)O(logn) 的时间内进行 dpdpdp 或者快速维护动态 dpdpdp。 高斯消元 请查看： 【学习笔记】高斯消元 本文只会扩展一下高斯消元的应用，主要是这种加减消元法的思想。 解异或方程组 记 ⊕\\oplus⊕ 为按位 xor 操作，解下列方程组： a1,1x1⊕a1,2x2⊕⋯a1,nxn=y1a2,1x1⊕a2,2x2⊕⋯a2,nxn=y2⋯am,1x1⊕am,2x2⊕⋯am,nxn=yma_{1,1} x_1 \\oplus a_{1,2} x_2 \\oplus \\cdots a_{1,n} x_n = y_1 \\\\ a_{2,1} x_1 \\oplus a_{2,2} x_2 \\oplus \\cdots a_{2,n} x_n = y_2 \\\\ \\cdots\\\\ a_{m,1} x_1 \\oplus a_{m,2} x_2 \\oplus \\cdots a_{m,n} x_n = y_m\\\\ a1,1​x1​⊕a1,2​x2​⊕⋯a1,n​xn​=y1​a2,1​x1​⊕a2,2​x2​⊕⋯a2,n​xn​=y2​⋯am,1​x1​⊕am,2​x2​⊕⋯am,n​xn​=ym​ 其中 ai,j∈{0,1}a_{i,j} \\in \\{0,1\\}ai,j​∈{0,1} 注意到一点 a⊕a=0a \\oplus a = 0a⊕a=0，也就是我们可以使用这点性质进行消元。 过程与高斯消元相同，因为我们每次只需要支持行的交换和行的对应异或所以可以使用 bitset 优化到 O(n3w)O(\\frac{n^3}{w})O(wn3​)。 矩阵求逆 对于方阵 AAA 若方阵 A−1A^{-1}A−1 满足 A×A−1=A−1×A=IA \\times A^{-1} = A^{-1} \\times A = IA×A−1=A−1×A=I，则称矩阵 AAA 可逆，其中 A−1A^{-1}A−1 就是它的逆矩阵。 记 InI_nIn​ 表示 n×nn\\times nn×n 的单位矩阵，则逆矩阵的求法如下： 构造一个 n×2nn \\times 2nn×2n 的矩阵 (A,In)(A,I_n)(A,In​)。 通过高斯消元将矩阵变成 (In,A−1)(I_n,A^{-1})(In​,A−1)，这样右半部分的矩阵就是 AAA 的逆矩阵 A−1A^{-1}A−1，若左边不可以化为 InI_nIn​ 则矩阵 AAA 不可逆。 行列式求值 对于一个 n×nn \\times nn×n 的行列式 AAA，其行列式的值定义为： det⁡(A)=∑σ∈Snsgn(σ)∏i=1nai,σi\\det(A) = \\sum_{\\sigma \\in S_n} \\text{sgn}(\\sigma)\\prod_{i=1}^n a_{i,\\sigma_i} det(A)=σ∈Sn​∑​sgn(σ)i=1∏n​ai,σi​​ 其中 SnS_nSn​ 定义为长度为 nnn 的全排列集合，sgn(σ)\\text{sgn}(\\sigma)sgn(σ) 定义为排列 σ\\sigmaσ 的奇偶性，若 σ\\sigmaσ 中逆序对数为偶数则 sgn(σ)=1\\text{sgn}(\\sigma) = 1sgn(σ)=1，否则 sgn(σ)=−1\\text{sgn}(\\sigma) = -1sgn(σ)=−1 行列式有如下性质： 交换两行（列）行列式的值取反 证明：若交换 x,yx,yx,y 两行，则考虑贡献是怎么变化的，如果要使得 ∏i=1nai,σi\\prod_{i=1}^n a_{i,\\sigma_i}∏i=1n​ai,σi​​ 依旧是之前的值，就相当于要交换 σx\\sigma_xσx​ 和 σy\\sigma_yσy​，此时 σx,σy\\sigma_x,\\sigma_yσx​,σy​ 是否构成逆序对的情况取反，而对于 p∈(x,y)p\\in(x,y)p∈(x,y)，σp\\sigma_pσp​ 是否与 σx,σy\\sigma_x,\\sigma_yσx​,σy​ 构成逆序对的情况要么同时改变，要么同时不变，所以不会有影响，对于 p∈[1,x)⋃(y,n]p\\in [1,x) \\bigcup (y,n]p∈[1,x)⋃(y,n]，σp\\sigma_pσp​ 是否与 σx,σy\\sigma_x,\\sigma_yσx​,σy​ 构成逆序对显然不会有任何影响。 综上逆序对恰好变化 111，也就是奇偶性会改变，会乘以 −1-1−1。 将一行（列）加到另一行（列）上行列式的值不变 证明：若将 xxx 列加入到 yyy 列上，那么对于一个排列 σ\\sigmaσ 交换 σx\\sigma_xσx​ 与 σy\\sigma_yσy​ 后可以得到一个新的排列 σ′\\sigma'σ′，显然 sgn(σ)=−sgn(σ′)\\text{sgn}(\\sigma) = -\\text{sgn}(\\sigma')sgn(σ)=−sgn(σ′)，而对于多加的贡献在两者中正好形成相反数所以相互抵消了。 若行列式只有 ai,j(i≤j)a_{i,j}(i \\le j)ai,j​(i≤j) 处有值，即一个上三角处有值，则该行列式的值为 ∏i=1nai,i\\prod_{i=1}^n a_{i,i}∏i=1n​ai,i​ 证明：此时对于一个排列 σ\\sigmaσ 要使得 ∏i=1nai,σi\\prod_{i=1}^n a_{i,\\sigma_i}∏i=1n​ai,σi​​ 不为 000，只有 σ={1,2,3,4,⋯ ,n}\\sigma = \\{1,2,3,4,\\cdots,n\\}σ={1,2,3,4,⋯,n}，而此时 sgn(σ)=1\\text{sgn}(\\sigma) = 1sgn(σ)=1，所以行列式的值就是 ∏i=1nai,i\\prod_{i=1}^n a_{i,i}∏i=1n​ai,i​ 将行列式某行（列）同时乘 kkk，则行列式的值乘 kkk 证明：相当于对于每个 σ\\sigmaσ 都将某个 ai,σia_{i,\\sigma_i}ai,σi​​ 乘以 kkk，所以最后的值就会乘以 kkk。 通过上述性质我们就可以直接通过高斯消元将行列式消成上三角，然后对角线元素的乘积就是行列式的值。 需要注意如果消的过程中交换了一次行，要将最后的答案乘以 −1-1−1。 LGV 引理 LGV 引理常用于解决 DAG 上不相交路径（权值）计数问题 记 w(P)w(P)w(P) 表示 PPP 这条路径的权值和，若为路径计数则可将权值记为 111。 记 e(u,v)e(u,v)e(u,v) 表示 uuu 到 vvv 所有路径 PPP 的 w(P)w(P)w(P) 之和。 记起点集合为 AAA，终点集合大小为 BBB，其大小均为 nnn。 则我们的答案为下列行列式的值： M=[e(A1,B1)e(A1,B2)⋯e(A1,Bn)e(A2,B1)e(A2,B2)⋯e(A2,Bn)⋯⋯⋯⋯e(An,B1)e(An,B2)⋯e(An,Bn)]M = \\begin{bmatrix} e(A_1,B_1) &amp;e(A_1,B_2) &amp;\\cdots &amp;e(A_1,B_n) \\\\ e(A_2,B_1) &amp;e(A_2,B_2) &amp;\\cdots &amp;e(A_2,B_n) \\\\ \\cdots &amp;\\cdots &amp;\\cdots &amp;\\cdots \\\\ e(A_n,B_1) &amp;e(A_n,B_2) &amp;\\cdots &amp;e(A_n,B_n) \\\\ \\end{bmatrix} M=⎣⎢⎢⎢⎡​e(A1​,B1​)e(A2​,B1​)⋯e(An​,B1​)​e(A1​,B2​)e(A2​,B2​)⋯e(An​,B2​)​⋯⋯⋯⋯​e(A1​,Bn​)e(A2​,Bn​)⋯e(An​,Bn​)​⎦⎥⎥⎥⎤​ 感觉这个如果不给例题就实在是太抽象了。 例题 CF348D Turtles： 一张 nnn 行 mmm 列的网格图，图中的有些格子上面有障碍物，但保证 (1,1)(1,1)(1,1) 和 (n,m)(n,m)(n,m) 上面都没有障碍物。在 (1,1)(1,1)(1,1) 处有两只乌龟，都想要去 (n,m)(n,m)(n,m)。乌龟每次都可以向下或者向右走一格，前提是格子上没有任何障碍物。要求两只乌龟在前往 (n,m)(n,m)(n,m) 的路途中不可以相遇，即除了起点和终点，他们的路径没有其他公共点。求出从起点到终点的不同路径对数。答案对 109+710^9+7109+7 取模。 考虑我们从 (1,1)(1,1)(1,1) 出发必然经过 (1,2)(1,2)(1,2) 和 (2,1)(2,1)(2,1) 到达 (n,m)(n,m)(n,m) 必然经过 (n−1,m)(n-1,m)(n−1,m) 和 (n,m−1)(n,m-1)(n,m−1)，所以我们的起点集合就是 A={(1,2),(2,1)}A = \\{(1,2),(2,1)\\}A={(1,2),(2,1)} 终点集合就是 B={(n−1,m),(n,m−1)}B = \\{(n-1,m),(n,m-1)\\}B={(n−1,m),(n,m−1)}。 根据 LGV 引理，我们要算四次 e(i,j)e(i,j)e(i,j) 表示从 iii 到 jjj 的路径条数，而这个东西 O(nm)O(nm)O(nm) 的 dpdpdp 做法显然，就很好做了。 矩阵树定理 矩阵树定理可以解决给定一张图，求其生成树个数，这里要求给定的图没有自环。 下面考虑无向图的情况。 给定一张图 G=(V,E)G = (V,E)G=(V,E)，mi,jm_{i,j}mi,j​ 表示直接连接 (i,j)(i,j)(i,j) 的边数，degideg_idegi​ 表示点 iii 的度数，定义它的拉普拉斯矩阵 LLL 为： Li,j={−mi,ji≠jdegii=jL_{i,j} = \\begin{cases} -m_{i,j} &amp; i\\not= j \\\\ deg_i &amp; i = j \\end{cases} Li,j​={−mi,j​degi​​i=ji=j​ 则生成树个数为 LLL 中任意删去一行一列后其行列式的值。 下面考虑有向图的情况。 记 mi,jm_{i,j}mi,j​ 表示从 iii 指向 jjj 的边数，定义出度拉普拉斯矩阵为： Li,jout={−mi,ji≠jdegiouti=jL_{i,j}^{out} = \\begin{cases} -m_{i,j} &amp; i\\not= j\\\\ deg_i^{out} &amp; i = j \\end{cases} Li,jout​={−mi,j​degiout​​i=ji=j​ 定义入度拉普拉斯矩阵为： Li,jin={−mi,ji≠jdegiini=jL_{i,j}^{in} = \\begin{cases} -m_{i,j} &amp; i\\not= j \\\\ deg_i^{in} &amp; i = j \\end{cases} Li,jin​={−mi,j​degiin​​i=ji=j​ 记图 GGG 的以 rrr 为根的根向生成树的方案数为 troot(G,r)t^{root}(G,r)troot(G,r)，记图 GGG 的以 rrr 为根的叶向生成树的方案数为 tleaf(G,r)t^{leaf}(G,r)tleaf(G,r)，则根据矩阵树定理有： troot(G,k)=det⁡Lout(1,2,3,⋯ ,k−1,k+1,⋯ ,n1,2,3,⋯ ,k−1,k+1,⋯ ,n)tleaf(G,k)=det⁡Lin(1,2,3,⋯ ,k−1,k+1,⋯ ,n1,2,3,⋯ ,k−1,k+1,⋯ ,n)t^{root}(G,k) = \\det L^{out}\\binom{1,2,3,\\cdots,k-1,k+1,\\cdots,n}{1,2,3,\\cdots,k-1,k+1,\\cdots,n} \\\\ t^{leaf}(G,k) = \\det L^{in} \\binom{1,2,3,\\cdots,k-1,k+1,\\cdots,n}{1,2,3,\\cdots,k-1,k+1,\\cdots,n} troot(G,k)=detLout(1,2,3,⋯,k−1,k+1,⋯,n1,2,3,⋯,k−1,k+1,⋯,n​)tleaf(G,k)=detLin(1,2,3,⋯,k−1,k+1,⋯,n1,2,3,⋯,k−1,k+1,⋯,n​) 其中定义 L(1,2,3,⋯ ,k−1,k+1,⋯ ,n1,2,3,⋯ ,k−1,k+1,⋯n)L\\binom{1,2,3,\\cdots,k-1,k+1,\\cdots,n}{1,2,3,\\cdots,k-1,k+1,\\cdots n}L(1,2,3,⋯,k−1,k+1,⋯n1,2,3,⋯,k−1,k+1,⋯,n​) 表示 LLL 矩阵除去第 kkk 行第 kkk 列后的矩阵。 BEST 定理 定义 troot(G,k)t^{root}(G,k)troot(G,k) 表示图 GGG 的以 kkk 为根的根向生成树个数。 在有向欧拉图 GGG 中，GGG 中不同欧拉回路的数量为： troot(G,k)∏v∈V(degv−1)!t^{root}(G,k)\\prod_{v \\in V} (deg_v - 1)! troot(G,k)v∈V∏​(degv​−1)! degvdeg_vdegv​ 既可以指出度也可以指入度，因为欧拉图中每个点的入度和出度相等。 kkk 可以为任意点，因为此时对于任意两个点 u,vu,vu,v 都有 troot(G,x)=troot(G,y)t^{root}(G,x) = t^{root}(G,y)troot(G,x)=troot(G,y)。 一种感性理解这个定理的方法： 对于一条欧拉路径，我们保留每一个点的最后一条出边，出边一定构成一棵根向树，因为如果不是就无法构成欧拉路径。 而对于其它的边发现任意排列都可以构成欧拉路径，所以就是∏v∈V(degv−1)!\\prod_{v \\in V} (deg_v-1)!∏v∈V​(degv​−1)!。 乘起来就是 BEST 定理。 多项式与生成函数 请查看： 【学习笔记】数论之生成函数基础 【学习笔记】拉格朗日插值 群论入门 请查看： 【学习笔记】Burnside 定理和 Polya 定理 计算几何 请查看： 【学习笔记】计算几何 博弈论 请查看： 【学习笔记】博弈论 ---- 非偏博弈","link":"/2023/09/14/math/"},{"title":"基(奇)本(技)套(淫)路(巧)","text":"本篇是关于我做题时遇到的很神奇的技巧和思路的总结，会不定时更新。 以后就记录一些小 trick 以及一些知识点的小套路 Tricks 对于乘除法我们可以直接取对数转化为加减法 对于 ⌈ab⌉\\lceil \\dfrac{a}{b} \\rceil⌈ba​⌉ 可以转化为 ⌊a+(b−1)b⌋\\lfloor \\dfrac{a + (b-1)}{b} \\rfloor⌊ba+(b−1)​⌋ 来快速求解 对于两个点 x,yx,yx,y，若 lca(x,y)lca(x,y)lca(x,y) 为 xxx，则意味着 xxx 在 yyy 到根的路径上。 区间内有无重复元素：记录上一次出现的位置，然后转化为区间取 min⁡\\minmin 将 DP 的转移分为几块，每一块分开处理分开考虑 区间问题转化为差分或前缀和后考虑 对于存在查询很优以及修改很优的做法，就可以考虑使用分块平衡复杂度 边权转点权：每条边额外建一个点，连接这条边的两个端点 枚举每一个数的约数可以逆向转化为枚举每一个数的倍数，就可以让复杂度 O(nn)→O(nlog⁡n)O(n\\sqrt{n}) \\to O(n \\log n)O(nn​)→O(nlogn) 预处理前后缀信息，通过前后缀信息合并得到答案 与子树相对深度相关的有关的题，将贡献改为与子树绝对深度相关的信息 与某个极大数的组合数相关的题，考虑卢卡斯定理 SAM 中两个前缀的 LCS 是它们在 parent 树上的 lca 的最长串 后缀的 LCP 可以建反串转化为前缀的 LCS 广义 SAM 中一般可以考虑使用线段树合并维护当前点属于的模板串的集合，也可以用来维护 endpos 集合 ⌊j−ik⌋=⌊jk⌋−⌊ik⌋−[(j%k)&lt;(i%k)]\\lfloor \\frac{j-i}{k} \\rfloor = \\lfloor \\frac{j}{k} \\rfloor - \\lfloor \\frac{i}{k} \\rfloor - [(j \\% k) &lt; (i \\% k)]⌊kj−i​⌋=⌊kj​⌋−⌊ki​⌋−[(j%k)&lt;(i%k)] 树形背包的优化做法的复杂度是 O(nm)O(nm)O(nm)，其中 nnn 是节点数，mmm 是背包大小 自动机要考虑对模式串建或者询问串建，都考虑一下 链加+单点查询 -&gt; 单点加+子树查询：好写而且复杂度低 对于某些操作或者什么的，可以考虑想想终止状态是什么 期望次数可以理解为 1概率\\frac{1}{\\text{概率}}概率1​ 路径最大值/最小值：Kruskal 重构树；路径最大值最小/最小值最大：最小生成树、二分答案 字符串匹配使用 bitset 维护文本串每一个字符出现的位置，然后模式串求一个并集就好了 计数问题想不出来就考虑容斥一下，容斥原理或者统计不合法的方案数 没啥想法就随便枚举几个值试试 带环 DP：高斯消元、二分一个值 对于两个不同的数，二进制分组之后一定至少有一次它们在不同组中 设 p[i]p[i]p[i] 表示为 iii 的概率，P[i]P[i]P[i] 表示大于等于 iii 的概率，那么期望可以理解为：∑i=1ni×p[i]=∑i=1nP[i]\\sum_{i=1}^n i \\times p[i] = \\sum_{i=1}^n P[i]∑i=1n​i×p[i]=∑i=1n​P[i] ∑j=0i(ij)=2i\\sum_{j=0}^i \\binom{i}{j} = 2^i∑j=0i​(ji​)=2i 平衡树的翻转标记：只要下面有用到他的儿子就下传 树上两条路径如果有公共点，则交集必然满足点数等于边数加一 非必要情况，否则使用树剖求 lcalcalca 根据条件去求满足条件的点，或者枚举点判断是否符合条件 Kruskal 重构树的节点个数为 2×n−12\\times n - 12×n−1，千万别直接把 nnn 拿上去了。 在图论中看到只经过小于等于或者大于等于某个值的条件时，想到 Kruskal 重构树，转化为子树询问 期望 dpdpdp 一般可以考虑设到最终状态的期望，也可以是走一步的期望 对于选 kkk 个元素最优的题，那么对于任意一种最优方案，对于任意一个区间 [l,r][l,r][l,r] 若区间内选了 ppp 个，那么这 ppp 个一定是区间 [l,r][l,r][l,r] 选择 ppp 个的最优方案之一。 set 里 count 的复杂度是假的，不如直接用 map 1 int = 4b 调题的时候不要着急，要分析问题性质而不是对着错误的数据在那里打补丁。 某类数数题考虑最终的状态满足什么条件时合法，然后统计这些条件就变简单了。 树上 mmm 个点的 LCALCALCA 等于 dfsdfsdfs 最小的点和最大的点的 LCALCALCA。 考试犯的傻逼错误： xxxx;xxxx; 却没打大括号 交错源代码 平衡树新建节点一定要把所有的信息都赋初值，不能感觉可以不赋就不赋 注意题目中是说：经过边的数量还是经过点的数量 字符串题注意串的字符串的首地址需要不需要加一 不要轻易否定自己的解法，如果感觉不对就构造一组，跑一遍 hack 掉就好了 网络流里不能随便建双向边，很多题在实际的建模里需要从 S -&gt; T （大致方向）建边。 建文件夹一定只包含数字和字母 可以手模的样例一定要手模 多测一定要清空，是将本次更改的全部改回去，而不是将下次可能用到的改回去，非必要情况，请使用 memsetmemsetmemset 清空 一定不要读形式化题面，只给了一坨抽象的式子完全不如慢慢读文字题面 数组中长度小的维度放在前面，可能可以让速度快很多倍 一定要认真读数据范围，特别关注看上去就很不正常的地方 预处理阶乘的逆元一定要记得处理 000 的啊。 平衡树不要和线段树混了，记得 nownownow 也是一个独立的点啊 无法调试或者灵异事件不要着急：观察一下基本的配置、观察一下文件（夹）名 传参数不要直接传一个 vectorvectorvector multiset 删除一定要反复检查是不是直接 erase(x) 状压或枚举状态的时候一定要注意从 000 开始还是从 111 开始，就是需不需要减一 写复杂的数据结构一定要从内层到外层慢慢来，千万不要从外层到内层去写 一些主函数比较难写的数据结构，就先把数据结构用暴力实现，直到主函数改对再去写数据结构 多测清空的时候注意：是不是之前的一些特判直接跳过了清空环节","link":"/2022/06/24/tricks/"}],"tags":[{"name":"1","slug":"1","link":"/tags/1/"},{"name":"2","slug":"2","link":"/tags/2/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"pages":[]}