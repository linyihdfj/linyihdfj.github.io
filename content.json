{"posts":[{"title":"Manacher","text":"对于 Manacher 部分的理解，推荐阅读前有一定了解 ##对算法本身的部分理解： 1234if(2 * maxn - i &gt;= 1) f[i] = min(f[2 * maxn - i],maxr - i);else f[i] = maxr - i; 关于这个算法，最难以理解的部分也就这里，也就是判断 iii 的最长回文长度的下界。 首先定义 jjj 为 iii 关于 maxnmaxnmaxn 的对称点，mxrmxrmxr 为已有回文半径覆盖到的最右点，maxnmaxnmaxn 为其的中心点 首先关于 jjj 的寻找，因为 maxn=i−j2maxn = \\frac{i-j}{2}maxn=2i−j​，所以可以化简得：2×maxn=i−j2\\times maxn = i - j2×maxn=i−j，所以 j=2×maxn−ij = 2\\times maxn - ij=2×maxn−i 关于第一行的判断条件，也就是在判断 jjj 的存在，然后看后面的两种情况。 1：若 f[j]&lt;maxr−if[j] &lt; maxr - if[j]&lt;maxr−i，我们选择的下界会是 f[j]f[j]f[j]，则有下图 ​ 其中用红线代表 i,ji,ji,j 的回文范围，maxr−imaxr- imaxr−i 也就是 iii 到 maxrmaxrmaxr 的距离。首先因为这一长段都是以 maxnmaxnmaxn 为中心的回文子串，所以其实以 jjj 为中心的回文子串也在以 iii 为中心的回文子串那里（不一定完整），因为 jjj 的回文半径小于 iii 到 maxrmaxrmaxr 的距离，所以以 jjj 为中心的整个回文串都完整地到了 iii 的地方，所以对于 iii 来说它的回文半径的下界也就是 jjj 的回文半径。之所以说是下界，因为超过这个下界的 iii 的右边可能有一些值仍然可以和 iii 的左边匹配，因为超过部分不一定和 jjj 那里一样，所以是下界。 2：若 f[j]&gt;maxr−if[j] &gt; maxr - if[j]&gt;maxr−i，我们选择的下界会是 maxr−imaxr - imaxr−i，则有下图： 此时也就相当于 jjj 的回文半径的长度超过了 maxnmaxnmaxn 的限制，也就是以 jjj 为中心的回文串只有一部分因为 maxnmaxnmaxn 的限制而来到了 iii 的位置，而这一部分的长度也就是 jjj 到 maxnmaxnmaxn 限制的左端点的距离，也就是 maxr−imaxr - imaxr−i 那么因为这一段有 maxnmaxnmaxn 的限制再加上在 jjj 是回文的，所以也一定是回文的","link":"/2022/03/29/Manacher/"},{"title":"Educational Codeforces Round 141（CF1783）","text":"【题解】Educational Codeforces Round 141（CF1783） 评价：educational A.Make it Beautiful 题目描述： 如果一个数组中存在一个数恰好等于该数前面所有数之和，那么这个数组就是丑的。如果一个数组不是丑的，就是美的。 比如说： 数组 $ [6, 3, 9, 6] $ 是丑的，因为 9=6+39 = 6 + 39=6+3 ； 数组 $ [5, 5, 7] $ 是丑的，因为第二个 5=55 = 55=5 。 数组 $ [8, 4, 10, 14] $ 是美的，因为 $ 8 \\ne 0 $ , $ 4 \\ne 8 $ , $ 10 \\ne 8 + 4 $ , $ 14 \\ne 8 + 4 + 10 $ ，没有任何一个数等于它前面的数之和。 给定数组 aaa 满足 $ 1 \\le a_1 \\le a_2 \\le \\dots \\le a_n \\le 100 $ 。 你可以任意调整元素的顺序，也可以不调整，使它变成一个美的数组。 题目分析： 我们可以考虑从大到小排序，这样除了最大值可能出问题，其它的都没问题。 而最大值就可以只保留一个在序列开头，其余的放到结尾即可。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100;int a[N];int main(){ int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); vector&lt;int&gt; v; for(int i=n; i&gt;=1; i--){ if(a[i] == a[n] &amp;&amp; i != n) continue; v.push_back(a[i]); } for(int i=n; i&gt;=1; i--){ if(a[i] == a[n] &amp;&amp; i != n) v.push_back(a[i]); } bool flag = true; int sum = 0; for(int i=0; i&lt;(int)v.size(); i++){ if(v[i] == sum) flag = false; sum += v[i]; } if(flag){ printf(&quot;YES\\n&quot;); for(int i=0; i&lt;(int)v.size(); i++) printf(&quot;%d &quot;,v[i]); printf(&quot;\\n&quot;); } else printf(&quot;NO\\n&quot;); } return 0;} B.Matrix of Differences 题目描述： 对于一个 n×nn\\times nn×n 的矩阵，对于每一对相邻（有公共边）的值 a,ba,ba,b，写下 ∣a−b∣|a-b|∣a−b∣（即 aaa 与 bbb 差的绝对值）。定义这个矩阵的美丽度为写下的不同的值的个数。以如下的矩阵为例： (1342)\\left(\\begin{matrix}1&amp;3\\\\4&amp;2\\end{matrix}\\right) (14​32​) 则所有相邻值的绝对值分别是 ∣1−3∣=2,∣1−4∣=3,∣3−2∣=1,∣4−2∣=2|1-3|=2,|1-4|=3,|3-2|=1,|4-2|=2∣1−3∣=2,∣1−4∣=3,∣3−2∣=1,∣4−2∣=2。共有 1,2,31,2,31,2,3 三种不同的值，则这个矩阵的美丽度为 333。 给你 ttt 次询问，每次询问给定一个正整数 nnn。输出任意一个 n×nn\\times nn×n 的矩阵，满足 1∼n21\\sim n^21∼n2 在矩阵中各出现一遍，并且该矩阵的美丽度最大。 1≤t≤49,2≤n≤501\\le t\\le49,2\\le n\\le501≤t≤49,2≤n≤50。 题目分析： 手摸了半天才搞出来的做法。 考虑 n−1n-1n−1 会怎么得到，只有可能是 1,n1,n1,n，那 n−2n-2n−2 呢？ 可以是 1,n−11,n-11,n−1 或者 2,n2,n2,n，为了构造的漂亮程度我们就不妨将 n,n−1n,n-1n,n−1 放到 111 的旁边，然后 222 继续放到下面，也就是下面这种方式： 1n−14n−5⋯n3n−4⋯2n−3⋯n−2⋯⋯\\begin{matrix} 1 &amp;n-1 &amp;4 &amp;n-5 &amp;\\cdots\\\\ n &amp;3 &amp;n-4 &amp;\\cdots\\\\ 2 &amp;n-3 &amp;\\cdots\\\\ n-2 &amp;\\cdots\\\\ \\cdots \\end{matrix} 1n2n−2⋯​n−13n−3⋯​4n−4⋯​n−5⋯⋯ 然后就可以过了。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100;int a[N][N];int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n;scanf(&quot;%d&quot;,&amp;n); int l = 1,r = n*n,tot = 0; for(int i=1; i&lt;=n; i++){ ++tot; int nx = i,ny = 1; while(nx &gt;= 1 &amp;&amp; ny &lt;= n){ if(tot &amp; 1) a[nx][ny] = l,l++; else a[nx][ny] = r,--r; nx --,ny ++; } } for(int i=2; i&lt;=n; i++){ ++tot; int nx = n,ny = i; while(nx &gt;= 1 &amp;&amp; ny &lt;= n){ if(tot &amp; 1) a[nx][ny] = l,l++; else a[nx][ny] = r,--r; nx --,ny ++; } } for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=n; j++){ printf(&quot;%d &quot;,a[i][j]); } printf(&quot;\\n&quot;); } } return 0;} C.Yet Another Tournament 题目描述： 有 nnn 个选手，编号为 111 至 nnn ，每两个选手对战时，编号大的将会胜利。 你可以准备 mmm 单位时间，每准备 aia_iai​ 时间就可以赢 iii 号选手。 按胜利的总次数排名，求你最高多少名。 题目分析： 一个想法就是我们直接将 aaa 最小到大排序，这样就可以赢尽可能多的场，看上去就是很好的排名。 但是我们的排名还与我们赢了哪些人有关，所以就有点不可做的样子。 注意到，当我们赢了 xxx 场就相当于要选择 n−xn-xn−x 个人多赢一场，然后寻找赢场数大于 xxx 的人的个数，而只有赢场数等于 xxx 的人会受到我们选择加一的影响，所以其实此时只需要判断能不能通过调整使得我们可以赢过胜场为 xxx 的人即可。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 5e5+5;int a[N],b[N];signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%lld&quot;,&amp;T); while(T--){ int n,m;scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]),b[i] = a[i]; sort(b+1,b+n+1); int pos = 0; for(int i=1; i&lt;=n; i++){ if(m - b[i] &gt;= 0){ pos = i; m -= b[i]; } } if(!pos){ printf(&quot;%lld\\n&quot;,n+1); continue; } if(pos != n &amp;&amp; a[pos+1] &lt;= m + b[pos]) ++pos; printf(&quot;%lld\\n&quot;,n-pos + 1); } return 0;} D.Different Arrays 题目描述： 给你一个有 nnn 个元素的序列，你需要进行 n−2n-2n−2 次操作。 对于第 iii 次操作，你可以选择让 ai−ai+1a_i-a_{i+1}ai​−ai+1​ 且 ai+2+ai+1a_{i+2}+a_{i+1}ai+2​+ai+1​ 或者可以选择让 ai+ai+1a_i+a_{i+1}ai​+ai+1​ 且 ai+2−ai+1a_{i+2}-a_{i+1}ai+2​−ai+1​ 问最后能产生多少个不同的序列。 题目分析： 一个想法就是判断什么样的序列是能被表示的，但是想了一会发现根本没有任何头绪，所以考虑换个想法，也就是直接使用 dpdpdp 去决策每一次的操作。 为了方便理解，我们将第 iii 次操作，成为操作第 i+1i+1i+1 个数。 但是这样看上去有很多重复的情况就很难办，注意一点就是要使得产生相同的序列则必然满足存在 ai=0a_i = 0ai​=0 的情况，然后操作 aia_iai​，否则一定不会产生相同的情况，所以我们完全不用考虑什么去重之类的问题，只需要判断 ai=0a_i = 0ai​=0 即可。 所以可以考虑设 dpi,jdp_{i,j}dpi,j​ 表示操作完了前 iii 个数，ai+1=ja_{i+1} = jai+1​=j 的方案数，记第二维的原因是我们此时需要决策第 i+1i+1i+1 次操作就必须知道对应的 aaa 是什么。 转移就是显然的，也就是直接枚举 ai+1a_{i+1}ai+1​ 是怎么操作的，以及特判 ai+1=0a_{i+1} = 0ai+1​=0。 注意到第二维可以为负，所以加一个偏移量。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int MOD = 998244353;const int MAX = 90000;int dp[305][90005 * 2];int a[305];void add(int &amp;a,int b){ a = (a + b)%MOD;}int main(){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); dp[1][MAX+a[2]] = 1; for(int i=1; i&lt;n; i++){ for(int k=-MAX; k&lt;=MAX; k++){ if(!dp[i][k+MAX]) continue; if(k == 0){ dp[i+1][a[i+2]+MAX] = (dp[i+1][a[i+2]+MAX] + dp[i][k+MAX])%MOD; } else{ dp[i+1][a[i+2]+k+MAX] = (dp[i+1][a[i+2]+k+MAX] + dp[i][k+MAX])%MOD; dp[i+1][a[i+2]-k+MAX] = (dp[i+1][a[i+2]-k+MAX] + dp[i][k+MAX])%MOD; } } } int ans = 0; for(int j=-MAX; j&lt;=MAX; j++) add(ans,dp[n-1][j+MAX]); printf(&quot;%d\\n&quot;,ans); return 0;} E.Game of the Year 题目描述： Monocarp 和 Polycarp 正在玩电脑游戏。游戏特点：$ n $ 个编号从 $ 1 $ 到 $ n $ 的BOSS。 他俩将用以下方式与BOSS战斗 Monocarp 进行 $ k $ 次尝试撒掉boss; Polycarp 进行 $ k $ 次尝试撒掉boss; Monocarp 进行 $ k $ 次尝试撒掉boss; Polycarp 进行 $ k $ 次尝试撒掉boss; … Monocarp 在第 $ a_i $ 次尝试中撒掉了第 $ i $ 只BOSS。Polycarp 在第 $ b_i $ 次尝试中撒掉了第 $ i $ 只BOSS。其中一个人撒掉第 $ i $ 只BOSS后，他们就会尝试撒第 $ (i+1) $ 只BOSS。并且他们的尝试计数器都会清空。撒掉第 $ n $ 只BOSS后，游戏结束。 找到从$ 1 $ 到 $ n $所有的 $ k $ 值， 使得 Monocarp 可以杀死所有的BOSS。 1≤n≤2×1051 \\le n \\le 2\\times 10^51≤n≤2×105 题目分析： 题目说的实在是太抽象了，转化一下题意就是要找到满足以下条件的 kkk： ∀i∈[1,n]⌈aik⌉≤⌈bik⌉\\begin{aligned} &amp;\\forall i\\in[1,n] &amp; \\lceil \\frac{a_i}{k} \\rceil \\le \\lceil \\frac{b_i}{k} \\rceil \\end{aligned} ​∀i∈[1,n]​⌈kai​​⌉≤⌈kbi​​⌉​ 首先就是可以直接整除分块就能找到所有满足条件的 kkk，复杂度 O(nn)O(n\\sqrt{n})O(nn​) 但是常数有点逆天据说不能过，考虑优化。 一个经典的想法就是既然不能枚举约数，那么我们就枚举倍数，即枚举 kkk 然后枚举 kkk 的倍数。 可以发现 kkk 的倍数将序列分成了 O(nk)O(\\frac{n}{k})O(kn​) 段，而要使得上述条件满足就是 aia_iai​ 所在的块不在 bib_ibi​ 所在的块后面。 如果原来就满足 ai≤bia_i \\le b_iai​≤bi​ 则无论如何都满足条件，就不管了。 如果 ai&gt;bia_i &gt; b_iai​&gt;bi​ 条件其实就是 aia_iai​ 所在的块与 bib_ibi​ 所在的块相同，这个不是很好判，那么什么时候是不在一块呢？ 既然不在一块也就是说 [bi,ai][b_i,a_i][bi​,ai​] 跨过了一个分界点，如果我们以 kkk 的倍数作为每一段的右端点，也就是 [bi,ai)[b_i,a_i)[bi​,ai​) 包含 kkk 的倍数。 可以直接预处理出每一个位置是否可以作为右端点，然后对于每一个 kkk 的倍数判断一下即可。 复杂度 O(nlog⁡n)O(n \\log n)O(nlogn) 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5+5;int a[N],b[N],sum[N];vector&lt;int&gt; v;int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1; i&lt;=n; i++){ if(a[i] &gt; b[i]) sum[b[i]]++,sum[a[i]]--; } for(int i=1; i&lt;=n; i++) sum[i] += sum[i-1]; for(int i=1; i&lt;=n; i++){ bool flag = true; for(int j=i; j&lt;=n; j+=i){ if(sum[j]) flag = false; } if(flag) v.push_back(i); } printf(&quot;%d\\n&quot;,v.size()); for(int i=0; i&lt;v.size(); i++) printf(&quot;%d &quot;,v[i]); printf(&quot;\\n&quot;); for(int i=0; i&lt;=n; i++) sum[i] = 0; v.clear(); } return 0;} F.Double Sort II 题目描述： 有两个 1..n1..n1..n 的排列 a,ba,ba,b。 你可以进行若干次操作，每次操作流程如下： 选择一个整数 i∈[1,n]i \\in [1,n]i∈[1,n]。 找出两个整数 x,yx,yx,y，使得 ax=by=ia_x=b_y=iax​=by​=i。 交换 axa_xax​ 和 aia_iai​，以及 byb_yby​ 和 bib_ibi​。 问把 aaa 和 bbb 从小到大排序的最小操作次数 题目分析： 考虑将排列看作一个置换，然后建图，也就是连边 i→aii \\to a_ii→ai​ 与 i→bii \\to b_ii→bi​，注意这是两张图。 我们的一次操作相当于将某个点缩成一个自环，其他点不受影响，所以对于每一个置换环设其长度为 lenlenlen 只需要操作 len−1len-1len−1 次就可以将所有点缩成自环，即我们可以对于每一个环钦定一个点使得这个点不被操作，要最大化钦定点的数量。 而两张图其实也是差不多的，如果钦定 iii 不被操作，也就是说 iii 在 a,ba,ba,b 中的环上均只能选择 iii 这一个点不被操作，这个其实就是一个匹配的感觉。 所以可以对于每一个点 iii，找到其在 a,ba,ba,b 上的环，将这两个环连边，最后跑一个最大匹配就是最多的不用被操作的点数。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;struct edge{ int nxt,to,id; edge(){} edge(int _nxt,int _to,int _id){ nxt = _nxt,to = _to,id = _id; }}e[2 * N];int cnt,col1[N],col2[N],head[N],flag[N],match[N],a[N],b[N];bool vis[N],tag[N];void add_edge(int from,int to,int id){ e[++cnt] = edge(head[from],to,id); head[from] = cnt;}bool dfs(int now){ if(vis[now]) return false; vis[now] = true; for(int i=head[now] ;i ; i=e[i].nxt){ int to = e[i].to; if(!match[to] || dfs(match[to])){ match[now] = to,match[to] = now; flag[now] = flag[to] = e[i].id; return true; } } return false;}void dfs1(int now,int col){ if(col1[now]) return; col1[now] = col; if(!col1[a[now]]) dfs1(a[now],col);}void dfs2(int now,int col){ if(col2[now]) return; col2[now] = col; if(!col2[b[now]]) dfs2(b[now],col);}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;b[i]); int tot = 0; for(int i=1; i&lt;=n; i++){ if(col1[i]) continue; ++tot;dfs1(i,tot); } int tmp = tot; memset(vis,false,sizeof(vis)); for(int i=1; i&lt;=n; i++){ if(col2[i]) continue; ++tot;dfs2(i,tot); } for(int i=1; i&lt;=n; i++){ add_edge(col1[i],col2[i],i); add_edge(col2[i],col1[i],i);// printf(&quot;%d %d\\n&quot;,col1[i],col2[i]); } int ans = 0; for(int i=1; i&lt;=tmp; i++){ memset(vis,false,sizeof(vis)); ans += dfs(i); } printf(&quot;%d\\n&quot;,n - ans); for(int i=1; i&lt;=tmp; i++){ tag[flag[i]] = true; } for(int i=1; i&lt;=n; i++){ if(!tag[i]) printf(&quot;%d &quot;,i); } return 0;} G.Weighed Tree Radius 题目描述： 给你一个nnn个点的树和n−1n-1n−1条边。第iii个点的初始权值为aia_iai​。 定义结点vvv到结点uuu的距离dv(u)d_v(u)dv​(u)等于vvv和uuu之间的边的数量。注意:dv(u)=du(v),dv(v)=0d_v(u)=d_u(v),d_v(v)=0dv​(u)=du​(v),dv​(v)=0 定义结点vvv到结点uuu的权值距离wv(u)=dv(u)+auw_v(u)=d_v(u)+a_uwv​(u)=dv​(u)+au​。注意：wv(v)=av,wv(u)≠wu(v)w_v(v)=a_v,w_v(u) \\neq w_u(v)wv​(v)=av​,wv​(u)=wu​(v)如果au≠ava_u \\neq a_vau​=av​ 与通常的距离类似，让我们定义结点vvv的偏心距e(v)e(v)e(v)是从vvv到其他结点的最大权值距离（包括vvv本身），即e(v)=max⁡1≤u≤nwv(u)e(v)=\\max\\limits_{1\\leq u \\leq n} w_v(u)e(v)=1≤u≤nmax​wv​(u)。 最后，我们定义树的半径rrr是所有偏心距的最小值，即r=min⁡1≤v≤ne(v)r=\\min\\limits_{1\\leq v\\leq n} e(v)r=1≤v≤nmin​e(v) 你需要对mmm次询问进行回答，对于第jjj次询问，给出两个数vjv_jvj​和xjx_jxj​，表示将avja_{v_j}avj​​的值修改为xjx_jxj​。 在每次询问后，输出当前该树的半径rrr。 2≤n≤2×105，1≤m≤1052 \\le n \\le 2 \\times 10^5，1\\le m \\le 10^52≤n≤2×105，1≤m≤105 题目分析： 题目已经提示了这东西叫做半径，那么是不是直接求直径然后除以 222 就可以呢？ 我们定义 w′(u,v)=au+av+dis(u,v)w'(u,v) = a_u + a_v + dis(u,v)w′(u,v)=au​+av​+dis(u,v)，那么满足 w′(u,v)w'(u,v)w′(u,v) 最大的两个点 u,vu,vu,v 之间的路径的长度我们称为直径。 这里我们将 aua_uau​ 理解为挂在 uuu 上长度为 aua_uau​ 的链，ava_vav​ 理解为挂在 vvv 上长度为 ava_vav​ 的链。 设直径的中点为 midmidmid，若 midmidmid 在直径的某一个节点上，则显然 r=⌈w′(u,v)2⌉r = \\lceil \\frac{w'(u,v)}{2} \\rceilr=⌈2w′(u,v)​⌉，可是如果 midmidmid 不在直径的某一个节点上呢。 若 midmidmid 在 aua_uau​ 对应的链上，则必然满足 eu=aue_u = a_ueu​=au​，则对于其它的任意一个点 xxx 都必然满足 ex≥dis(u,x)+au&gt;au=eue_x \\ge dis(u,x) + a_u &gt; a_u = e_uex​≥dis(u,x)+au​&gt;au​=eu​，即 r=aur = a_ur=au​，但是这样的话就必然满足直径为 w′(u,u)w'(u,u)w′(u,u) 就不可能不存在了。 下面我们的问题就转化为了维护直径。 考虑假设我们原来的直径为 (u,v)(u,v)(u,v) 现在将 axa_xax​ 增大了一些，那么我们新直径的端点必然是 u,v,xu,v,xu,v,x 其中的两个，可以直接分类讨论得到答案。 而如果我们将 axa_xax​ 减小了一些，我们就无法判断直径端点的变化，所以可以考虑使用线段树分治维护修改，这样每次将值从 000 开始变化，这样每次都是加的操作了。","link":"/2023/09/13/Educational-Codeforces-Round-141-CF1783/"},{"title":"轻重链剖分","text":"树链剖分的部分理解，推荐阅读前有一定了解 对算法本身的部分理解 12345678if (son[now]) dfs2(son[now], topf)for (int i = head[now] i; i = e[i].nxt) { int to = e[i].to; if (to != fa[now] &amp;&amp; to != son[now]) { dfs2(to, to); }} 这是第二遍 dfsdfsdfs，定义：son[now]son[now]son[now] 为 nownownow 点的重儿子，topftopftopf 为当前的重链上深度最小的一个点也就是开始的点。我们在遍历整棵树的时候，会选择先去遍历这个点的左儿子然后再去管其他的点。我们在这一遍遍历其实就是在给他们分配线段树上的基本信息以及记录轻重链的基本信息，在我们的轻重链剖分的时候，是会将重链看作是线段树上维护的的一段连续区间，先访问重儿子可以使得其的重儿子在线段树上的维护的下标为它加一，也就是说是连续的，也就是一条重链对应连续的一段。 这是寻找 x,yx,yx,y 树上路径的相关信息，定义：top[x]top[x]top[x] 为 xxx 节点所在的重链的深度最小的节点（这里节点均为树上的编号），也就是这条重链的开始，dep[x]dep[x]dep[x] 为 xxx 节点在树上的深度，id[x]id[x]id[x] 为节点 xxx 在线段树上的编号。也就是这几行代码是在查询树上 x,yx,yx,y 节点之间的路径上经过的节点的权值和。我们一点点地去看。 首先看循环内部，第一个判断条件就是寻找一个重链的起点深度最大的一个，也就是树上最靠下的一个，然后查询这条重链的信息后就直接跳出这条重链，我们考虑跳深度大的一条链一定不会跳过头，而跳深度小的一条链可能会跳过头了，如下图所示： 我们以红色边代表重边，以黑色边代表轻边，我们看在这样的情况下如果直接去跳过 yyy 所在的这条重链，那么就会跳到节点 111 很明显这不正确，所以就会选择跳 xxx 所在的这条重链，这样不可能会跳出去我们的正确路径。 再看下边的线段树的询问，因为我们的分配线段树上的基本信息是自根到底，所以深度小的节点在线段树上的编号就小，深度大的节点在线段树上的深度就大，所以查询的区间左端点是这条重链的开始，右端点是它本身。 再看下边关于跳过这条重链的情况，我们的 xxx 跳要跳到其重链的开始的父亲节点，因为如果我们不是跳到父亲结点的话，我们一是会将其重链开始的节点的信息重复计算，二是我们可能下一次跳还是选择这一条重链，但是它的起点就是当前的 xxx 节点，所以就死循环了。 翻过来看一眼循环条件，这个循环条件相当于是在约束 x,yx,yx,y 不在同一条重链上，因为我们循环是在跳重链，所以如果它们在同一条重链上那么这条重链肯定不能直接跳过了，就应该直接在这条重链上去询问 x,yx,yx,y 的线段树上的相关信息，因为他们在同一重链，所以编号一定是连续的，直接询问那一段就可以了。 最后三行，因为深度大的节点线段树上的编号也大，所以线段树上的区间就是从深度小的节点到深度大的节点。 注意： 我们所给他们分配的线段树上维护的下标或者叫编号就相当于 dfsdfsdfs 序，所以满足 dfsdfsdfs 具有的性质。","link":"/2022/03/29/heavy-light-decomp/"},{"title":"高斯消元","text":"从零开始的高斯消元 说在前面： 高斯消元看上去是一个很复杂的东西，但是其实只要是理解了就会发现也就那样的 算法功能： 解方程组。 没错就是如此的简单，就是去解方程组。但是高斯消元一般是用来解决含有上百个未知数的方程组。 其时间复杂度为 O(n3)O(n^3)O(n3) 算法详解： 下面我就来介绍一下高斯消元的最简单的应用，也就是解正常的一次方程组。 比如我们有以下的方程组： {3x1+4x2+x3=95x1+10x2+7x3=52x1+7x2+3x3=10\\left\\{ \\begin{array}{} 3x_1 + 4x_2 + x_3 = 9 \\\\ 5x_1 + 10x_2 + 7x_3 = 5 \\\\ 2x_1 + 7x_2 + 3x_3 = 10 \\end{array} \\right. ⎩⎪⎨⎪⎧​3x1​+4x2​+x3​=95x1​+10x2​+7x3​=52x1​+7x2​+3x3​=10​ 在高斯消元的过程中我们会将它转化为一个矩阵，矩阵里第 iii 行代表第 iii 个式子，第 jjj 列代表第 jjj 个未知数的系数，其中第 n+1n+1n+1 也就是最后一列，代表常数项，也就是等于号后面的数 那么以上的这个方程组就会被写为： [x1x2x3C34195107527310]\\begin{bmatrix} x_1 &amp; x_2 &amp; x_3 &amp; C \\\\ 3 &amp; 4 &amp; 1 &amp; 9 \\\\ 5 &amp; 10 &amp; 7 &amp; 5 \\\\ 2 &amp; 7 &amp; 3 &amp; 10 \\\\ \\end{bmatrix} ⎣⎢⎢⎢⎡​x1​352​x2​4107​x3​173​C9510​⎦⎥⎥⎥⎤​ 这个时候可能会很懵，但是一定要静下心来仔细看看这个矩阵和上面的方程组 我们高斯消元的思想就是加减消元，就是我们在小学会学习到的那个知识 加减消元的解释：（如果会了就请跳过，避免看了之后有点晕） 比如我们有以下一个二元一次方程组： {3x+2y=6(1)x+3y=2(2)\\left\\{ \\begin{array}{} 3x + 2y = 6 &amp; (1)\\\\ x + 3y = 2 &amp; (2) \\end{array} \\right. {3x+2y=6x+3y=2​(1)(2)​ 那么如何进行加减消元呢？ 我们考虑先消掉 xxx 很简单：(1)−3×(2)(1) - 3 \\times (2)(1)−3×(2) 这样就能得到 −7y=0-7y = 0 −7y=0 我们就成功地将 xxx 这个未知数消掉了，接下来就只剩下了一个未知数，很明显就可以直接算出来 y=0y = 0y=0，然后将这个值带回去，就能解出 x=2x = 2x=2 我们在高斯消元中，就是用加减消元，从第一个未知数开始一个一个地消，直到消到只剩下一个未知数就能很轻松地能将方程解出来 按我的代码习惯而言，就是将每一个式子都消掉只剩一个未知数，这样 nnn 个式子每个式子对应一个未知数就很好地能解出来 代码详解： 下面先放代码，根据代码一点点来解释 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;double a[105][105];int n;bool Gauss(){ for(int i=1; i&lt;=n; i++){ //第几个未知数/第几列 int mx = i; //先让最大值为 i; for(int j = i+1; j&lt;=n; j++){ //找到第 i 列上绝对值最大的那个数在第几行 //前 i-1 行已经有了自己的位置，就是自己有独特的保留的未知数了，再次将他设为 i 需要的值 //那么它本身的那个数就没了 if(fabs(a[j][i]) &gt; fabs(a[mx][i])){ mx = j; } } //我们认为第 i 行就是仅包含第 i 个未知数的那一行 if(mx != i){ //交换两行，需要全部交换 for(int j=1; j&lt;=n+1; j++){ swap(a[i][j],a[mx][j]); } } if(!a[i][i]){ //这一列都是 0 ，所以说这一列对未知数没有限制，也就是有可以任意取值的未知数 printf(&quot;No Solution&quot;); return false; } for(int j=1; j&lt;=n; j++){ if(j != i){ double tmp = a[j][i] / a[i][i]; //代表要减多少倍才能将这一行的第 i 个未知数消掉，因为要减一起减，所以就全部减了 for(int k = i; k&lt;=n+1; k++){ //因为前 i 列已经被之前消没了，就全是 0 了 a[j][k] -= a[i][k] * tmp; } } } } return true;}int main(){ cin&gt;&gt;n; for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=n+1; j++){ cin&gt;&gt;a[i][j]; } } if(Gauss()){ for(int i=1; i&lt;=n; i++){ printf(&quot;%.2f\\n&quot;,a[i][n + 1] / a[i][i]); } } return 0;} 我们就顺着代码一点点来看，这里的高斯消元部分也就是那个 Gauss()Gauss()Gauss() 函数（可能有点长，但是耐心读一读应该会有所收获） 首先最外层循环，枚举当前消到了哪一个未知数，也就是该消哪一个了。 注意我上文的解释，既然枚举到了这一个未知数，那么按照我的码风来说，前 i−1i-1i−1 个未知数是都被消没了的，因为如果没有消没，就不可能再将后面的式子都化为只含有一个未知数的式子 然后就继续往下看。 下面的这个 forforfor 循环就是在寻找当前未知数中绝对值最大的是谁在哪一个式子里，然后我们就要将别的式子通过加减我们找到的这个式子，来将当前的未知数消掉。 而且我们默认有一点：第 iii 个式子其最后只含有第 iii 个未知数，所以我们的 jjj 是从 iii 开始枚举，一开始第 iii 行被认为是最大的一行，也相当于枚举了，也就有了下面的 ififif 里面的交换操作。 注意对于交换完了之后第 iii 个式子就是我们找到的当前未知数绝对值最大的一个式子，那么第 iii 行的第 iii 列，也就是第 iii 个未知数绝对值最大的那个数 继续最后的一个循环，就是用第 iii 行的这个式子去消其他的式子，也就是将其他行的第 iii 个未知数消去，让他们的系数全都变成 000 其他的不用我多说，我代码里写的也很清楚，也很简单，重点在于 kkk 的范围 [i,n+1][i,n+1][i,n+1]，是不是有种很懵的感觉 不着急，我们一点点看，先看左边界 iii ，因为我们消元就是将除了第 iii 个式子之外的所有式子中含有的未知数 iii 的系数全部变成 000，那么就意味着当我们枚举到 iii 的时候前 i−1i-1i−1 个未知数，也就是前 i−1i-1i−1 行，一定都被全消成 000 了，那么此时我们再去枚举这些本来就是 000 的地方，想让他变成 000 也就没有任何意义了。 再来看右边界 n+1n+1n+1，我们考虑第 n+1n+1n+1 列存的是什么，存的是不是就是我们的常数项啊，在我们加减消元的过程中常数项也是需要加减的，因为这样才会满足等式的性质，等于号才不变 如果有感觉我哪里解释的不对或者不清楚，欢迎给我留言","link":"/2022/04/25/gao-si-xiao-yuan/"},{"title":"后缀数组","text":"对于后缀数组的浅谈，推荐阅读前有一定了解 对算法本身的部分理解： 本部分可以认为是读过一位大佬的后缀数组博客的感受，加上对于某些地方我感觉大佬解释的不是很明白，所以还有一部分我自己对这一部分的理解与解释，当然只是部分我认为不是很懂的内容，只是一部分，更多还要去看这位大佬的博客。 第一行： 这就相当于对于一个字符串，其没有后 www 位，既然没有后 www 位，那就应该是排在前面 第二行： 首先不用管所谓的 sa[i]&gt;wsa[i] &gt; wsa[i]&gt;w，这只是个特判没有任何意义，其实也就是为了保证存在而已，也暂时不用考虑第一条语句所提前处理出来的一些数据。 我们现在必须搞清楚我们要求什么，求的也就是 tptptp 数组，其中 tp[i]tp[i]tp[i] 代表长度为 $2\\times w $ 的串中，只看后 www 个元素排名为 iii 的串的起始位置 对于 sa[i]−wsa[i] - wsa[i]−w 就是让原本的长度为 www 的后缀中排名为 iii 的那个的起始位置左移 www 位，那么是不是也就相当于 sa[i]−wsa[i]-wsa[i]−w 就是代表着左右长度为 2×w2 \\times w2×w 的后缀中，按后 www 个元素排序的第 iii 个串的起始位置。我们考虑 sa[i]sa[i]sa[i] 代表着长度为 www 的后缀中排名为 iii 的那个元素的排名，那么对于长度为 2×w2\\times w2×w 的串来说，sa[i]sa[i]sa[i] 其实就相当于某一个长度为 2×w2\\times w2×w 的串的后缀，那么这个串很明显就是 sa[i]−wsa[i] - wsa[i]−w 为开始的串。注意 sa[i]sa[i]sa[i] 里存的也是起始位置。 因为我们的 iii 从小到大枚举，所以我们直接计数器累加即可 我们考虑此时 sa[i]sa[i]sa[i] 就是长度为 www 的串中排名为 iii 的串起始位置，tp[i]tp[i]tp[i] 就是所有长度为 2×w2\\times w2×w 的串中后按 www 个元素排序，排名为 iii 的串的起始位置， rk[i]rk[i]rk[i] 就是所有长度为 www 的串中以 iii 为开头的串排第几。我们的基数排序就是以 rkrkrk 为第一关键字以 tptptp 为第二关键字的排序，此时这两个关键字都处理好了，所以直接排序得到新的 sasasa 数组即可 我们首先必须明确 tax[i]tax[i]tax[i] 代表按前 www 个元素排名，排名小于等于 iii 的串的个数，也就是代表着按前 www 个元素排名，排名为 iii 的元素的排名加排名为 iii 的串的个数 前三行非常好理解，就是为了得到 taxtaxtax 数组，关键在与最后一行非常难以理解。 我们先一点点地看 rak[tp[i]]rak[tp[i]]rak[tp[i]] 代表的含义就是长度为 2×w2\\times w2×w 的串中，后 www 个元素排名为 iii 的那个位置的前 www 个元素的排名 tax[rak[tp[i]]]tax[rak[tp[i]]]tax[rak[tp[i]]] 也就是代表着长度为 2×w2\\times w2×w 的串中，后 www 个元素排名为 iii 的那个位置的前 www 个元素的排名，注意这里的最后的排名是指被分到的排名 $tax[rak[tp[i]]] – $ 关于这个自减的理解，我们考虑就是对于按第一关键字也就是前 www 个元素排名相同的点，因为我们的第二关键字不一定相同所以我们的最终他们虽然第一关键字一定一样但是第二关键字不一定一样，因此被分到的排名也不一定相同（可能有点绕），注意我们的循环顺序，也就是枚举的顺序，我们是按第二关键字从大到小去枚举，也就意味着当这个长度为 $2\\times w $ 的字串的第一关键字也就是前 www 个元素排名相同时，我们第二关键字也就是按后 www 个元素的排名越大被分到的最终排名也就越大，也就符合了我们按双关键字排序的目的。 sa[tax[rak[tp[i]]]−−]=tp[i]sa[tax[rak[tp[i]]]−−] = tp[i]sa[tax[rak[tp[i]]]−−]=tp[i] 也就相当于排名为 tax[rak[tp[i]]]−−tax[rak[tp[i]]]−−tax[rak[tp[i]]]−− 的串的起始位置也就是 tp[i]tp[i]tp[i] 这个串的起始位置，也就是 tp[i]tp[i]tp[i] 这里就是对 rkrkrk 数组的更新 对于这里的 tp[i]tp[i]tp[i] 代表长度为 www 的串里起始位置为 iii 的串的排名，也就是我们之前的 rkrkrk 数组， sa[i]sa[i]sa[i] 代表长度为 2×w2\\times w2×w 的串里，排名为 iii 的串的起始位置 我们这里其实就是在判断排名为 iii 的串和排名为 i−1i-1i−1 的串的排名是否相同，第一个判断也就相当于他们前 www 个元素是相同的，第二个判断也就相当于他们的后 www 个元素是相同的，所以如果两个全部满足，也就意味着 2×w2\\times w2×w 个元素都是相同的，也就意味着 iii 与 i−1i-1i−1 的排名相同 关于 heightheightheight 数组的更新： 对于 heightheightheight 数组某大佬证明了一个定理： H[i]≥H[i−1]−1H[i]\\ge H[i-1] - 1H[i]≥H[i−1]−1 我们对 heightheightheight 数组的定义，排名为 iii 的后缀与排名为 i−1i-1i−1 的后缀的最长公共前缀的长度，即 height[i]=lcp(sa[i],sa[i−1])height[i]=lcp(sa[i],sa[i-1])height[i]=lcp(sa[i],sa[i−1]) 。 我们定义 H[i]=height[rak[i]]=lcp(sa[rak[i]],sa[rak[i]−1])=lcp(i,sa[rak[i]−1])H[i] = height[rak[i]] = lcp(sa[rak[i]],sa[rak[i]-1])=lcp(i,sa[rak[i]-1])H[i]=height[rak[i]]=lcp(sa[rak[i]],sa[rak[i]−1])=lcp(i,sa[rak[i]−1]) 也就是第 iii 号后缀与排名在第 iii 号后缀前一个的后缀的最长公共前缀的长度，这里的所谓的前一个后缀的起始位置也就是 sa[rak[i]−1]sa[rak[i] - 1]sa[rak[i]−1] ，对于 HHH 数组直接根据定义加下界去算就可以了，算完了更新 height[rak[i]]height[rak[i]]height[rak[i]] 即可","link":"/2022/03/29/hou-zhui-shu-zu/"},{"title":"金牌导航-高斯消元&#x2F;Luogu P3232 游走","text":"这应该是我们做的除模板外的第一道高斯消元吧（我是的） 题目描述： 详细分析： 我们对于编号的分配，很明显可以发现如下的分配就是期望最小的：对经过的期望次数越大的边赋予更小的编号。 那么问题就转化为了怎么求一条边的经过的期望次数，我们发现边数非常大所以肯定不好弄，所以我们就转而看很少的点。因为我们会发现如果我们能知道经过每个点的期望次数，那么这条边的期望次数很轻松就能表达出来。 比如如下的式子：（设 ans[i]ans[i]ans[i] 为经过第 iii 个点的期望次数, du[i]du[i]du[i] 为第 iii 个点的度数, res[i]res[i]res[i] 为经过第 iii 条边的期望次数） res[i]=ans[from]du[from]+ans[to]du[to]res[i] = \\dfrac{ans[from]}{du[from]} + \\dfrac{ans[to]}{du[to]} res[i]=du[from]ans[from]​+du[to]ans[to]​ 这个式子应该很好理解，就是说每个点等概率地选择和他相连的边，所以选择这一条边地期望次数就是经过它的期望次数除以它的度数，也就是与他相连的边的数量，因为这条边可以从两个端点开始走然后经过，所以应该加上两个端点的值。 上文探讨了如果知道经过所有点的期望次数如何求经过这条边的期望，那么下文就来看看如何求经过每个点的期望次数。 很明显可以列出这样的一个式子： ans[i]=∑ans[to]du[to]ans[i] = \\sum \\dfrac{ans[to]}{du[to]} ans[i]=∑du[to]ans[to]​ 注意 tototo 是指所有与 iii 有边直接相连的点，tototo 不包含 nnn 号节点，因为这个式子的含义从是 tototo 等概率地回到 iii 节点，可是 nnn 号节点就停了，也就不存在再走回来的情况了 但是其实还有一种特殊情况，就是对于 111 号节点，其作为初始节点所以一定在开始时被经过一次，所以其不仅要计算从别的点到来的期望次数，更要算其一开始的这一次 ans[1]=1+∑ans[to]du[to]ans[1] = 1 + \\sum \\dfrac{ans[to]}{du[to]} ans[1]=1+∑du[to]ans[to]​ 我们会发现上文的这个式子会出现循环依赖的情况,就是假设 AAA 的值需要 BBB 的值才能推出来，但是 BBB 也同样需要 AAA 才能推出来。而且我们考虑这个式子不含有最大值最小值的操作，所以就考虑使用高斯消元，把这个式子化成一个方程，然后求解. 那么既然要高斯消元就要考虑我们的未知数是什么,我们的系数是什么,常数是什么,这一切都是根据我上面的式子得出来的. 首先未知数肯定非常容易,就是我们不知道的数嘛,那我们不知道什么?就是 ansansans 数组啊,所以 ansansans 就是我们的未知数, ans[i]ans[i]ans[i] 就代表我们的第 iii 个未知数. 这个明白了之后剩下的就非常简单的,考虑对上面的式子进行转化 ans[i]−∑1du[to]×ans[to]=0ans[i] - \\sum \\dfrac{1}{du[to]} \\times ans[to] = 0 ans[i]−∑du[to]1​×ans[to]=0 很明显 dududu 数组我们是知道的,又发现有一个 1du[to]×ans[to]\\dfrac{1}{du[to]} \\times ans[to]du[to]1​×ans[to] 的项,所以 dududu 数组就理所应当的成为了我们的系数 会发现了常数项除了 ans[1]ans[1]ans[1] 的方程含有一个 111 ,其他的都是 000. 注意在代码里我的 aaa 数组开的二维,因为我们的高斯消元需要知道第几个方程,所以就按照第一个点的顺序给方程编了号,所以 aaa 数组的第一维就是编号,第二维才是我们的未知数,这也就与正常的高斯消元一样了 代码详解: 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-6;const int MAXN = 505;const int MAXM = 130000;struct edge{ int nxt,to; edge(int _nxt = 0,int _to = 0){ nxt = _nxt,to = _to; }}e[2 * MAXM];double a[MAXN][MAXN];double ans[MAXN],res[MAXM];int from[MAXM],to[MAXM],head[MAXN],du[MAXN];int n,m,cnt;void Gauss(int n){ //推荐里面写一个 n ，然后直接按模板敲就好了 for(int i=1; i&lt;=n; i++){ int mx = i; for(int j=i + 1; j&lt;=n; j++){ if(fabs(a[j][i]) &gt; fabs(a[mx][i])){ mx = j; } } if(mx != i) { for(int j=1; j&lt;=n+1; j++){ swap(a[i][j],a[mx][j]); } } for(int j=1; j&lt;=n; j++){ if(j != i){ double tmp = a[j][i] / a[i][i]; for(int k=i; k&lt;=n+1; k++){ a[j][k] -= tmp * a[i][k]; } } } } for(int i=1; i&lt;=n; i++){ //ans[i] 即我们最后解出来的解 ans[i] = a[i][n+1] / a[i][i]; }}void add_edge(int from,int to){ e[++cnt] = edge(head[from],to); head[from] = cnt;}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=m; i++){ cin&gt;&gt;from[i]&gt;&gt;to[i]; add_edge(from[i],to[i]); add_edge(to[i],from[i]); du[from[i]]++;du[to[i]]++; } for(int i=1; i&lt;n; i++){ //注意一点，因为到 n 就停了，所以 n 的期望等就不用算了 a[i][i] = 1; //根据我们的式子可以化出来 for(int j=head[i]; j; j = e[j].nxt){ int to = e[j].to; if(to != n){ //注意 to != n a[i][to] = -1.0/du[to]; //根据我们的式子可以化出来 } } } a[1][n] = 1; //根据式子可以化出来 Gauss(n-1); for(int i=1; i&lt;=m; i++){ if(from[i] != n){ res[i] += ans[from[i]] / du[from[i]]; //到达这个点的期望除以度数，就是从这个点到当前点的期望 } if(to[i] != n){ res[i] += ans[to[i]] / du[to[i]]; } } sort(res+1,res+m+1); //从小到大排边 //一定要相信 STL,如果自己写一个 cmp（例如我），就会造成神奇的精度问题 double h = 0; for(int i=1; i&lt;=m; i++){ //越大的期望的边给他越小的编号 h += res[i] * (m - i + 1); } printf(&quot;%.3f&quot;,h); return 0;} 我的上文对这个代码的解释应该也比较合理了,如果有任何疑问或者感觉我说的不对的地方欢迎大家留言或者私信我","link":"/2022/04/26/jinpaidaohang-gaosixiaoyuan-Luogu-P3232-youzou/"},{"title":"数学知识","text":"大概就是一个数学知识的梳理，可能会有一些地方写的并不是很全很好，未来可能会补。 模意义下的数论 欧几里得算法 gcd⁡(a,b)=gcd⁡(b,a%b)\\gcd(a,b) = \\gcd(b,a\\% b) gcd(a,b)=gcd(b,a%b) 扩展欧几里得算法 求解： ax+by=gcd⁡(a,b)ax + by = \\gcd(a,b) ax+by=gcd(a,b) 分析： 设 ax1+by1=gcd⁡(a,b)ax_1 + by_1 = \\gcd(a,b)ax1​+by1​=gcd(a,b)，bx2+(a%b)y2=gcd⁡(b,a%b)bx_2 + (a\\%b)y_2 = \\gcd(b,a\\%b)bx2​+(a%b)y2​=gcd(b,a%b)。 根据欧几里得算法则 gcd⁡(a,b)=gcd⁡(b,a%b)\\gcd(a,b) = \\gcd(b,a\\%b)gcd(a,b)=gcd(b,a%b)，也就是说： ax1+by1=bx2+(a%b)y2ax_1 + by_1 = bx_2 + (a\\%b)y_2 ax1​+by1​=bx2​+(a%b)y2​ 根据 a%b=a−⌊ab⌋×ba \\% b = a - \\lfloor \\frac{a}{b} \\rfloor \\times ba%b=a−⌊ba​⌋×b，则有： ax1+by1=bx2+(a−⌊ab⌋×b)y2ax_1 + by_1 = bx_2 + (a - \\lfloor \\frac{a}{b} \\rfloor \\times b)y_2 ax1​+by1​=bx2​+(a−⌊ba​⌋×b)y2​ 化简一下就有： ax1+by1=ay2+b(x2−⌊ab⌋×b×y2)ax_1 + by_1 = ay_2 + b(x_2 - \\lfloor \\frac{a}{b} \\rfloor \\times b \\times y_2) ax1​+by1​=ay2​+b(x2​−⌊ba​⌋×b×y2​) 必然存在一组解为 x1=y2,y1=x2−⌊ab⌋×b×y2x_1 = y_2,y_1 = x_2 - \\lfloor \\frac{a}{b} \\rfloor \\times b \\times y_2x1​=y2​,y1​=x2​−⌊ba​⌋×b×y2​ 不断递归下去，当 b=0b = 0b=0 时使用 x=1,y=0x=1,y=0x=1,y=0 作为一组解然后回溯即可。 费马小定理 对于素数 ppp，若 gcd⁡(a,p)=1\\gcd(a,p) = 1gcd(a,p)=1，则有： ap−1≡1mod pa^{p-1} \\equiv 1 \\mod p ap−1≡1modp 欧拉定理 若 gcd⁡(a,p)=1\\gcd(a,p) = 1gcd(a,p)=1，则有： aφ(p)≡1mod pa^{\\varphi(p)} \\equiv 1 \\mod p aφ(p)≡1modp 扩展欧拉定理 ab={abmod φ(p)gcd⁡(b,p)=1abgcd⁡(b,p)≠1,b&lt;φ(p)a[b%φ(p)+φ(p)]%φ(p)gcd⁡(b,p)≠1,b≥φ(p)a^b = \\begin{cases} a^{b \\mod \\varphi(p)} &amp; \\gcd(b,p) = 1\\\\ a^b &amp; \\gcd(b,p) \\not= 1,b &lt; \\varphi(p) \\\\ a^{[b \\% \\varphi(p) + \\varphi(p)]\\% \\varphi(p)} &amp; \\gcd(b,p) \\not= 1,b \\ge \\varphi(p) \\end{cases} ab=⎩⎪⎪⎨⎪⎪⎧​abmodφ(p)aba[b%φ(p)+φ(p)]%φ(p)​gcd(b,p)=1gcd(b,p)=1,b&lt;φ(p)gcd(b,p)=1,b≥φ(p)​ 中国剩余定理 问题描述： 求一组解： {x≡a1mod m1x≡a2mod m2⋯x≡anmod mn\\begin{cases} x \\equiv a_1 \\mod m_1 \\\\ x \\equiv a_2 \\mod m_2 \\\\ \\cdots \\\\ x \\equiv a_n \\mod m_n \\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​x≡a1​modm1​x≡a2​modm2​⋯x≡an​modmn​​ 其实满足 m1,m2,⋯ ,mnm_1,m_2,\\cdots,m_nm1​,m2​,⋯,mn​ 两两互质 问题分析： 令 M=∏i=1naiM = \\prod_{i=1}^n a_iM=∏i=1n​ai​。 对于第 iii 个方程，令 pi=Mmip_i = \\frac{M}{m_i}pi​=mi​M​，计算 pip_ipi​ 在模 mim_imi​ 意义下的逆元 pi−1p_i^{-1}pi−1​，令 ci=pipi−1c_i = p_ip_i^{-1}ci​=pi​pi−1​（不对 mim_imi​ 取模）。 则答案为 x=∑i=1nciaimod Mx = \\sum_{i=1}^n c_ia_i \\mod Mx=∑i=1n​ci​ai​modM 扩展中国剩余定理 考虑合并两个方程： x≡a1mod m1x≡a2mod m2x \\equiv a_1 \\mod m_1 \\\\ x \\equiv a_2 \\mod m_2 x≡a1​modm1​x≡a2​modm2​ 可以将它们转化为不定方程即： x=m1p+a1=m2q+a2x = m_1p + a_1 = m_2q + a_2 x=m1​p+a1​=m2​q+a2​ 转化一下即 m1p−m2q=a2−a1m_1p - m_2q = a_2 - a_1m1​p−m2​q=a2​−a1​，根据裴蜀定理当 a2−a1a_2 - a_1a2​−a1​ 不能被 m1−m2m_1 - m_2m1​−m2​ 整除时无解，否则可以通过扩展欧几里得算法得到一组解 p,qp,qp,q。 这样的话就可以将原方程组合并为：x≡bmod Mx \\equiv b \\mod Mx≡bmodM，其中 b=m1p+a1，M=lcm(m1,m2)b = m_1p + a_1，M = \\text{lcm}(m_1,m_2)b=m1​p+a1​，M=lcm(m1​,m2​) Wilson 定理 ppp 为素数的充要条件为 (p−1)!≡−1mod p(p-1)! \\equiv -1 \\mod p(p−1)!≡−1modp Kummer 定理 形式一：ppp 在 (nm)\\binom{n}{m}(mn​) 中的幂次，等于 ppp 进制下 n−mn - mn−m 需要的借位次数 形式二：ppp 在 (n+mm)\\binom{n+m}{m}(mn+m​) 中的幂次，等于 ppp 进制下 n+mn+mn+m 的进位次数 Lucas 定理 若有两个正整数 n,mn,mn,m 和一个素数 ppp，则有： (nm)=(nmod pmmod p)×(⌊np⌋⌊mp⌋)\\binom{n}{m} = \\binom{n \\mod p}{m \\mod p} \\times \\binom{\\lfloor \\frac{n}{p} \\rfloor}{\\lfloor \\frac{m}{p} \\rfloor} (mn​)=(mmodpnmodp​)×(⌊pm​⌋⌊pn​⌋​) 感性的理解就是拆到 ppp 进制下，然后每一位单独考虑。 阶 定义： 对于 a∈Z，m∈N∗a \\in \\mathbb{Z}，m \\in \\mathbb{N}^*a∈Z，m∈N∗，若 (a,m)=1(a,m) = 1(a,m)=1，则满足 an≡1(modm)a^n \\equiv 1 \\pmod man≡1(modm) 的最小正整数 nnn 称为 aaa 模 mmm 的阶，记为 δm(a)\\delta_m(a)δm​(a) 或 ordm(a)\\text{ord}_m(a)ordm​(a)。 性质一： a1,a2,⋯ ,aδm(a)a^1,a^2,\\cdots,a^{\\delta_m(a)}a1,a2,⋯,aδm​(a) 模 mmm 两两不同余。 证明：考虑使用反证法，若存在 i≠ji \\not= ji=j 满足 ai≡aj(modm)a^i \\equiv a^j \\pmod mai≡aj(modm)，则必然有 a∣i−j∣≡1(modm)a^{|i-j|} \\equiv 1 \\pmod ma∣i−j∣≡1(modm)，而 0&lt;∣i−j∣&lt;δm(a)0 &lt; |i-j| &lt; \\delta_m(a)0&lt;∣i−j∣&lt;δm​(a) 与定义冲突。 性质二： 若 an≡1(modm)a^n \\equiv 1 \\pmod man≡1(modm)，则必然有 δm(a)∣n\\delta_m(a) | nδm​(a)∣n。以及据此可以推出若 ap≡aqa^p \\equiv a^qap≡aq，则 p≡q(modδm(a))p \\equiv q \\pmod{\\delta_m(a)}p≡q(modδm​(a)) 性质三： δm(ab)=δm(a)δm(b)\\delta_m(ab) = \\delta_m(a) \\delta_m(b)δm​(ab)=δm​(a)δm​(b) 的充要条件为 (δm(a),δm(b))=1(\\delta_m(a),\\delta_m(b)) = 1(δm​(a),δm​(b))=1。 性质四： δm(ak)=δm(a)(δm(a),k)\\delta_m(a^k) = \\dfrac{\\delta_m(a)}{(\\delta_m(a),k)}δm​(ak)=(δm​(a),k)δm​(a)​ 所以根据上面这些性质，阶就给了人一种“循环节”的感觉。 原根 若 δm(g)=φ(m)\\delta_m(g) = \\varphi(m)δm​(g)=φ(m)，则称 ggg 为模 mmm 意义下的原根。 性质一： ggg 是模 mmm 意义下的原根的充要条件为，对于 φ(m)\\varphi(m)φ(m) 的每个质因数 ppp，都有 gφ(m)p≢1(modm)g^{\\frac{\\varphi(m)}{p}} \\not\\equiv 1 \\pmod mgpφ(m)​≡1(modm) 性质二： 若模 mmm 意义下有原根，则原根个数为 φ(φ(m))\\varphi(\\varphi(m))φ(φ(m)) 性质三： 数 mmm 存在原根当且仅当 m=2,4,pα,2pαm = 2,4,p^{\\alpha},2p^{\\alpha}m=2,4,pα,2pα，其中 ppp 为奇质数，α∈N∗\\alpha \\in \\mathbb{N}^*α∈N∗ 性质四： 最小原根的值为 O(n0.25)O(n^{0.25})O(n0.25)，可以暴力。 BSGS 满足 (a,p)=1(a,p) = 1(a,p)=1，求解下列方程的解： ax≡b(modp)a^x \\equiv b \\pmod p ax≡b(modp) 考虑按 ttt 分块，也就是将上述式子改写为： ait+j≡b(modp)a^{it + j} \\equiv b \\pmod p ait+j≡b(modp) 移一下项也就是： aj≡b×a−it(modp)a^j \\equiv b \\times a^{-it} \\pmod p aj≡b×a−it(modp) 所以就可以直接预处理 a0,a1,⋯ ,at−1a^0,a^1,\\cdots,a^{t-1}a0,a1,⋯,at−1，然后枚举 iii，通过 hash 判断预处理的数里面是否存在 b×a−itb \\times a^{-it}b×a−it 即可。 显然当 t=pt = \\sqrt{p}t=p​ 时复杂度最优，为 O(p)O(\\sqrt{p})O(p​)。 exBSGS 不满足 (a,p)=1(a,p) = 1(a,p)=1，求解下列方程的解： ax≡b(modp)a^x \\equiv b \\pmod p ax≡b(modp) 想法就是将这个方程转化为 (a,p)=1(a,p) = 1(a,p)=1。 首先这个方程显然可以转化为： ax+kp=ba^x + kp = b ax+kp=b 设 (a,p)=d(a,p) = d(a,p)=d，根据裴蜀定理这个式子有解当且仅当 d∣bd \\mid bd∣b，所以不合法直接判无解。 这样的话这个式子就可以转化为： ax−1⋅ad+k⋅pd=bda^{x-1}\\cdot \\frac{a}{d} + k\\cdot \\frac{p}{d} = \\frac{b}{d} ax−1⋅da​+k⋅dp​=db​ 此时可以令 ax−1→ax,pd→p,bd→ba^{x-1} \\to a^x,\\frac{p}{d} \\to p,\\frac{b}{d} \\to bax−1→ax,dp​→p,db​→b，这样一直递归下去，直到 (a,p)=1(a,p) = 1(a,p)=1。 设总共递归了 cntcntcnt 次，递归过程中 ddd 的乘积为 d′d'd′，则显然原式为： ax−cnt⋅acntd′≡bd′(modpd′)a^{x-cnt}\\cdot \\frac{a^{cnt}}{d'} \\equiv \\frac{b}{d'} \\pmod{\\frac{p}{d'}} ax−cnt⋅d′acnt​≡d′b​(modd′p​) 此时直接令 a′=a,b′=bd′,p′=pd′a' = a,b' = \\frac{b}{d'},p'= \\frac{p}{d'}a′=a,b′=d′b​,p′=d′p​，跑一遍 BSGS 然后将答案加 cntcntcnt 即可。 要注意此时左边式子会多一个 acntd′\\frac{a_{cnt}}{d'}d′acnt​​ 的系数，要记得乘上。 二次剩余 定义： 若 ppp 为奇质数，且 (n,p)=1(n,p) = 1(n,p)=1，使得存在一个 xxx 满足： x2≡n(modp)x^2 \\equiv n \\pmod p x2≡n(modp) 则称 nnn 为模 ppp 意义下的二次剩余，简称二次剩余，默认 n≥1n \\ge 1n≥1。（顾名思义就是二次方后剩余的数） 二次剩余的数量： 考虑对于一个二次剩余 nnn，考虑 x2≡n(modp)x^2 \\equiv n \\pmod px2≡n(modp) 有多少个解。 若存在多个解，设其中两个解为 x0,x1x_0,x_1x0​,x1​ 且满足 x0≠x1x_0 \\not= x_1x0​=x1​，则有： x02≡x12(modp)x_0^2 \\equiv x_1^2 \\pmod p x02​≡x12​(modp) 化简一下就是： (x0−x1)(x0+x1)≡0(modp)(x_0-x_1)(x_0+x_1) \\equiv 0 \\pmod p (x0​−x1​)(x0​+x1​)≡0(modp) 因为 x0≠x1x_0 \\not= x_1x0​=x1​，所以 x0−x1≠0x_0 - x_1 \\not= 0x0​−x1​=0，即要让上述式子为 000 则必然存在 x0+x1=0(modp)x_0 + x_1 = 0\\pmod px0​+x1​=0(modp) 也就是模 ppp 意义下的一对相反数对应一个二次剩余，因为 ppp 为奇质数所以任意一对 x0,x1x_0,x_1x0​,x1​ 若满足 x0+x1=0x_0 + x_1 = 0x0​+x1​=0，则必然满足 x0≠x1x_0 \\not= x_1x0​=x1​，也就是说任意一对相反数都可以对应一个二次剩余。 还可以知道的是任意两对相反数所对应的两个二次剩余均不同，所以二次剩余的数量就是 p−12\\frac{p-1}{2}2p−1​，故非二次剩余的数量就是 p−12\\frac{p-1}{2}2p−1​ 欧拉准则： 考虑怎么快速判断一个数 nnn 是不是二次剩余。 考虑费马小定理，np−1≡1(modp)n^{p-1} \\equiv 1 \\pmod pnp−1≡1(modp)，因为 ppp 为奇质数，所以有 n2⋅p−12≡1(modp)n^{2\\cdot \\frac{p-1}{2} } \\equiv 1 \\pmod pn2⋅2p−1​≡1(modp)，也就是说 np−12n^{\\frac{p-1}{2}}n2p−1​ 是 111 的开根，因为 111 的开根只有 111 或 −1-1−1，所以 np−12n^{\\frac{p-1}{2}}n2p−1​ 只可以为 111 或者 −1-1−1。 下面考虑证明 np−12≡1(modp)n^{\\frac{p-1}{2}} \\equiv 1 \\pmod pn2p−1​≡1(modp) 与 nnn 为二次剩余等价，也就是证明充分性和必要性。 充分性，也就是已知 np−12≡1(modp)n^{\\frac{p-1}{2}} \\equiv 1 \\pmod pn2p−1​≡1(modp)，设 ggg 表示模 ppp 意义下的原根，则可以令 n=gkn = g^kn=gk，则有 gk⋅p−12≡1(modp)g^{k\\cdot \\frac{p-1}{2}} \\equiv 1 \\pmod pgk⋅2p−1​≡1(modp)，有原根的性质可得 (p−1)∣k⋅p−12(p-1) \\mid k\\cdot \\frac{p-1}{2}(p−1)∣k⋅2p−1​，也就是说 kkk 一定是偶数，即我们可以将 kkk 除以 222，所以 nnn 就是可以开根的，开根后的结果就是 x=gk2x = g^{\\frac{k}{2}}x=g2k​ 必要性，也就是已知 nnn 是二次剩余，np−12=(x2)p−12=xp−1n^{\\frac{p-1}{2}} = (x^2)^{\\frac{p-1}{2}} = x^{p-1}n2p−1​=(x2)2p−1​=xp−1，因为 xφ(p)≡1(modp)x^{\\varphi(p)} \\equiv 1 \\pmod pxφ(p)≡1(modp)，所以 xp−1≡1(modp)x^{p-1} \\equiv 1 \\pmod pxp−1≡1(modp)，即 np−12≡1(modp)n^{\\frac{p-1}{2}} \\equiv 1 \\pmod pn2p−1​≡1(modp) 所以就证明了 np−12≡1(modp)n^{\\frac{p-1}{2}} \\equiv 1 \\pmod pn2p−1​≡1(modp) 与 nnn 为二次剩余等价，所以当 np−12≡−1(modp)n^{\\frac{p-1}{2}} \\equiv -1 \\pmod pn2p−1​≡−1(modp) 时 nnn 就是非二次剩余。 Cipolla： 考虑求解 x2≡n(modp)x^2 \\equiv n \\pmod px2≡n(modp) 首先找到一个 aaa 使得 a2−na^2 - na2−n 是非二次剩余，因为非二次剩余的数的个数接近 p2\\frac{p}{2}2p​ 所以期望两次找到。 定义 i2=a2−ni^2 = a^2 - ni2=a2−n，下面就是关于怎么找到这个 iii。 可以类似复数域，定义这样的一个 iii，使得每一个数都可以被表示为 A+BiA + BiA+Bi，其中 A,BA,BA,B 都是模 ppp 意义下的。 下面考虑证明下面这个结论： (a+i)p+1≡n(modp)(a+i)^{p+1} \\equiv n \\pmod p (a+i)p+1≡n(modp) 引理 111： ip≡−i(modp)i^p \\equiv -i \\pmod pip≡−i(modp) 证明：ip=i(i2)p−12=i(a2−n)p−12=−ii^p = i(i^2)^{\\frac{p-1}{2}} = i(a^2 - n)^{\\frac{p-1}{2}} = -iip=i(i2)2p−1​=i(a2−n)2p−1​=−i 引理 222： (A+B)p≡Ap+Bp(modp)(A+B)^p \\equiv A^p + B^p \\pmod p(A+B)p≡Ap+Bp(modp) 证明：(A+B)p≡∑i=0p(pi)AiBp−i≡(pp)Ap+(p0)Bp≡Ap+Bp(modp)(A+B)^p \\equiv \\sum_{i=0}^p \\binom{p}{i} A^iB^{p-i} \\equiv \\binom{p}{p} A^p + \\binom{p}{0}B^p \\equiv A^p + B^p \\pmod p(A+B)p≡∑i=0p​(ip​)AiBp−i≡(pp​)Ap+(0p​)Bp≡Ap+Bp(modp) 有了这两个引理就可以证明了： (a+i)p+1≡(ap+ip)(a+i)≡(a−i)(a+i)≡a2−i2≡n(modp)(a+i)^{p+1} \\equiv (a^p + i^p)(a+i) \\equiv (a-i)(a+i) \\equiv a^2 - i^2 \\equiv n \\pmod p (a+i)p+1≡(ap+ip)(a+i)≡(a−i)(a+i)≡a2−i2≡n(modp) 第二个等于号 ap≡a(modp)a^p \\equiv a \\pmod pap≡a(modp) 就是扩展欧拉定理。 因为 ppp 为奇质数，所以 p+1p+1p+1 为偶数，因此 nnn 开方后的数就是 (a+i)p+12(a+i)^{\\frac{p+1}{2}}(a+i)2p+1​，即 xxx 就是 (a+i)p+12(a+i)^{\\frac{p+1}{2}}(a+i)2p+1​ 可以证明 (a+i)p+12(a+i)^{\\frac{p+1}{2}}(a+i)2p+1​ 的 “虚部” 一定为 000。 使用反证法来证明这个结论，若存在 (A+Bi)2≡n(modp)(A+Bi)^2 \\equiv n \\pmod p(A+Bi)2≡n(modp) 且 B≠0B \\not= 0B=0，那么展开之后就是 A2+B2i2+2ABi≡n(modp)A^2 + B^2i^2 + 2ABi \\equiv n \\pmod pA2+B2i2+2ABi≡n(modp)，因为右边&quot;虚部&quot;为 000 所以显然左边&quot;虚部&quot;为 000，即 AB=0AB = 0AB=0，因为 B≠0B \\not= 0B=0，所以 A=0A = 0A=0，上面式子就可以化为 B2i2≡n(modp)B^2i^2 \\equiv n \\pmod pB2i2≡n(modp)，即 i2≡nB−2(modp)i^2 \\equiv nB^{-2} \\pmod pi2≡nB−2(modp)，显然 B−2B^{-2}B−2 是一个二次剩余，而 nnn 也是一个二次剩余，所以 nB−2nB^{-2}nB−2 就是一个二次剩余，即 i2i^2i2 是一个二次剩余，这与我们的假设 i2i^2i2 不是一个二次剩余违背，故此这个结论不成立。 正整数中的数论 算术基本定理 内容： 对于任意一个大于 111 的自然数 NNN，其一定可以被唯一分解为有限个质数的乘积。 标准分解式： N=∏i=1mpikiN = \\prod_{i=1}^m p_i^{k_i}N=∏i=1m​piki​​，满足 p1&lt;p2&lt;p3⋯&lt;pmp_1 &lt; p_2 &lt; p_3 \\cdots &lt; p_mp1​&lt;p2​&lt;p3​⋯&lt;pm​ 且 p1,p2,p3,⋯ ,pmp_1,p_2,p_3,\\cdots,p_mp1​,p2​,p3​,⋯,pm​ 均为质数，kik_iki​ 均为正整数，将这样的分解称为 NNN 的标准分解式。 p 进赋值序列： 记 vp(n)=max⁡{k∈n∣pk∣n}v_p(n) = \\max\\{k \\in \\mathbb{n}\\mid p^k \\mid n\\}vp​(n)=max{k∈n∣pk∣n}，则 nnn 的 ppp 进赋值序列为 {v2(n),v3(n),v5(n),v7(n),⋯ }\\{v_2(n),v_3(n),v_5(n),v_7(n),\\cdots\\}{v2​(n),v3​(n),v5​(n),v7​(n),⋯}，即要求 ppp 均为质数。 ppp 进赋值序列可以帮助我们在数论的角度下刻画正整数，在 ppp 进赋值序列下任何一个正整数都唯一对应一个高维平面上的点，该平面每一维对应一个素数。 gcd⁡\\gcdgcd 与 lcm\\text{lcm}lcm 就可以转化为高维平面上的 min⁡\\minmin 与 max⁡\\maxmax。 狄利克雷前缀和就对应高维前缀和，狄利克雷卷积就对应着高维和卷积。 莫比乌斯函数相当于高维差分的容斥系数。 素性检测和因数分解 素性检测就是在不对给定数进行质因数分解的情况下判断这个数是否为质数。 Miller–Rabin 素性测试 引理一：费马小定理 若 ppp 为素数，aaa 为整数，若 (a,p)=1(a,p) = 1(a,p)=1，则有 ap−1≡1(modp)a^{p-1} \\equiv 1 \\pmod pap−1≡1(modp) 费马小定理只是 ppp 为素数的充分条件，如不成立则 ppp 一定为合数，若成立则 ppp 不一定为素数。 引理二：二次检测定理 若 ppp 为素数，且 0&lt;x&lt;p0 &lt; x &lt; p0&lt;x&lt;p，则 x2≡1(modp)x^2 \\equiv 1 \\pmod px2≡1(modp) 的解为 x=1x=1x=1 或 x=p−1x=p-1x=p−1 证明： x2≡1(modp)⟹x2−1≡0(modp)⟹(x+1)(x−1)≡0(modp)⟹p∣(x+1)(x−1)x^2 \\equiv 1 \\pmod p \\Longrightarrow x^2 - 1 \\equiv 0 \\pmod p \\Longrightarrow (x+1)(x-1) \\equiv 0 \\pmod p \\Longrightarrow p \\mid (x+1)(x-1)x2≡1(modp)⟹x2−1≡0(modp)⟹(x+1)(x−1)≡0(modp)⟹p∣(x+1)(x−1)。 因为 ppp 为质数，所以只有 x=1x = 1x=1 或 x=p−1x = p-1x=p−1。 下面考虑给定 ppp 判断其是否为素数。 我们将 p−1p-1p−1 写成 2k×t2^k \\times t2k×t 的形式，可以考虑随机一个数 aaa，然后计算 at(modp)a^t \\pmod pat(modp) 的值。 将这个数不断自乘，然后使用二次检测定理判断，也就是若当前的数为 AAA 满足 A×A=1A \\times A = 1A×A=1 且 A≠1A \\not= 1A=1 且 A≠p−1A \\not= p-1A=p−1，则 ppp 不是素数。 这样乘 kkk 次的结果就是 ap−1a^{p-1}ap−1，这个时候只需要判断 ap−1≡1(modp)a^{p-1} \\equiv 1 \\pmod pap−1≡1(modp) 是否满足即可，如果不满足则一定不是素数。 这样检测的正确率是不低的，可以验证的是如果我们取前 121212 个素数作为 aaa 进行检测则在 [1,264)[1,2^{64})[1,264) 内的数都不会出现问题。 时间复杂度就是 O(∣a∣log3n)O(|a|log^3n)O(∣a∣log3n) 代码实现如下： 点击查看代码 12345678910111213141516bool Miller(int P) { if(P == 1) return 0; int t = P - 1, k = 0; while(!(t &amp; 1)) k++, t &gt;&gt;= 1; for(int i = 0; i &lt; 12; i++) { if(P == Test[i]) return 1; LL a = pow(Test[i], t, P), nxt = a; for(int j = 1; j &lt;= k; j++) { nxt = (a * a) % P; if(nxt == 1 &amp;&amp; a != 1 &amp;&amp; a != P - 1) return 0; a = nxt; } if(a != 1) return 0; } return 1;} Pollard-Rho 算法 首先要明确这个算法的功能就是在 O(n14)O(n^{\\frac{1}{4}})O(n41​) 的时间内找到数 nnn 的一个因子。 一个暴力的想法就是我们每次随机一个数，判断这个数是不是因子，如果是就返回如果不是就继续随机，但是这样的复杂度就炸了。 考虑构造如下的随机数序列： 定义 f(x)=(x2+c)(modN)f(x) = (x^2 + c) \\pmod Nf(x)=(x2+c)(modN)，那么我们构造的随机数序列就是 x,f(x),f(f(x)),⋯x,f(x),f(f(x)),\\cdotsx,f(x),f(f(x)),⋯。 这个序列的样子大概就是下面这个样子： 也就是一个 ρ\\rhoρ 的形状，而根据生日悖论期望随机 O(n14)O(n^{\\frac{1}{4}})O(n41​) 个数可以找到相同的数，所以这里期望环长为 O(n14)O(n^{\\frac{1}{4}})O(n41​)。 那么如果快速判环，可以使用类似龟兔赛跑的算法，也就是设置两个变量 t,rt,rt,r，每次判断是否有 gcd(∣t−r∣,n)≠1gcd(|t-r|,n) \\not= 1gcd(∣t−r∣,n)=1 且 gcd(∣t−r∣,n)≠ngcd(|t-r|,n) \\not= ngcd(∣t−r∣,n)=n，若有则 ∣t−r∣|t-r|∣t−r∣ 就是 nnn 的一个因数，如果没有我们就令 t=f(t),r=f(f(r))t = f(t),r=f(f(r))t=f(t),r=f(f(r))，可以发现这样的话 rrr 比 ttt 跑的快也就是它们在环上一定可以相遇。 这个时候就能体现出我们这个随机序列的优势了： 若 ∣i−j∣≡0(modp)|i-j| \\equiv 0 \\pmod p∣i−j∣≡0(modp)，则有 ∣fi−fj∣=(i2−j2)=(i−j)(i+j)≡0(modp)|f_i - f_j| = (i^2 - j^2) = (i-j)(i+j) \\equiv 0 \\pmod p∣fi​−fj​∣=(i2−j2)=(i−j)(i+j)≡0(modp)，所以我们只需要对两个点之间的距离 ddd 进行判断就好，不在于哪两个点而在于他们的距离，而我们上面的龟兔赛跑也显然是枚举到了每一种距离。 直接这样做就是 O(n14log⁡n)O(n^{\\frac{1}{4}}\\log n)O(n41​logn)。 优化就是减小求 gcdgcdgcd 的次数，可以考虑设一个固定的距离 CCC 然后每隔 CCC 个求一个公因数然后判断，这样的话期望的时间复杂度就是 O(n14)O(n^\\frac{1}{4})O(n41​)。 代码实现： 点击查看代码 1234567891011121314151617181920212223242526ll Pollard_Rho(ll N){ if (N == 4) return 2; if (is_prime(N)) return N; while (1) { ll c = randint(1, N - 1); auto f = [=](ll x) { return ((lll)x * x + c) % N; }; ll t = 0, r = 0, p = 1, q; do { for (int i = 0; i &lt; 128; ++i) // 令固定距离C=128 { t = f(t), r = f(f(r)); if (t == r || (q = (lll)p * abs(t - r) % N) == 0) // 如果发现环，或者积即将为0，退出 break; p = q; } ll d = gcd(p, N); if (d &gt; 1) return d; } while (t != r); }} 数论函数和筛法 此处可以查看如下几篇 blog，推荐按顺序观看： 【学习笔记】数论入门基础 【学习笔记】欧拉函数 【学习笔记】莫比乌斯反演 【学习笔记】数论之筛法 本文只在此基础上补充几个知识点。 区间筛 给定区间 [l,r][l,r][l,r] 要求区间 [l,r][l,r][l,r] 中的素数的数量。 考虑若 x≤rx \\le rx≤r 且 xxx 不为素数，则 xxx 必然拥有一个小于等于 r\\sqrt{r}r​ 的质因子，所以只需要用 [2,r][2,\\sqrt{r}][2,r​] 筛一遍区间 [l,r][l,r][l,r] 留下来的就是素数。 一些小 tip amod b=a−a×⌊ab⌋a \\mod b = a - a\\times \\lfloor \\frac{a}{b} \\rflooramodb=a−a×⌊ba​⌋ ⌊⌊ab⌋c⌋=⌊abc⌋\\lfloor {\\frac{\\lfloor\\frac{a}{b}\\rfloor}{c}} \\rfloor = \\lfloor {\\frac{a}{bc}} \\rfloor⌊c⌊ba​⌋​⌋=⌊bca​⌋ 整除分块中如果式子中多个数整除，复杂度是加而不是乘。 集合幂级数 FWT 与 FMT FWT 与 FMT 是解决如下问题的工具： ck=∑i⊕j=kaibjc_k = \\sum_{i\\oplus j = k}a_ib_j ck​=i⊕j=k∑​ai​bj​ 其中 ⊕\\oplus⊕ 为二进制下的 and or xor 三种运算之一。 下面将 FWT 与 FMT 统称为 FWT。 其解决这个问题的思路也类似 FFT，就是将序列 a,ba,ba,b 转化为某种变换 FWT(a),FWT(b)\\text{FWT}(a),\\text{FWT}(b)FWT(a),FWT(b) 然后乘起来得到 FWT(c)\\text{FWT}(c)FWT(c) 后反演得到 ccc。 OR 要求： ck=∑i∣j=kaibjc_k = \\sum_{i | j = k} a_ib_j ck​=i∣j=k∑​ai​bj​ 考虑若 i∣k=ki \\mid k = ki∣k=k 且 j∣k=kj \\mid k = kj∣k=k 则 (i∣j)∣k=k(i\\mid j) \\mid k = k(i∣j)∣k=k，就使用这个来设计变换。 即 FWTor(A)k=∑i∣k=kAi\\text{FWT}_{or}(A)_k = \\sum_{i\\mid k = k} A_iFWTor​(A)k​=∑i∣k=k​Ai​ 也就是 iii 为 kkk 的子集才可以转移。 那考虑为什么这样是对的： FWTor(A)=∑k(∑i∣k=kAi)×(∑j∣k=kBj)=∑k∑i∣k=k∑j∣k=kAiBj=∑k∑(i∣j)∣k=kAiBj\\begin{aligned} \\text{FWT}_{or}(A) &amp;= \\sum_{k} (\\sum_{i \\mid k = k}A_i) \\times (\\sum_{j \\mid k = k} B_j) \\\\ &amp;= \\sum_{k} \\sum_{i \\mid k = k}\\sum_{j \\mid k = k} A_iB_j \\\\ &amp;= \\sum_{k} \\sum_{(i \\mid j) \\mid k = k} A_iB_j \\end{aligned} FWTor​(A)​=k∑​(i∣k=k∑​Ai​)×(j∣k=k∑​Bj​)=k∑​i∣k=k∑​j∣k=k∑​Ai​Bj​=k∑​(i∣j)∣k=k∑​Ai​Bj​​ 所以这个变换就是正确的。 那么考虑如何快速进行这个变换，类似 FFT 每次合并两个长度为 2n2^n2n 的段，设不同的最高位为 111 的序列为 A1A_1A1​，为 000 的序列为 A0A_0A0​，则根据 ororor 的性质 A0A_0A0​ 可以转移到 A1A_1A1​，而 A1A_1A1​ 不能转移到 A0A_0A0​，也就是形如下面这样： FWTor(A)=(FWTor(A0),FWTor(A0)+FWTor(A1))\\text{FWT}_{or}(A) = (\\text{FWT}_{or}(A_0),\\text{FWT}_{or}(A_0) + \\text{FWT}_{or}(A_1)) FWTor​(A)=(FWTor​(A0​),FWTor​(A0​)+FWTor​(A1​)) 其中 A+BA + BA+B 是对应系数相加，(A,B)(A,B)(A,B) 就是按顺序写下 A,BA,BA,B。 逆变换就是逆着做这个操作就好了，即： IFWTor(A)=(IFWTor(A0),IFWTor(A1)−IFWTor(A0))\\text{IFWT}_{or}(A) = (\\text{IFWT}_{or}(A_0),\\text{IFWT}_{or}(A_1) - \\text{IFWT}_{or}(A_0)) IFWTor​(A)=(IFWTor​(A0​),IFWTor​(A1​)−IFWTor​(A0​)) 代码： 点击查看代码 123456789101112void Or(ll *x,int n,int op){ for(int l=1;l&lt;n;l&lt;&lt;=1){ for(int st=0;st&lt;n;st+=l*2){ for(int i=0;i&lt;l;i++){ ll u=x[st+i],v=x[st+l+i]; if(op==1) x[st+i]=u,x[st+l+i]=(v+u)%mod; else x[st+i]=u,x[st+l+i]=(v+mod-u)%mod; } } }} AND 要求： ck=∑i&amp;j=kaibjc_k = \\sum_{i \\&amp; j = k} a_ib_j ck​=i&amp;j=k∑​ai​bj​ 考虑若 i&amp;k=ki \\&amp; k = ki&amp;k=k 且 j&amp;k=kj \\&amp; k = kj&amp;k=k 则 (i&amp;j)&amp;k=k(i\\&amp;j) \\&amp; k = k(i&amp;j)&amp;k=k，所以可以构造如下的变换：FWTand(A)k=∑i&amp;k=kAi\\text{FWT}_{and}(A)_k = \\sum_{i\\&amp;k=k} A_iFWTand​(A)k​=∑i&amp;k=k​Ai​ 也就是 iii 为 kkk 的超集时产生贡献。 变化的与上文同理： FWTand(A)=(FWTand(A0)+FWTand(A1),FWTand(A1))IFWTand(A)=(IFWTand(A0)−IFWTand(A1),IFWTand(A1))\\text{FWT}_{and}(A) = (\\text{FWT}_{and}(A_0)+\\text{FWT}_{and}(A_1),\\text{FWT}_{and}(A_1)) \\\\ \\text{IFWT}_{and}(A) = (\\text{IFWT}_{and}(A_0)-\\text{IFWT}_{and}(A_1),\\text{IFWT}_{and}(A_1)) FWTand​(A)=(FWTand​(A0​)+FWTand​(A1​),FWTand​(A1​))IFWTand​(A)=(IFWTand​(A0​)−IFWTand​(A1​),IFWTand​(A1​)) 代码： 点击查看代码 123456789101112void And(ll *x,int n,int op){ for(int l=1;l&lt;n;l&lt;&lt;=1){ for(int st=0;st&lt;n;st+=l*2){ for(int i=0;i&lt;l;i++){ ll u=x[st+i],v=x[st+l+i]; if(op==1) x[st+i]=(u+v)%mod,x[st+l+i]=v; else x[st+i]=(u+mod-v)%mod,x[st+l+i]=v; } } }} XOR 要求： ck=∑i⊕j=kaibjc_k = \\sum_{i \\oplus j = k} a_ib_j ck​=i⊕j=k∑​ai​bj​ 设 d(x)d(x)d(x) 表示二进制下 xxx 的 111 的个数的奇偶性，则有如下性质：d(i&amp;k)⊕d(j&amp;k)=d((i⊕j)&amp;k)d(i\\&amp;k)\\oplus d(j\\&amp;k) = d((i\\oplus j) \\&amp; k)d(i&amp;k)⊕d(j&amp;k)=d((i⊕j)&amp;k)。 证明：因为我们是与操作，所以可以只考虑 kkk 为 111 的位。若某一位上 i,ji,ji,j 同时为 000 或 111 则显然不会有什么影响，若某一位上 i,ji,ji,j 分别为 0,10,10,1 那么左右两边都是同步变化的，所有也是一样的。 所以可以设计出以下的变换： FWTxor(A)k=∑i(−1)d(i&amp;k)Ai\\text{FWT}_{xor}(A)_k = \\sum_{i} (-1)^{d(i\\&amp;k)} A_i FWTxor​(A)k​=i∑​(−1)d(i&amp;k)Ai​ 可以乘一下看看是不是对的： FWTxor(C)=∑k(∑i(−1)d(i&amp;k)Ai)(∑j(−1)d(j&amp;k)Bj)=∑k∑i∑j(−1)d(i&amp;k)+d(j&amp;k)AiBj=∑k∑i,j(−1)d(i&amp;k)⊕d(j&amp;k)AiBj=∑k∑i,j(−1)d((i⊕j)&amp;k)AiBj\\begin{aligned} \\text{FWT}_{xor}(C) &amp;= \\sum_{k} (\\sum_{i} (-1)^{d(i\\&amp;k)} A_i) (\\sum_{j} (-1)^{d(j\\&amp;k)} B_j) \\\\ &amp;= \\sum_{k} \\sum_{i} \\sum_{j} (-1)^{d(i\\&amp;k) + d(j\\&amp;k)} A_iB_j \\\\ &amp;= \\sum_{k} \\sum_{i,j} (-1)^{d(i\\&amp;k)\\oplus d(j\\&amp;k)} A_iB_j \\\\ &amp;= \\sum_{k} \\sum_{i,j} (-1)^{d((i\\oplus j)\\&amp;k)} A_iB_j \\end{aligned} FWTxor​(C)​=k∑​(i∑​(−1)d(i&amp;k)Ai​)(j∑​(−1)d(j&amp;k)Bj​)=k∑​i∑​j∑​(−1)d(i&amp;k)+d(j&amp;k)Ai​Bj​=k∑​i,j∑​(−1)d(i&amp;k)⊕d(j&amp;k)Ai​Bj​=k∑​i,j∑​(−1)d((i⊕j)&amp;k)Ai​Bj​​ 这样就形式化对了，所以这个就是正确的。 考虑怎么快速求解，其实就是新加一位，而新加一位只有 111 贡献到 111 会导致奇偶性改变，也就是取负，其它的都没有变化。 即： FWTxor(A)=(FWTxor(A0)+FWTxor(A1),FWTxor(A0)−FWTxor(A1))\\text{FWT}_{xor}(A) = (\\text{FWT}_{xor}(A_0) + \\text{FWT}_{xor}(A_1),\\text{FWT}_{xor}(A_0) - \\text{FWT}_{xor}(A_1)) FWTxor​(A)=(FWTxor​(A0​)+FWTxor​(A1​),FWTxor​(A0​)−FWTxor​(A1​)) 逆变换其实就是考虑 A0,A1A_0,A_1A0​,A1​ 已经变成上面那个东西了，怎么还原回来的，就是： IFWTxor(A)=(IFWTxor(A0)+IFWTxor(A1)2,IFWTxor(A0)−IFWTxor(A1)2)\\text{IFWT}_{xor}(A) = (\\frac{\\text{IFWT}_{xor}(A_0) + \\text{IFWT}_{xor}(A_1)}{2},\\frac{\\text{IFWT}_{xor}(A_0) - \\text{IFWT}_{xor}(A_1)}{2}) IFWTxor​(A)=(2IFWTxor​(A0​)+IFWTxor​(A1​)​,2IFWTxor​(A0​)−IFWTxor​(A1​)​) 代码： 点击查看代码 1234567891011void Xor(ll *x,int n,int op){ for(int l=1;l&lt;n;l&lt;&lt;=1){ for(int st=0;st&lt;n;st+=l*2){ for(int i=0;i&lt;l;i++){ ll u=x[st+i],v=x[st+l+i]; if(op==1) x[st+i]=(u+v)%mod,x[st+l+i]=(u+mod-v)%mod; else x[st+i]=(u+v)%mod*inv2%mod,x[st+l+i]=(u+mod-v)%mod*inv2%mod; } } }} FWT 的一些性质 FWT 的本质是一个线性变换，也就是： FWT(A+B)=FWT(A)+FWT(B)\\text{FWT}(A+B) = \\text{FWT}(A) + \\text{FWT}(B)FWT(A+B)=FWT(A)+FWT(B)，FWT(cA)=cFWT(A)\\text{FWT}(cA) = c\\text{FWT}(A)FWT(cA)=cFWT(A) 集合幂级数 位运算是 OI 中的常考知识点，因为位运算中每一位的独立性，所以可以将其看作两个 {0,1}n\\{0,1\\}^n{0,1}n 上的向量的运算。 生成函数是刻画序列的有力工具，而集合幂级数就是处理集合（位运算）的一种特殊形式。对于序列 a0,a1,⋯ ,a2n−1a_0,a_1,\\cdots,a_{2^n-1}a0​,a1​,⋯,a2n−1​ 我们可以定义其集合幂级数 A(x)=∑i=02n−1aixiA(x) = \\sum \\limits_{i=0}^{2^n-1}a_ix^iA(x)=i=0∑2n−1​ai​xi。 定义集合幂级数的乘法操作，也就是子集卷积为如下的形式； ci=∑j∣k=ij&amp;k=0ajbk\\begin{aligned} c_i = \\sum_{j \\mid k = i \\quad j \\&amp; k = 0} a_jb_k \\end{aligned} ci​=j∣k=ij&amp;k=0∑​aj​bk​​ 组合意义就是选择两个不交的集合，可以直接枚举子集就可以做到 O(3n)O(3^n)O(3n)。 可以构造占位函数 w(x)=popcount(x)w(x) = \\text{popcount}(x)w(x)=popcount(x)，这样上述条件可以等价为 j xor k=ij \\ \\text{xor} \\ k = ij xor k=i 且 w(j)+w(k)=w(i)w(j) + w(k) = w(i)w(j)+w(k)=w(i)，这样就可以以 w(x)w(x)w(x) 来构造一个二元集合幂级数 A(x,y)=∑i=02n−1aixiyw(i)A(x,y) = \\sum \\limits_{i=0}^{2^n-1} a_ix^iy^{w(i)}A(x,y)=i=0∑2n−1​ai​xiyw(i)，而子集卷积就相当于对于第一维异或卷积，第二维和卷积，都是可以做的，所以就可以一维维来做，时间复杂度 O(n22n)O(n^22^n)O(n22n)。 因为不出意外的话我们第二维都为 O(log⁡n)O(\\log n)O(logn) 级别，所以直接暴力做和卷积就没问题，不用再写 FFT 了。 代码： 点击查看代码 1234567891011121314int main(){ m=read();n=(1&lt;&lt;m); for (int i=1;i&lt;n;i++)c[i]=c[i&gt;&gt;1]+(i&amp;1); for (int i=0;i&lt;n;i++)F[i].a[c[i]]=read(); for (int i=0;i&lt;n;i++)G[i].a[c[i]]=read(); FWT(F,n);FWT(G,n); for (int i=0;i&lt;n;i++) F[i]=F[i]*G[i]; IFWT(F,n); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,(F[i].a[c[i]]+mod)%mod); return 0;} 这个技巧就被称为占位多项式，有了这个占位多项式我们就可以对集合幂级数做各种多项式的操作，但是那东西我完全不会，就不说了。 组合计数 计数原理 加法原理： 若完成某道工序有两种方法，第一种方法的实现方式有 aaa 种，第二种方法的实现方式有 bbb 种，则完成这道工序的实现方法有 a+ba+ba+b 种。 乘法原理： 若完成某道工序有两个步骤，第一个步骤有 aaa 种实现方式，第二个步骤有 bbb 种实现方式，则完成这道工序的实现方法有 ababab 种。 其实只需要观察它们是不是相互独立的就可以判断出应使用加法原理还是乘法原理。 算两次原理（富比尼原理）： 将同一个量同两个不同角度计算两次，从而建立等量关系。 这东西看上去很玄乎，但是其实放在 OI 中就是：维度的变换（枚举下标/权值）、贡献的计算（直接计算/增量计算）等，从不同的角度解决问题，并在选取了合适的角度之后通过其它的方法解决问题。 例题 P8557 炼金术： 有 kkk 个熔炉，每个熔炉可以随机炼出 nnn 种金属中的一些，当 nnn 种金属都被炼制出来过该方案就是合法的，询问有多少种合法的方案。 考虑按每一种金属考虑，其在每一个熔炉中都可以出现或者不出现，所以方案数为 222，而其在 kkk 个熔炉中出现的情况相互独立，所以方案数为 2k2^k2k，但是这个金属必须要在某一个熔炉中出现，所以真实的方案数为 2k−12^k-12k−1。 对于不同的金属之间相互独立，所以总方案数为 (2k−1)n(2^k-1)^n(2k−1)n。 鸽巢原理： nnn 个小球放到 mmm 个抽屉中，至少有一个抽屉放了大于等于 ⌈nm⌉\\lceil \\frac{n}{m} \\rceil⌈mn​⌉ 个。 这个原理常用于结论的证明，以及一些极端情况的求解等。 组合数 组合数的计算 递推形式：(nm)=(n−1m)+(n−1m−1)\\binom{n}{m} = \\binom{n-1}{m} + \\binom{n-1}{m-1}(mn​)=(mn−1​)+(m−1n−1​)。 阶乘形式：(nm)=n!m!(n−m)!=nm‾m!\\binom{n}{m} = \\frac{n!}{m!(n-m)!} = \\frac{n^{\\underline{m}}}{m!}(mn​)=m!(n−m)!n!​=m!nm​​ Lucas 定理：(nm)=(nmod pmmod p)×(⌊np⌋⌊mp⌋)\\binom{n}{m} = \\binom{n \\mod p}{m \\mod p} \\times \\binom{\\lfloor \\frac{n}{p} \\rfloor}{\\lfloor \\frac{m}{p} \\rfloor}(mn​)=(mmodpnmodp​)×(⌊pm​⌋⌊pn​⌋​) 组合恒等式： 吸收恒等式： (nm)=nm(n−1m−1)\\binom{n}{m} = \\frac{n}{m} \\binom{n-1}{m-1}(mn​)=mn​(m−1n−1​)，移项得 m(nm)=n(n−1m−1)m\\binom{n}{m} = n\\binom{n-1}{m-1}m(mn​)=n(m−1n−1​) 证明：根据组合数的阶乘形式易得 行求和：∑i=0n(ni)=2n\\sum_{i=0}^n \\binom{n}{i} = 2^n∑i=0n​(in​)=2n 证明：根据二项式定理 (1+1)n=∑i=0n(ni)=2n(1+1)^n = \\sum_{i=0}^n \\binom{n}{i} = 2^n(1+1)n=∑i=0n​(in​)=2n 列求和：∑i=nm(in)=(m+1n+1)\\sum_{i=n}^m \\binom{i}{n} = \\binom{m+1}{n+1}∑i=nm​(ni​)=(n+1m+1​) 证明：(nn)+(n+1n)+(n+2n)+⋯+(mn)=(n+1n+1)+(n+1n)+(n+2n)+⋯+(mn)=(n+2n+1)+(n+2n)+⋯+(mn)=(mn+1)+(mn)=(m+1n+1)\\binom{n}{n} + \\binom{n+1}{n} + \\binom{n+2}{n} + \\cdots + \\binom{m}{n} = \\binom{n+1}{n+1} + \\binom{n+1}{n} + \\binom{n+2}{n} + \\cdots + \\binom{m}{n} = \\binom{n+2}{n+1} + \\binom{n+2}{n} + \\cdots + \\binom{m}{n} = \\binom{m}{n+1} + \\binom{m}{n} = \\binom{m+1}{n+1}(nn​)+(nn+1​)+(nn+2​)+⋯+(nm​)=(n+1n+1​)+(nn+1​)+(nn+2​)+⋯+(nm​)=(n+1n+2​)+(nn+2​)+⋯+(nm​)=(n+1m​)+(nm​)=(n+1m+1​)，主要是使用了组合数的递推形式。 范德蒙德卷积：∑i=0k(ni)×(mk−i)=(n+mk)\\sum_{i=0}^k \\binom{n}{i}\\times\\binom{m}{k-i} = \\binom{n+m}{k}∑i=0k​(in​)×(k−im​)=(kn+m​) 证明：考虑我们枚举的其实就是 nnn 个里面选 iii 个和 mmm 个里面选 k−ik-ik−i 个，显然可以合并起来。 组合数的应用： 隔板法：nnn 个相同的小球放到 mmm 个不同的盒子里，每个盒子里必须至少放一个小球，方案数为 (n−1m−1)\\binom{n-1}{m-1}(m−1n−1​)。 证明：考虑将 nnn 个小球放到一排，这样中间就出现了 n−1n-1n−1 个缝隙，放到 kkk 个不同的盒子中相当于划分为 kkk 段也就是选择 k−1k-1k−1 个缝隙放上隔板，方案数就是 (n−1m−1)\\binom{n-1}{m-1}(m−1n−1​)。 扩展： 如果将要求改为每个盒子可以不放小球，那么方案数就是 (n+m−1m−1)\\binom{n+m-1}{m-1}(m−1n+m−1​)，可以理解为先将所有的盒子提前放上一个小球，这样就必须至少放 111 个了。 捆绑法：有 nnn 个不同的人站队，要求其中两个人必须相邻，方案数为 (n−1)!×2!(n-1)! \\times 2!(n−1)!×2!。 证明：将这两个人视为一个人去站队方案数为 (n−1)!(n-1)!(n−1)!，而两个人内部也可以随便站方案数为 2!2!2!。 格路计数：给定一个 n×mn \\times mn×m 的网格，每次可以从 (x,y)(x,y)(x,y) 走到 (x+1,y)(x+1,y)(x+1,y) 或者 (x,y+1)(x,y+1)(x,y+1)，从 (1,1)(1,1)(1,1) 走到 (n,m)(n,m)(n,m) 的方案数为 (n+mn)\\binom{n+m}{n}(nn+m​)。 证明：我们总共要走 n+mn+mn+m 步才能走到 (n,m)(n,m)(n,m) 这其中有 nnn 步是执行 (x,y)→(x+1,y)(x,y) \\to (x+1,y)(x,y)→(x+1,y)，而且这 nnn 步可以在任意位置。 卡特兰数：见数论之生成函数基础。 prufer 序列 对于一棵有 nnn 个节点的带标号树，其 prufer 序列一定是一个长度为 n−2n-2n−2 值域为 [1,n][1,n][1,n] 的序列。 树转化为 prufer 序列： 选择树上编号最小的叶子节点，将其父亲插入到序列的末尾 删除这个选择的叶子节点 重复上述步骤直到树中只剩下两个节点 注意到我们的 prufer 序列与树构成一个双射，所以我们可以由 prufer 序列还原对应的树。 选择编号最小的一个叶子节点（即从未在序列中出现的点），其父亲就是序列第 iii 个数。（iii 初始为 111） 点 xxx 的度数为 xxx 的出现次数加 111，所以可以删除这个叶子节点，然后将其父亲的度数减 111，直到其父亲度数变为 111 就成为了叶子节点。 重复上述两步，直到序列全部被用完。 可以发现这样构造出的 prufer 序列有如下的性质： 剩下的两个节点中，一定有一个为 nnn 号节点 对于一个 nnn 度点，其会在 prufer 序列中出现 n−1n-1n−1 次 应用： 无向完全图生成树计数：若该完全图点数为 nnn，则任意一个长度为 n−2n-2n−2 的值域为 [1,n][1,n][1,n] 的序列都可以还原出一棵生成树，所以方案数即 nn−2n^{n-2}nn−2，与 Cayley 定理的结论一致。 Cayley 定理：假设图中有 mmm 个连通块，连通块内的点数为 a1,a2,⋯ ,ama_1,a_2,\\cdots,a_ma1​,a2​,⋯,am​，且满足 a1+a2+⋯+am=na_1 + a_2 + \\cdots + a_m = na1​+a2​+⋯+am​=n，则选择 m−1m-1m−1 条边将图联通的方案数为 nm−2∏i=1main^{m-2}\\prod_{i=1}^m a_inm−2∏i=1m​ai​ 广义 Cayley 定理：nnn 个有标号的点形成的包含 kkk 棵树的森林，要求给定的 kkk 个点没有两个点属于同一棵树的方案数为 k×nn−k−1k \\times n^{n-k-1}k×nn−k−1。 nnn 个点的有根树计数：因为每个点都可以作为根，所以答案为 n×nn−2=nn−1n \\times n^{n-2} = n^{n-1}n×nn−2=nn−1 容斥原理 最基本的式子就是交集与并集的转化： 设 SSS 为有限集，Ai⊆S（i∈[1,n]）A_i \\subseteq S（i \\in [1,n]）Ai​⊆S（i∈[1,n]），则有： ∣⋃i=1nAi∣=∑T⊆[1,n](−1)∣T∣−1∣⋂j∈TAj∣=∑k=1n(−1)k−1∑b1&lt;b2&lt;b3&lt;⋯&lt;bk∣⋂j=1kAbj∣\\left| \\bigcup\\limits_{i=1}^n A_i \\right| = \\sum_{T \\subseteq [1,n]} (-1)^{|T|-1} \\left| \\bigcap\\limits_{j \\in T} A_j \\right| = \\sum_{k=1}^{n} (-1)^{k-1} \\sum_{b_1 &lt; b_2 &lt; b_3 &lt; \\cdots &lt; b_k} \\left| \\bigcap\\limits_{j=1}^k A_{b_j} \\right| ∣∣∣∣∣∣​i=1⋃n​Ai​∣∣∣∣∣∣​=T⊆[1,n]∑​(−1)∣T∣−1∣∣∣∣∣∣∣​j∈T⋂​Aj​∣∣∣∣∣∣∣​=k=1∑n​(−1)k−1b1​&lt;b2​&lt;b3​&lt;⋯&lt;bk​∑​∣∣∣∣∣∣​j=1⋂k​Abj​​∣∣∣∣∣∣​ 证明：考虑元素 xxx 属于 mmm 个 AAA，则其产生的贡献就是这个式子 ∑i=1m(−1)i−1(mi)=−(∑i=1m(−1)i(mi))=−(−1+∑i=0m(−1)i(mi))=−(−1+(1−1)m)=1\\sum_{i=1}^m (-1)^{i-1} \\binom{m}{i} = -(\\sum_{i=1}^m (-1)^i \\binom{m}{i}) = -(-1 + \\sum_{i=0}^m (-1)^i \\binom{m}{i}) = -(-1 + (1-1)^m) = 1∑i=1m​(−1)i−1(im​)=−(∑i=1m​(−1)i(im​))=−(−1+∑i=0m​(−1)i(im​))=−(−1+(1−1)m)=1 直观理解这个式子就是将满足 A1A_1A1​ 或满足 A2A_2A2​ 或 ⋯\\cdots⋯ 的元素个数转化为了强制同时满足某些条件的元素个数。 当然有的时候也要有一些直观的理解，比如 [a,b][a,b][a,b] 中满足 AAA 的数的个数可以转化为 [1,b][1,b][1,b] 中满足的个数减去 [1,a−1][1,a-1][1,a−1] 中满足的个数；满足 AAA 的个数可以转化为无所谓的个数减去不满足 AAA 的个数等。 在容斥以及反演过程中常使用二项式定理证明结论。 反演 反演其实就是容斥原理的代数形式，下面就简单介绍几种反演。 通过这些反演推导的练习，相信你一定会学会如何推导容斥系数。 二项式反演 形式一： F(n)=∑i=0n(−1)i(ni)G(i) ⟺ G(n)=∑i=0n(−1)i(ni)F(i)F(n) = \\sum_{i=0}^n (-1)^i \\binom{n}{i} G(i) \\iff G(n) = \\sum_{i=0}^n (-1)^i \\binom{n}{i} F(i) F(n)=i=0∑n​(−1)i(in​)G(i)⟺G(n)=i=0∑n​(−1)i(in​)F(i) 证明： 这里只证明充分性，必要性显然成立。 也就是得到在计算 G(n)G(n)G(n) 的时候 G(i)G(i)G(i) 的系数是多少，要证明的就是后面这个式子 G(n)G(n)G(n) 的系数为 111，其余的系数为 000。 下面就是考虑计算 G(i)G(i)G(i) 的系数，一个想法就是枚举所有的 F(j)F(j)F(j) 然后将 F(j)F(j)F(j) 中 G(i)G(i)G(i) 的系数求和。 ans=∑j=in(−1)j(nj)(−1)i(ji)=(−1)i∑j=in(−1)jn!j!j!(n−j)!i!(j−i)!=(−1)i∑j=in(−1)jn!i!(n−i!)×(n−i)!(n−j)!(j−i)!=(−1)i(ni)∑j=in(−1)j(n−in−j)=(−1)i(ni)∑j=0n−i(−1)j+1(n−jn−j−i)=(−1)2i(ni)∑j=0n−i(−1)j(n−ij)=(−1)2i(ni)(1−1)n−i=[n=i]\\begin{aligned} ans &amp;= \\sum_{j=i}^n (-1)^j \\binom{n}{j} (-1)^i \\binom{j}{i} \\\\ &amp;= (-1)^i \\sum_{j=i}^n (-1)^j \\frac{n!j!}{j!(n-j)!i!(j-i)!} \\\\ &amp;= (-1)^i \\sum_{j=i}^n (-1)^j \\frac{n!}{i!(n-i!)} \\times \\frac{(n-i)!}{(n-j)!(j-i)!} \\\\ &amp;= (-1)^i \\binom{n}{i} \\sum_{j=i}^n (-1)^j \\binom{n-i}{n-j} \\\\ &amp;= (-1)^i \\binom{n}{i} \\sum_{j=0}^{n-i} (-1)^{j+1} \\binom{n-j}{n-j-i} \\\\ &amp;= (-1)^{2i} \\binom{n}{i} \\sum_{j=0}^{n-i} (-1)^j \\binom{n-i}{j} \\\\ &amp;= (-1)^{2i} \\binom{n}{i} (1-1)^{n-i} \\\\ &amp;= [n = i] \\end{aligned} ans​=j=i∑n​(−1)j(jn​)(−1)i(ij​)=(−1)ij=i∑n​(−1)jj!(n−j)!i!(j−i)!n!j!​=(−1)ij=i∑n​(−1)ji!(n−i!)n!​×(n−j)!(j−i)!(n−i)!​=(−1)i(in​)j=i∑n​(−1)j(n−jn−i​)=(−1)i(in​)j=0∑n−i​(−1)j+1(n−j−in−j​)=(−1)2i(in​)j=0∑n−i​(−1)j(jn−i​)=(−1)2i(in​)(1−1)n−i=[n=i]​ 所以系数就正确了，得证。 形式二： F(n)=∑i=0n(ni)G(i) ⟺ G(n)=∑i=0n(−1)n−i(ni)F(i)F(n) = \\sum_{i=0}^n \\binom{n}{i} G(i) \\iff G(n) = \\sum_{i=0}^n (-1)^{n-i} \\binom{n}{i}F(i) F(n)=i=0∑n​(in​)G(i)⟺G(n)=i=0∑n​(−1)n−i(in​)F(i) 证明： 考虑使用 EGF 证明； F(n)=∑i=0nn!(n−i)!i!G(i)F(n)n!=∑i=0n1(n−i)!G(i)i!F(n) = \\sum_{i=0}^n \\frac{n!}{(n-i)!i!}G(i) \\\\ \\frac{F(n)}{n!} = \\sum_{i=0}^n \\frac{1}{(n-i)!} \\frac{G(i)}{i!} F(n)=i=0∑n​(n−i)!i!n!​G(i)n!F(n)​=i=0∑n​(n−i)!1​i!G(i)​ 这个式子显然就是一个卷积的形式也就是： F=G∗ex ⟺ G=F∗e−xF = G * e^x \\iff G = F * e^{-x} F=G∗ex⟺G=F∗e−x 所以： G(n)n!=∑i=0n(−1)n−i(n−i)!F(i)i!\\frac{G(n)}{n!} = \\sum_{i=0}^n \\frac{(-1)^{n-i}}{(n-i)!} \\frac{F(i)}{i!} n!G(n)​=i=0∑n​(n−i)!(−1)n−i​i!F(i)​ 移项之后就是： G(n)=∑i=0n(−1)n−i(ni)F(i)G(n) = \\sum_{i=0}^n (-1)^{n-i} \\binom{n}{i} F(i) G(n)=i=0∑n​(−1)n−i(in​)F(i) 得证。 形式三： F(n)=∑i=n(in)G(i) ⟺ G(n)=∑i=n(−1)i−n(in)F(i)F(n) = \\sum_{i=n} \\binom{i}{n} G(i) \\iff G(n) = \\sum_{i=n} (-1)^{i-n} \\binom{i}{n} F(i) F(n)=i=n∑​(ni​)G(i)⟺G(n)=i=n∑​(−1)i−n(ni​)F(i) 形式四： F(n)=∑i=n(−1)i(in)G(i) ⟺ G(n)=∑i=n(−1)i(in)F(i)F(n) = \\sum_{i=n} (-1)^i \\binom{i}{n} G(i) \\iff G(n) = \\sum_{i=n} (-1)^i \\binom{i}{n} F(i) F(n)=i=n∑​(−1)i(ni​)G(i)⟺G(n)=i=n∑​(−1)i(ni​)F(i) 这两种形式都可以通过慢慢推的方式证明，因为形式一已经类似证明过了就不证明了。 莫比乌斯反演 请查看： 【学习笔记】数论入门基础 【学习笔记】莫比乌斯反演 Min-Max 容斥 定义全集 U={a1,a2,a3,⋯ ,an}U = \\{a_1,a_2,a_3,\\cdots,a_n\\}U={a1​,a2​,a3​,⋯,an​}，有一个集合 SSS，则 max⁡(S)=max⁡ai∈Sai\\max(S) = \\max \\limits_{a_i \\in S} a_imax(S)=ai​∈Smax​ai​，min⁡(S)=min⁡ai∈Sai\\min(S) = \\min \\limits_{a_i\\in S} a_imin(S)=ai​∈Smin​ai​。 则有如下结论： max⁡(S)=∑T⊆S(−1)∣T∣+1min⁡(T)min⁡(S)=∑T⊆S(−1)∣T∣+1max⁡(T)\\max(S) = \\sum_{T \\subseteq S} (-1)^{|T|+1} \\min(T) \\\\ \\min(S) = \\sum_{T \\subseteq S} (-1)^{|T|+1} \\max(T) max(S)=T⊆S∑​(−1)∣T∣+1min(T)min(S)=T⊆S∑​(−1)∣T∣+1max(T) 下面考虑证明第一个式子。 一样的套路，假设元素 xxx 为第 kkk 大，钦定 xxx 为集合中的最小值，那么它在后面的式子里对答案贡献的系数是什么，可以枚举大于 xxx 的数选择多少个。 =∑i=0k−1(k−1i)(−1)i+2=∑i=0k−1(k−1i)(−1)i=(1−1)k−1=[k=1]\\begin{aligned} &amp;= \\sum_{i=0}^{k-1} \\binom{k-1}{i} (-1)^{i+2} \\\\ &amp;= \\sum_{i=0}^{k-1} \\binom{k-1}{i} (-1)^i \\\\ &amp;= (1-1)^{k-1} \\\\ &amp;= [k=1] \\end{aligned} ​=i=0∑k−1​(ik−1​)(−1)i+2=i=0∑k−1​(ik−1​)(−1)i=(1−1)k−1=[k=1]​ 所以只有最大值会产生 111 的贡献，其他都会产生 000 的贡献，得证。 要注意的一点就是 Min-Max 容斥在期望意义下依然成立，即： E(max⁡(S))=∑T⊆S(−1)∣T∣+1min⁡(T)E(\\max(S)) = \\sum_{T \\subseteq S} (-1)^{|T|+1} \\min(T) E(max(S))=T⊆S∑​(−1)∣T∣+1min(T) 如果我们要求第 kkk 大也是可以容斥出来的： Kthmax⁡(S)=∑T⊆S(−1)∣T∣−k(∣T∣−1k−1)min⁡(T)K_{th}\\max(S) = \\sum_{T \\subseteq S} (-1)^{|T| - k} \\binom{|T|-1}{k-1} \\min(T) Kth​max(S)=T⊆S∑​(−1)∣T∣−k(k−1∣T∣−1​)min(T) 这个容斥系数我们是可以很简单推导出来的。 考虑设： Kthmax⁡(S)=∑T⊆SF(∣T∣)min⁡(T)K_{th}\\max(S) = \\sum_{T \\subseteq S} F(|T|) \\min(T) Kth​max(S)=T⊆S∑​F(∣T∣)min(T) 考虑若 xxx 为第 ppp 大，则由上文可知其贡献即： ∑i=0p−1(p−1i)F(i+1)\\sum_{i=0}^{p-1} \\binom{p-1}{i} F(i+1) i=0∑p−1​(ip−1​)F(i+1) 我们的目的就要让这个式子的值等于 [p=k][p=k][p=k]，也就是： ∑i=0p(pi)F(i+1)=[p=k−1]\\sum_{i=0}^{p} \\binom{p}{i} F(i+1) = [p=k-1] i=0∑p​(ip​)F(i+1)=[p=k−1] 这个就是一个二项式反演的形式，所以就有： F(p+1)=∑i=0p(−1)p−i(pi)[i=k−1]=(−1)p−k+1(pk−1)F(p+1) = \\sum_{i=0}^p (-1)^{p-i} \\binom{p}{i} [i=k-1] = (-1)^{p-k+1} \\binom{p}{k-1} F(p+1)=i=0∑p​(−1)p−i(ip​)[i=k−1]=(−1)p−k+1(k−1p​) 因此 F(∣T∣)=(−1)∣T∣−k(∣T∣−1k−1)F(|T|) = (-1)^{|T|-k}\\binom{|T|-1}{k-1}F(∣T∣)=(−1)∣T∣−k(k−1∣T∣−1​) 子集反演 莫比乌斯反演相当于在因子多重集上的子集反演，所以本质也是子集反演。 现有一个满足某些条件的元素集合 AAA。 设 f(S)f(S)f(S) 表示 A=SA=SA=S 时的答案，g(S)g(S)g(S) 表示 S⊆AS \\subseteq AS⊆A 时的答案，则有如下结论： g(S)=∑T⊆Sf(T) ⟺ f(S)=∑T⊆S(−1)∣S∣−∣T∣g(T)g(S) = \\sum_{T \\subseteq S} f(T) \\iff f(S) = \\sum_{T \\subseteq S} (-1)^{|S|-|T|}g(T) g(S)=T⊆S∑​f(T)⟺f(S)=T⊆S∑​(−1)∣S∣−∣T∣g(T) 设 f(s)f(s)f(s) 表示满足 A=SA=SA=S 时的答案，g(S)g(S)g(S) 表示 A⊆SA \\subseteq SA⊆S 时的答案，则有如下结论： g(S)=∑S⊆Tf(T) ⟺ f(S)=∑S⊆T(−1)∣T∣−∣S∣g(T)g(S) = \\sum_{S \\subseteq T} f(T) \\iff f(S) = \\sum_{S \\subseteq T} (-1)^{|T|-|S|}g(T) g(S)=S⊆T∑​f(T)⟺f(S)=S⊆T∑​(−1)∣T∣−∣S∣g(T) 斯特林反演 定义第一类斯特林数 [nm]\\begin{bmatrix}n \\\\ m\\end{bmatrix}[nm​] 表示 nnn 个不同元素形成 mmm 个圆排列的方案数。 注意 (1,2,3,4)(1,2,3,4)(1,2,3,4) 与 (2,3,4,1)(2,3,4,1)(2,3,4,1) 为同一个圆排列，但 (1,2,3,4)(1,2,3,4)(1,2,3,4) 与 (4,3,2,1)(4,3,2,1)(4,3,2,1) 不是同一个圆排列。 其满足如下递推式： [nm]=[n−1m−1]+(n−1)[n−1m]\\begin{bmatrix}n\\\\m\\end{bmatrix} = \\begin{bmatrix} n-1 \\\\ m-1 \\end{bmatrix} + (n-1) \\begin{bmatrix} n-1 \\\\ m \\end{bmatrix} [nm​]=[n−1m−1​]+(n−1)[n−1m​] 这个递推式就是考虑元素 nnn 是自己单独变成一个圆排列还是放到前 n−1n-1n−1 个数的前面。 对于任意一个排列我们如果将其变成置换的形式，就相当于划分成了若干圆排列，也就是说： ∑i=0n[ni]=n!\\sum_{i=0}^n \\begin{bmatrix} n \\\\ i \\end{bmatrix} = n! i=0∑n​[ni​]=n! 定义第二类斯特林数 {nm}\\begin{Bmatrix} n \\\\ m\\end{Bmatrix}{nm​} 表示将 nnn 个不同的元素划分到 mmm 个相同的集合中，要求集合非空的方案数。 则有如下的递推式： {nm}={n−1m−1}+m{n−1m}\\begin{Bmatrix} n \\\\ m \\end{Bmatrix} = \\begin{Bmatrix} n-1 \\\\ m-1 \\end{Bmatrix} + m\\begin{Bmatrix} n-1 \\\\ m \\end{Bmatrix} {nm​}={n−1m−1​}+m{n−1m​} 就是考虑元素 nnn 是自己新建一个集合，还是放在前面已有的集合中。 可以显然发现这个结论： [nm]≥{nm}\\begin{bmatrix} n \\\\ m\\end{bmatrix} \\ge \\begin{Bmatrix} n \\\\ m \\end{Bmatrix} [nm​]≥{nm​} 因为一个圆排列只对应一个集合，而一个集合可以对应多个圆排列。 斯特林数最关键的应用就是：普通幂、上升幂、下降幂之间的转换。 定义下降幂：xn‾=x×(x−1)×(x−2)×⋯×(x−n+1)x^{\\underline{n}} = x\\times (x-1) \\times (x-2) \\times \\cdots \\times (x-n+1)xn​=x×(x−1)×(x−2)×⋯×(x−n+1)。 定义上升幂：xn‾=x×(x+1)×(x+2)×⋯×(x+n−1)x^{\\overline{n}} = x \\times (x+1) \\times (x+2) \\times \\cdots \\times (x+n-1)xn=x×(x+1)×(x+2)×⋯×(x+n−1)。 显然若 x&lt;nx &lt; nx&lt;n，则 xn‾=0x^{\\underline{n}} = 0xn​=0。 普通幂转下降幂： xn=∑i=0n{ni}xi‾x^n = \\sum_{i=0}^n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x^{\\underline{i}} xn=i=0∑n​{ni​}xi​ 证明： 考虑使用数学归纳法，显然 n=0n=0n=0 时成立，考虑假设 [0,n−1][0,n-1][0,n−1] 成立，证明 nnn 时成立。 ∑i=0n{ni}xi‾=∑i=0n{n−1i−1}xi‾+∑i=0ni×{n−1i}xi‾=∑i=0n−1{n−1i}xi+1‾+∑i=0n−1i×{n−1i}xi‾=∑i=0n−1(x−i)×{n−1i}xi‾+∑i=0n−1i×{n−1i}xi‾=x×∑i=0n{ni}xi‾=x×xn−1=xn\\begin{aligned} &amp;\\sum_{i=0}^{n} \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= \\sum_{i=0}^{n} \\begin{Bmatrix} n-1 \\\\ i-1 \\end{Bmatrix}x^{\\underline{i}} + \\sum_{i=0}^n i \\times \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= \\sum_{i=0}^{n-1} \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i+1}} + \\sum_{i=0}^{n-1} i \\times \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= \\sum_{i=0}^{n-1} (x-i) \\times \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i}} + \\sum_{i=0}^{n-1} i \\times \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= x \\times \\sum_{i=0}^n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= x \\times x^{n-1} \\\\ &amp;= x^n \\end{aligned} ​i=0∑n​{ni​}xi​=i=0∑n​{n−1i−1​}xi​+i=0∑n​i×{n−1i​}xi​=i=0∑n−1​{n−1i​}xi+1​+i=0∑n−1​i×{n−1i​}xi​=i=0∑n−1​(x−i)×{n−1i​}xi​+i=0∑n−1​i×{n−1i​}xi​=x×i=0∑n​{ni​}xi​=x×xn−1=xn​ 上升幂转通常幂： xn‾=∑i=0n[ni]xix^{\\overline{n}} = \\sum_{i=0}^n \\begin{bmatrix} n \\\\ i \\end{bmatrix} x^i xn=i=0∑n​[ni​]xi 证明同上。 下降幂转通常幂： xn‾=∑i=0n(−1)n−i{ni}xix^{\\underline{n}} = \\sum_{i=0}^n (-1)^{n-i} \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x^i xn​=i=0∑n​(−1)n−i{ni​}xi 通常幂转上升幂： xn=∑i=0n(−1)n−i[ni]xi‾x^{n} = \\sum_{i=0}^n (-1)^{n-i} \\begin{bmatrix} n \\\\ i \\end{bmatrix} x^{\\overline{i}} xn=i=0∑n​(−1)n−i[ni​]xi 上述两个式子的证明： 首先这个式子成立： xn‾=(−1)n×(−x)n‾x^{\\underline{n}} = (-1)^n \\times (-x)^{\\overline{n}} xn​=(−1)n×(−x)n 将这个式子分别带入第一、二个公式即可得到这两个式子。 反转公式： ∑i=mn{ni}[im](−1)n−i=[m=n]∑i=mn[ni]{im}(−1)n−i=[m=n]\\sum_{i=m}^n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} \\begin{bmatrix} i \\\\ m \\end{bmatrix} (-1)^{n-i} = [m = n] \\\\ \\sum_{i=m}^n \\begin{bmatrix} n \\\\ i \\end{bmatrix} \\begin{Bmatrix} i \\\\ m \\end{Bmatrix} (-1)^{n-i}= [m = n] \\\\ i=m∑n​{ni​}[im​](−1)n−i=[m=n]i=m∑n​[ni​]{im​}(−1)n−i=[m=n] 证明： 将第三、四个公式，分别带入第一、二个公式就可以得到这个公式。 斯特林反演： f(n)=∑i=0n[ni]g(i) ⟺ g(n)=∑i=0n(−1)n−i{ni}f(i)f(n)=∑i=0n{ni}g(i) ⟺ g(n)=∑i=0n(−1)n−i[ni]f(i)f(n)=∑i=n[in]g(i) ⟺ g(n)=∑i=n(−1)i−n{in}f(i)f(n)=∑i=n{in}g(i) ⟺ g(n)=∑i=n(−1)i−n[in]f(i)f(n) = \\sum_{i=0}^n \\begin{bmatrix} n \\\\ i \\end{bmatrix} g(i) \\iff g(n) = \\sum_{i=0}^n (-1)^{n-i} \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} f(i) \\\\ f(n) = \\sum_{i=0}^n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} g(i) \\iff g(n) = \\sum_{i=0}^n (-1)^{n-i} \\begin{bmatrix} n \\\\ i \\end{bmatrix} f(i) \\\\ f(n) = \\sum_{i=n} \\begin{bmatrix} i \\\\ n \\end{bmatrix} g(i) \\iff g(n) = \\sum_{i=n} (-1)^{i-n} \\begin{Bmatrix} i \\\\ n \\end{Bmatrix} f(i) \\\\ f(n) = \\sum_{i=n} \\begin{Bmatrix} i \\\\ n \\end{Bmatrix} g(i) \\iff g(n) = \\sum_{i=n} (-1)^{i-n} \\begin{bmatrix} i \\\\ n \\end{bmatrix} f(i) \\\\ f(n)=i=0∑n​[ni​]g(i)⟺g(n)=i=0∑n​(−1)n−i{ni​}f(i)f(n)=i=0∑n​{ni​}g(i)⟺g(n)=i=0∑n​(−1)n−i[ni​]f(i)f(n)=i=n∑​[in​]g(i)⟺g(n)=i=n∑​(−1)i−n{in​}f(i)f(n)=i=n∑​{in​}g(i)⟺g(n)=i=n∑​(−1)i−n[in​]f(i) 下面只证明一下第一个式子的充分性，其余的都可以类比地推出。 g(n)=∑i=0n[i=n]g(i)=∑i=0n(∑j=in{nj}[ji](−1)n−jg(i))=∑j=0n(−1)n−j{nj}(∑i=0j[ji]g(i))=∑j=0n(−1)n−j{nj}f(j)\\begin{aligned} g(n) &amp;= \\sum_{i=0}^n [i=n] g(i) \\\\ &amp;= \\sum_{i=0}^n \\left(\\sum_{j=i}^n \\begin{Bmatrix} n \\\\ j \\end{Bmatrix} \\begin{bmatrix} j \\\\ i \\end{bmatrix} (-1)^{n-j} g(i)\\right) \\\\ &amp;= \\sum_{j=0}^n (-1)^{n-j} \\begin{Bmatrix} n \\\\ j \\end{Bmatrix} \\left(\\sum_{i=0}^j \\begin{bmatrix} j \\\\ i \\end{bmatrix} g(i)\\right) \\\\ &amp;= \\sum_{j=0}^n (-1)^{n-j} \\begin{Bmatrix} n \\\\ j \\end{Bmatrix}f(j) \\end{aligned} g(n)​=i=0∑n​[i=n]g(i)=i=0∑n​(j=i∑n​{nj​}[ji​](−1)n−jg(i))=j=0∑n​(−1)n−j{nj​}(i=0∑j​[ji​]g(i))=j=0∑n​(−1)n−j{nj​}f(j)​ 线性代数 矩阵乘法 若给定矩阵 A,BA,BA,B，使得 C=A×BC = A \\times BC=A×B，则满足：ci,j=∑k(Ai,k×Bk,j)c_{i,j} = \\sum_{k} (A_{i,k} \\times B_{k,j})ci,j​=∑k​(Ai,k​×Bk,j​) 也就是说若 A,BA,BA,B 可以进行矩阵乘法则必须要满足：AAA 的列数等于 BBB 的行数。 矩阵乘法之后的 CCC 矩阵 (i,j)(i,j)(i,j) 位置的元素，相当于 AAA 的第 iii 行与 BBB 的第 jjj 列对应相乘再相加后的结果。 矩阵乘法之后的 CCC 矩阵的行数等于 AAA 的行数，列数等于 BBB 的列数。 矩阵乘法满足结合律，但不满足交换律，即若我们要计算 AkA^kAk 也可以用类似快速幂的方法进行计算。 我们可以将矩阵乘法中的运算更换，比如换成：ci,j=max⁡k(Ai,k+Bk,j)c_{i,j} = \\max_{k} (A_{i,k} + B_{k,j})ci,j​=maxk​(Ai,k​+Bk,j​)，这个东西叫做 max⁡+\\max+max+矩乘，可以证明这种形式的矩阵乘法也满足结合律。 而我们的许多 dpdpdp 中的转移方程就可以用这种矩阵表示出来，所以就可以通过矩阵乘法在 O(log⁡n)O(\\log n)O(logn) 的时间内进行 dpdpdp 或者快速维护动态 dpdpdp。 高斯消元 请查看： 【学习笔记】高斯消元 本文只会扩展一下高斯消元的应用，主要是这种加减消元法的思想。 解异或方程组 记 ⊕\\oplus⊕ 为按位 xor 操作，解下列方程组： a1,1x1⊕a1,2x2⊕⋯a1,nxn=y1a2,1x1⊕a2,2x2⊕⋯a2,nxn=y2⋯am,1x1⊕am,2x2⊕⋯am,nxn=yma_{1,1} x_1 \\oplus a_{1,2} x_2 \\oplus \\cdots a_{1,n} x_n = y_1 \\\\ a_{2,1} x_1 \\oplus a_{2,2} x_2 \\oplus \\cdots a_{2,n} x_n = y_2 \\\\ \\cdots\\\\ a_{m,1} x_1 \\oplus a_{m,2} x_2 \\oplus \\cdots a_{m,n} x_n = y_m\\\\ a1,1​x1​⊕a1,2​x2​⊕⋯a1,n​xn​=y1​a2,1​x1​⊕a2,2​x2​⊕⋯a2,n​xn​=y2​⋯am,1​x1​⊕am,2​x2​⊕⋯am,n​xn​=ym​ 其中 ai,j∈{0,1}a_{i,j} \\in \\{0,1\\}ai,j​∈{0,1} 注意到一点 a⊕a=0a \\oplus a = 0a⊕a=0，也就是我们可以使用这点性质进行消元。 过程与高斯消元相同，因为我们每次只需要支持行的交换和行的对应异或所以可以使用 bitset 优化到 O(n3w)O(\\frac{n^3}{w})O(wn3​)。 矩阵求逆 对于方阵 AAA 若方阵 A−1A^{-1}A−1 满足 A×A−1=A−1×A=IA \\times A^{-1} = A^{-1} \\times A = IA×A−1=A−1×A=I，则称矩阵 AAA 可逆，其中 A−1A^{-1}A−1 就是它的逆矩阵。 记 InI_nIn​ 表示 n×nn\\times nn×n 的单位矩阵，则逆矩阵的求法如下： 构造一个 n×2nn \\times 2nn×2n 的矩阵 (A,In)(A,I_n)(A,In​)。 通过高斯消元将矩阵变成 (In,A−1)(I_n,A^{-1})(In​,A−1)，这样右半部分的矩阵就是 AAA 的逆矩阵 A−1A^{-1}A−1，若左边不可以化为 InI_nIn​ 则矩阵 AAA 不可逆。 行列式求值 对于一个 n×nn \\times nn×n 的行列式 AAA，其行列式的值定义为： det⁡(A)=∑σ∈Snsgn(σ)∏i=1nai,σi\\det(A) = \\sum_{\\sigma \\in S_n} \\text{sgn}(\\sigma)\\prod_{i=1}^n a_{i,\\sigma_i} det(A)=σ∈Sn​∑​sgn(σ)i=1∏n​ai,σi​​ 其中 SnS_nSn​ 定义为长度为 nnn 的全排列集合，sgn(σ)\\text{sgn}(\\sigma)sgn(σ) 定义为排列 σ\\sigmaσ 的奇偶性，若 σ\\sigmaσ 中逆序对数为偶数则 sgn(σ)=1\\text{sgn}(\\sigma) = 1sgn(σ)=1，否则 sgn(σ)=−1\\text{sgn}(\\sigma) = -1sgn(σ)=−1 行列式有如下性质： 交换两行（列）行列式的值取反 证明：若交换 x,yx,yx,y 两行，则考虑贡献是怎么变化的，如果要使得 ∏i=1nai,σi\\prod_{i=1}^n a_{i,\\sigma_i}∏i=1n​ai,σi​​ 依旧是之前的值，就相当于要交换 σx\\sigma_xσx​ 和 σy\\sigma_yσy​，此时 σx,σy\\sigma_x,\\sigma_yσx​,σy​ 是否构成逆序对的情况取反，而对于 p∈(x,y)p\\in(x,y)p∈(x,y)，σp\\sigma_pσp​ 是否与 σx,σy\\sigma_x,\\sigma_yσx​,σy​ 构成逆序对的情况要么同时改变，要么同时不变，所以不会有影响，对于 p∈[1,x)⋃(y,n]p\\in [1,x) \\bigcup (y,n]p∈[1,x)⋃(y,n]，σp\\sigma_pσp​ 是否与 σx,σy\\sigma_x,\\sigma_yσx​,σy​ 构成逆序对显然不会有任何影响。 综上逆序对恰好变化 111，也就是奇偶性会改变，会乘以 −1-1−1。 将一行（列）加到另一行（列）上行列式的值不变 证明：若将 xxx 列加入到 yyy 列上，那么对于一个排列 σ\\sigmaσ 交换 σx\\sigma_xσx​ 与 σy\\sigma_yσy​ 后可以得到一个新的排列 σ′\\sigma'σ′，显然 sgn(σ)=−sgn(σ′)\\text{sgn}(\\sigma) = -\\text{sgn}(\\sigma')sgn(σ)=−sgn(σ′)，而对于多加的贡献在两者中正好形成相反数所以相互抵消了。 若行列式只有 ai,j(i≤j)a_{i,j}(i \\le j)ai,j​(i≤j) 处有值，即一个上三角处有值，则该行列式的值为 ∏i=1nai,i\\prod_{i=1}^n a_{i,i}∏i=1n​ai,i​ 证明：此时对于一个排列 σ\\sigmaσ 要使得 ∏i=1nai,σi\\prod_{i=1}^n a_{i,\\sigma_i}∏i=1n​ai,σi​​ 不为 000，只有 σ={1,2,3,4,⋯ ,n}\\sigma = \\{1,2,3,4,\\cdots,n\\}σ={1,2,3,4,⋯,n}，而此时 sgn(σ)=1\\text{sgn}(\\sigma) = 1sgn(σ)=1，所以行列式的值就是 ∏i=1nai,i\\prod_{i=1}^n a_{i,i}∏i=1n​ai,i​ 将行列式某行（列）同时乘 kkk，则行列式的值乘 kkk 证明：相当于对于每个 σ\\sigmaσ 都将某个 ai,σia_{i,\\sigma_i}ai,σi​​ 乘以 kkk，所以最后的值就会乘以 kkk。 通过上述性质我们就可以直接通过高斯消元将行列式消成上三角，然后对角线元素的乘积就是行列式的值。 需要注意如果消的过程中交换了一次行，要将最后的答案乘以 −1-1−1。 LGV 引理 LGV 引理常用于解决 DAG 上不相交路径（权值）计数问题 记 w(P)w(P)w(P) 表示 PPP 这条路径的权值和，若为路径计数则可将权值记为 111。 记 e(u,v)e(u,v)e(u,v) 表示 uuu 到 vvv 所有路径 PPP 的 w(P)w(P)w(P) 之和。 记起点集合为 AAA，终点集合大小为 BBB，其大小均为 nnn。 则我们的答案为下列行列式的值： M=[e(A1,B1)e(A1,B2)⋯e(A1,Bn)e(A2,B1)e(A2,B2)⋯e(A2,Bn)⋯⋯⋯⋯e(An,B1)e(An,B2)⋯e(An,Bn)]M = \\begin{bmatrix} e(A_1,B_1) &amp;e(A_1,B_2) &amp;\\cdots &amp;e(A_1,B_n) \\\\ e(A_2,B_1) &amp;e(A_2,B_2) &amp;\\cdots &amp;e(A_2,B_n) \\\\ \\cdots &amp;\\cdots &amp;\\cdots &amp;\\cdots \\\\ e(A_n,B_1) &amp;e(A_n,B_2) &amp;\\cdots &amp;e(A_n,B_n) \\\\ \\end{bmatrix} M=⎣⎢⎢⎢⎡​e(A1​,B1​)e(A2​,B1​)⋯e(An​,B1​)​e(A1​,B2​)e(A2​,B2​)⋯e(An​,B2​)​⋯⋯⋯⋯​e(A1​,Bn​)e(A2​,Bn​)⋯e(An​,Bn​)​⎦⎥⎥⎥⎤​ 感觉这个如果不给例题就实在是太抽象了。 例题 CF348D Turtles： 一张 nnn 行 mmm 列的网格图，图中的有些格子上面有障碍物，但保证 (1,1)(1,1)(1,1) 和 (n,m)(n,m)(n,m) 上面都没有障碍物。在 (1,1)(1,1)(1,1) 处有两只乌龟，都想要去 (n,m)(n,m)(n,m)。乌龟每次都可以向下或者向右走一格，前提是格子上没有任何障碍物。要求两只乌龟在前往 (n,m)(n,m)(n,m) 的路途中不可以相遇，即除了起点和终点，他们的路径没有其他公共点。求出从起点到终点的不同路径对数。答案对 109+710^9+7109+7 取模。 考虑我们从 (1,1)(1,1)(1,1) 出发必然经过 (1,2)(1,2)(1,2) 和 (2,1)(2,1)(2,1) 到达 (n,m)(n,m)(n,m) 必然经过 (n−1,m)(n-1,m)(n−1,m) 和 (n,m−1)(n,m-1)(n,m−1)，所以我们的起点集合就是 A={(1,2),(2,1)}A = \\{(1,2),(2,1)\\}A={(1,2),(2,1)} 终点集合就是 B={(n−1,m),(n,m−1)}B = \\{(n-1,m),(n,m-1)\\}B={(n−1,m),(n,m−1)}。 根据 LGV 引理，我们要算四次 e(i,j)e(i,j)e(i,j) 表示从 iii 到 jjj 的路径条数，而这个东西 O(nm)O(nm)O(nm) 的 dpdpdp 做法显然，就很好做了。 矩阵树定理 矩阵树定理可以解决给定一张图，求其生成树个数，这里要求给定的图没有自环。 下面考虑无向图的情况。 给定一张图 G=(V,E)G = (V,E)G=(V,E)，mi,jm_{i,j}mi,j​ 表示直接连接 (i,j)(i,j)(i,j) 的边数，degideg_idegi​ 表示点 iii 的度数，定义它的拉普拉斯矩阵 LLL 为： Li,j={−mi,ji≠jdegii=jL_{i,j} = \\begin{cases} -m_{i,j} &amp; i\\not= j \\\\ deg_i &amp; i = j \\end{cases} Li,j​={−mi,j​degi​​i=ji=j​ 则生成树个数为 LLL 中任意删去一行一列后其行列式的值。 下面考虑有向图的情况。 记 mi,jm_{i,j}mi,j​ 表示从 iii 指向 jjj 的边数，定义出度拉普拉斯矩阵为： Li,jout={−mi,ji≠jdegiouti=jL_{i,j}^{out} = \\begin{cases} -m_{i,j} &amp; i\\not= j\\\\ deg_i^{out} &amp; i = j \\end{cases} Li,jout​={−mi,j​degiout​​i=ji=j​ 定义入度拉普拉斯矩阵为： Li,jin={−mi,ji≠jdegiini=jL_{i,j}^{in} = \\begin{cases} -m_{i,j} &amp; i\\not= j \\\\ deg_i^{in} &amp; i = j \\end{cases} Li,jin​={−mi,j​degiin​​i=ji=j​ 记图 GGG 的以 rrr 为根的根向生成树的方案数为 troot(G,r)t^{root}(G,r)troot(G,r)，记图 GGG 的以 rrr 为根的叶向生成树的方案数为 tleaf(G,r)t^{leaf}(G,r)tleaf(G,r)，则根据矩阵树定理有： troot(G,k)=det⁡Lout(1,2,3,⋯ ,k−1,k+1,⋯ ,n1,2,3,⋯ ,k−1,k+1,⋯ ,n)tleaf(G,k)=det⁡Lin(1,2,3,⋯ ,k−1,k+1,⋯ ,n1,2,3,⋯ ,k−1,k+1,⋯ ,n)t^{root}(G,k) = \\det L^{out}\\binom{1,2,3,\\cdots,k-1,k+1,\\cdots,n}{1,2,3,\\cdots,k-1,k+1,\\cdots,n} \\\\ t^{leaf}(G,k) = \\det L^{in} \\binom{1,2,3,\\cdots,k-1,k+1,\\cdots,n}{1,2,3,\\cdots,k-1,k+1,\\cdots,n} troot(G,k)=detLout(1,2,3,⋯,k−1,k+1,⋯,n1,2,3,⋯,k−1,k+1,⋯,n​)tleaf(G,k)=detLin(1,2,3,⋯,k−1,k+1,⋯,n1,2,3,⋯,k−1,k+1,⋯,n​) 其中定义 L(1,2,3,⋯ ,k−1,k+1,⋯ ,n1,2,3,⋯ ,k−1,k+1,⋯n)L\\binom{1,2,3,\\cdots,k-1,k+1,\\cdots,n}{1,2,3,\\cdots,k-1,k+1,\\cdots n}L(1,2,3,⋯,k−1,k+1,⋯n1,2,3,⋯,k−1,k+1,⋯,n​) 表示 LLL 矩阵除去第 kkk 行第 kkk 列后的矩阵。 BEST 定理 定义 troot(G,k)t^{root}(G,k)troot(G,k) 表示图 GGG 的以 kkk 为根的根向生成树个数。 在有向欧拉图 GGG 中，GGG 中不同欧拉回路的数量为： troot(G,k)∏v∈V(degv−1)!t^{root}(G,k)\\prod_{v \\in V} (deg_v - 1)! troot(G,k)v∈V∏​(degv​−1)! degvdeg_vdegv​ 既可以指出度也可以指入度，因为欧拉图中每个点的入度和出度相等。 kkk 可以为任意点，因为此时对于任意两个点 u,vu,vu,v 都有 troot(G,x)=troot(G,y)t^{root}(G,x) = t^{root}(G,y)troot(G,x)=troot(G,y)。 一种感性理解这个定理的方法： 对于一条欧拉路径，我们保留每一个点的最后一条出边，出边一定构成一棵根向树，因为如果不是就无法构成欧拉路径。 而对于其它的边发现任意排列都可以构成欧拉路径，所以就是∏v∈V(degv−1)!\\prod_{v \\in V} (deg_v-1)!∏v∈V​(degv​−1)!。 乘起来就是 BEST 定理。 多项式与生成函数 请查看： 【学习笔记】数论之生成函数基础 【学习笔记】拉格朗日插值 群论入门 请查看： 【学习笔记】Burnside 定理和 Polya 定理 计算几何 请查看： 【学习笔记】计算几何 博弈论 请查看： 【学习笔记】博弈论 ---- 非偏博弈","link":"/2023/09/14/math/"},{"title":"金牌导航 凸包-稳定凸包","text":"【题解】金牌导航-凸包-稳定凸包 题面： 做法详解： 考虑一个什么样的凸包是一个稳定的凸包（推荐自己画画图，就理解了） 若对于凸包上的每一条边，都有包含其端点在内至少三个不同位置的点，那么这就肯定是一个稳定的凸包。 考虑若只有两个点，那么在其外面在加入一个点，那么这个点与其对应的这条边可以同时被计算入新的凸包 考虑若有三个及更多的点，那么在其外面加入一个点，这条边上除了两个端点之外的那些点就不可能再计入新的凸包里了，所以这就是一个稳定的凸包 实现起来非常好搞：对于每一条凸包上的边统计有多少个点在这条边上，注意这些点不一定要是凸包上的点 小细节： （1）可能会有重复的点，那么这样的点肯定不能被算多次，所以要去重 （2）考虑若凸包就是一条线，那么肯定不会是一个稳定的凸包，因为在其延长线上再随意找一个点也可以形成一个包含所有点的新凸包 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e3+4;struct V{ int x,y; V(int _x = 0 ,int _y = 0){ x = _x,y = _y; }}q[MAXN],a[MAXN],tmp[MAXN];int head,n;V operator - (V l,V r){ return V(l.x - r.x,l.y - r.y);}int operator * (V l,V r){ return l.x * r.y - l.y * r.x;}int dot(V l,V r){ return l.x * r.x + l.y * r.y;}int len(V l){ return sqrt(l.x * l.x + l.y * l.y);}bool cmp(V l,V r){ V u = (l - a[1]),w = (r - a[1]); int h = u * w; if(h != 0){ return h &gt; 0; } if(l.x != r.x) return l.x &lt; r.x; return l.y&lt;r.y;}bool cmp_x(V l,V r){ if(l.x != r.x) return l.x &lt; r.x; return l.y &lt; r.y;}void Graham(){ int pos = 1; for(int i=2; i&lt;=n; i++){ if(a[i].x &lt; a[pos].x || (a[i].x == a[pos].x &amp;&amp; a[i].y &lt; a[pos].y)){ pos = i; } } if(pos != 1){ swap(a[pos],a[1]); } sort(a+2,a+n+1,cmp); for(int i=1; i&lt;=n; i++){ while(head &gt;= 2 &amp;&amp; (a[i] - q[head -1]) * (q[head] - q[head - 1]) &gt;= 0){ head--; } q[++head] = a[i]; } q[head + 1] = q[1];}bool in_line(V p,V from,V to){ int h = (from - p) * (to - p); if(h != 0) return false; return dot((from - p),(to - p)) &lt;= 0;}bool check_ans(V from,V to){ int res = 0; for(int i=1; i&lt;=n; i++){ if(in_line(a[i],from,to)) res++; if(res &gt;= 3) return true; } return res &gt;= 3;}int cross(V x,V y,V z){ return (y - x) * (z - x);}int Area(){ int res = 0; for(int i=1; i&lt;=head; i++){ res += q[i] * q[i+1]; } return res;}int main(){ int t; cin&gt;&gt;t; while(t--){ head = 0; int h; cin&gt;&gt;h; for(int i=1; i&lt;=h; i++){ cin&gt;&gt;tmp[i].x&gt;&gt;tmp[i].y; } sort(tmp+1,tmp+h+1,cmp_x); a[1] = tmp[1]; n = 1; for(int i=2; i&lt;=h; i++){ if(tmp[i].x != tmp[i-1].x || tmp[i].y != tmp[i-1].y) a[++n] = tmp[i]; } Graham(); bool flag = false; for(int i=1; i&lt;=head; i++){ if(!check_ans(q[i],q[i+1])){ printf(&quot;NO\\n&quot;); flag = true; break; } } if(Area() == 0 &amp;&amp; !flag){ printf(&quot;NO\\n&quot;); } else if(!flag){ printf(&quot;YES\\n&quot;); } } return 0;}","link":"/2022/04/18/jinpaidaohang-tubao-wendingtubao/"},{"title":"基(奇)本(技)套(淫)路(巧)","text":"本篇是关于我做题时遇到的很神奇的技巧和思路的总结，会不定时更新。 以后就记录一些小 trick 以及一些知识点的小套路 Tricks 对于乘除法我们可以直接取对数转化为加减法 对于 ⌈ab⌉\\lceil \\dfrac{a}{b} \\rceil⌈ba​⌉ 可以转化为 ⌊a+(b−1)b⌋\\lfloor \\dfrac{a + (b-1)}{b} \\rfloor⌊ba+(b−1)​⌋ 来快速求解 对于两个点 x,yx,yx,y，若 lca(x,y)lca(x,y)lca(x,y) 为 xxx，则意味着 xxx 在 yyy 到根的路径上。 区间内有无重复元素：记录上一次出现的位置，然后转化为区间取 min⁡\\minmin 将 DP 的转移分为几块，每一块分开处理分开考虑 区间问题转化为差分或前缀和后考虑 对于存在查询很优以及修改很优的做法，就可以考虑使用分块平衡复杂度 边权转点权：每条边额外建一个点，连接这条边的两个端点 枚举每一个数的约数可以逆向转化为枚举每一个数的倍数，就可以让复杂度 O(nn)→O(nlog⁡n)O(n\\sqrt{n}) \\to O(n \\log n)O(nn​)→O(nlogn) 预处理前后缀信息，通过前后缀信息合并得到答案 与子树相对深度相关的有关的题，将贡献改为与子树绝对深度相关的信息 与某个极大数的组合数相关的题，考虑卢卡斯定理 SAM 中两个前缀的 LCS 是它们在 parent 树上的 lca 的最长串 后缀的 LCP 可以建反串转化为前缀的 LCS 广义 SAM 中一般可以考虑使用线段树合并维护当前点属于的模板串的集合，也可以用来维护 endpos 集合 ⌊j−ik⌋=⌊jk⌋−⌊ik⌋−[(j%k)&lt;(i%k)]\\lfloor \\frac{j-i}{k} \\rfloor = \\lfloor \\frac{j}{k} \\rfloor - \\lfloor \\frac{i}{k} \\rfloor - [(j \\% k) &lt; (i \\% k)]⌊kj−i​⌋=⌊kj​⌋−⌊ki​⌋−[(j%k)&lt;(i%k)] 树形背包的优化做法的复杂度是 O(nm)O(nm)O(nm)，其中 nnn 是节点数，mmm 是背包大小 自动机要考虑对模式串建或者询问串建，都考虑一下 链加+单点查询 -&gt; 单点加+子树查询：好写而且复杂度低 对于某些操作或者什么的，可以考虑想想终止状态是什么 期望次数可以理解为 1概率\\frac{1}{\\text{概率}}概率1​ 路径最大值/最小值：Kruskal 重构树；路径最大值最小/最小值最大：最小生成树、二分答案 字符串匹配使用 bitset 维护文本串每一个字符出现的位置，然后模式串求一个并集就好了 计数问题想不出来就考虑容斥一下，容斥原理或者统计不合法的方案数 没啥想法就随便枚举几个值试试 带环 DP：高斯消元、二分一个值 对于两个不同的数，二进制分组之后一定至少有一次它们在不同组中 设 p[i]p[i]p[i] 表示为 iii 的概率，P[i]P[i]P[i] 表示大于等于 iii 的概率，那么期望可以理解为：∑i=1ni×p[i]=∑i=1nP[i]\\sum_{i=1}^n i \\times p[i] = \\sum_{i=1}^n P[i]∑i=1n​i×p[i]=∑i=1n​P[i] ∑j=0i(ij)=2i\\sum_{j=0}^i \\binom{i}{j} = 2^i∑j=0i​(ji​)=2i 平衡树的翻转标记：只要下面有用到他的儿子就下传 树上两条路径如果有公共点，则交集必然满足点数等于边数加一 非必要情况，否则使用树剖求 lcalcalca 根据条件去求满足条件的点，或者枚举点判断是否符合条件 Kruskal 重构树的节点个数为 2×n−12\\times n - 12×n−1，千万别直接把 nnn 拿上去了。 在图论中看到只经过小于等于或者大于等于某个值的条件时，想到 Kruskal 重构树，转化为子树询问 期望 dpdpdp 一般可以考虑设到最终状态的期望，也可以是走一步的期望 对于选 kkk 个元素最优的题，那么对于任意一种最优方案，对于任意一个区间 [l,r][l,r][l,r] 若区间内选了 ppp 个，那么这 ppp 个一定是区间 [l,r][l,r][l,r] 选择 ppp 个的最优方案之一。 set 里 count 的复杂度是假的，不如直接用 map 1 int = 4b 调题的时候不要着急，要分析问题性质而不是对着错误的数据在那里打补丁。 某类数数题考虑最终的状态满足什么条件时合法，然后统计这些条件就变简单了。 树上 mmm 个点的 LCALCALCA 等于 dfsdfsdfs 最小的点和最大的点的 LCALCALCA。 考试犯的傻逼错误： xxxx;xxxx; 却没打大括号 交错源代码 平衡树新建节点一定要把所有的信息都赋初值，不能感觉可以不赋就不赋 注意题目中是说：经过边的数量还是经过点的数量 字符串题注意串的字符串的首地址需要不需要加一 不要轻易否定自己的解法，如果感觉不对就构造一组，跑一遍 hack 掉就好了 网络流里不能随便建双向边，很多题在实际的建模里需要从 S -&gt; T （大致方向）建边。 建文件夹一定只包含数字和字母 可以手模的样例一定要手模 多测一定要清空，是将本次更改的全部改回去，而不是将下次可能用到的改回去，非必要情况，请使用 memsetmemsetmemset 清空 一定不要读形式化题面，只给了一坨抽象的式子完全不如慢慢读文字题面 数组中长度小的维度放在前面，可能可以让速度快很多倍 一定要认真读数据范围，特别关注看上去就很不正常的地方 预处理阶乘的逆元一定要记得处理 000 的啊。 平衡树不要和线段树混了，记得 nownownow 也是一个独立的点啊 无法调试或者灵异事件不要着急：观察一下基本的配置、观察一下文件（夹）名 传参数不要直接传一个 vectorvectorvector multiset 删除一定要反复检查是不是直接 erase(x) 状压或枚举状态的时候一定要注意从 000 开始还是从 111 开始，就是需不需要减一 写复杂的数据结构一定要从内层到外层慢慢来，千万不要从外层到内层去写 一些主函数比较难写的数据结构，就先把数据结构用暴力实现，直到主函数改对再去写数据结构 多测清空的时候注意：是不是之前的一些特判直接跳过了清空环节","link":"/2022/06/24/tricks/"},{"title":"莫队","text":"从零开始的莫队 本篇主要是我学习了莫队算法之后的一些感受，仅包含普通莫队与普通带修改莫队相关知识，望各位大佬指点一二 首先就是非常经典的莫队适用的题型： （1）区间询问问题，且区间信息不可高效合并，即传统数据结构难以维护 （2）必须可以离线 （3）不带修改（或带简单修改） （4）（这一条可以自动忽略）若已知区间 [L1,R1][L_1,R_1][L1​,R1​] 的答案，我们可以花费 O(∣L1−L2∣)O(|L_1 - L_2|)O(∣L1​−L2​∣) 的时间将左端点移到 L2L_2L2​，花费 O(∣R1−R2∣)O(|R_1 - R_2|)O(∣R1​−R2​∣) 的时间将右端点移到 R2R_2R2​ 的位置，从而得到区间 [L2,R2][L_2,R_2][L2​,R2​] 的答案，即我们区间左右端点移动 111 的复杂度是 O(1)O(1)O(1) 的 下面就来说一下莫队的基本思想： 在我们可以 O(1)O(1)O(1) 地移动区间左右端点地前提下，莫队就是将所有的询问区间按照一定顺序排好，然后从第一个区间开始进行区间的移动，每次移动完一个区间就进行答案的统计，每一个区间的答案从上一个移动好的区间移动过去，而非从头开始重新移动，我们一开始认为已知 [0,0][0,0][0,0] 的答案 对于莫队分块的大小： 普通莫队：n\\sqrt nn​ 带修莫队：n23n^{\\frac{2}{3}}n32​ 四指针莫队：n34n^{\\frac{3}{4}}n43​ 普通莫队 看思想肯定是啥都不会的，下面就通过一道题具体来看一下什么是莫队（相信我莫队真的不难） 题目描述： 基本思路： 我们在本题中维护数组 tmp[i]tmp[i]tmp[i] 表示数 iii 出现的次数，在移动区间的过程中对这个数组进行操作，若 tmp[i]tmp[i]tmp[i] 在加入了一次 iii 之后为 111 则为出现了一个新数，同理若 tmp[i]tmp[i]tmp[i] 在删去了一个 iii 之后为 000 则为消失了一个数，然后按照莫队的基本写法写就好了 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 5e4+5;const int MAXM = 2e5+5;const int MAX_VAL = 1e6+5;struct node{ int l,r,pos,id;}q[MAXM];int a[MAXN],ans[MAXM],tmp[MAX_VAL],n,S,m,res;int bl(int x){ return (x - 1) / S + 1;}bool cmp(node l,node r){ if(bl(l.l) != bl(r.l)) return bl(l.l) &lt; bl(r.l); return l.r &lt; r.r;}void Dele(int val){ if((--tmp[val]) == 0) res--;}void Add(int val){ if((++tmp[val]) == 1) res++;}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n; S = sqrt(n); for(int i=1; i&lt;=n; i++){ cin&gt;&gt;a[i]; } cin&gt;&gt;m; for(int i=1; i&lt;=m; i++){ cin&gt;&gt;q[i].l&gt;&gt;q[i].r; q[i].pos = i; } sort(q+1,q+m+1,cmp); //按照第一关键字块内顺序，第二关键字大小顺序排序 int now_l = 0,now_r = 0; for(int i=1; i&lt;=m; i++){ while(now_l &gt; q[i].l) Add(a[--now_l]); //因为这个数我们加过了，所以加减过后的 while(now_r &lt; q[i].r) Add(a[++now_r]); while(now_l &lt; q[i].l) Dele(a[now_l++]); //因为这个数我们也要删除，所以先删再加 while(now_r &gt; q[i].r) Dele(a[now_r--]); ans[q[i].pos] = res; } for(int i=1; i&lt;=m; i++){ cout&lt;&lt;ans[i]&lt;&lt;endl; } return 0;} 代码部分说明： bl(i)bl(i)bl(i) 返回的是分块之后 iii 所在块的编号 这也就是普通莫队的写法，对于不同的题目唯一需要修改的也就是 AddAddAdd 函数和 DeleDeleDele 函数而已。 需要注意的一点（也是我之前不知道的一点）：在莫队的扩展区间要先进行 l−−l--l−−,r++r++r++ 然后再进行 l++l++l++,r−−r--r−−，为了避免出现比如 [5,3][5,3][5,3] 这种的恶心情况 带修改莫队 带修改莫队与普通莫队基本是一致的，推荐理解了普通莫队之后再进行观看。 带修莫队会比普通莫队多维护一个值：时间戳，说白了就是这个询问在第几次修改后，那么在我们进行区间移动的时候，只需要在移动完区间之后，再移动一下时间戳，使得时间戳也符合当前询问的条件就好了。 下面依旧是通过一道题来具体的看看带修莫队： 题目描述： 基本思路： 使用带修莫队，与普通莫队一样维护一个 tmptmptmp 数组， tmp[i]tmp[i]tmp[i] 表示数 iii 出现的次数，然后按上一道题的写法写就好了，就是移动区间的时候需要移动时间戳 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e4+5;const int MAXM = 1e4+5;const int MAX_VAL = 1e6+5;struct node{ int l,r,time,id;}q[MAXM];struct node2{ int pos,val;}c[MAXM];int tmp[MAX_VAL],a[MAXN],ans[MAXM],n,m,qnum,tim,S,res;int bl(int x){ return (x - 1) / S + 1;}bool cmp(node x,node y){ if(bl(x.l) != bl(y.l)) return bl(x.l) &lt; bl(y.l); if(bl(x.r) != bl(y.r)) return bl(x.r) &lt; bl(y.r); if(x.time != y.time) return x.time &lt; y.time;}void add(int x){ if((++tmp[a[x]]) == 1) res++;} void Dele(int x){ if((--tmp[a[x]]) == 0) res--;}void change(int now,int i){ if(c[now].pos &gt;= q[i].l &amp;&amp; c[now].pos &lt;= q[i].r){ if((++tmp[c[now].val]) == 1) res++; if((--tmp[a[c[now].pos]]) == 0) res--; } swap(c[now].val,a[c[now].pos]);}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n&gt;&gt;m; S = int(pow(n,0.66)); for(int i=1; i&lt;=n; i++){ cin&gt;&gt;a[i]; } for(int i=1; i&lt;=m; i++){ char opt; int x,y; cin&gt;&gt;opt&gt;&gt;x&gt;&gt;y; if(opt == 'Q'){ q[++qnum].l = x; q[qnum].r = y; q[qnum].time = tim; q[qnum].id = qnum; } else if(opt == 'R'){ c[++tim].pos = x; c[tim].val = y; } } sort(q+1,q+qnum+1,cmp); int now = 0,now_l = 0,now_r = 0; for(int i=1; i&lt;=qnum; i++){ while(q[i].l &lt; now_l) add(--now_l); while(q[i].r &gt; now_r) add(++now_r); while(q[i].l &gt; now_l) Dele(now_l++); while(q[i].r &lt; now_r) Dele(now_r--); while(q[i].time &lt; now) change(now--,i); //非常好的一句话：改多了，改回去，所以 now 点也要改回去 while(q[i].time &gt; now) change(++now,i); //改少了，改过来，now 点已经改过了，所以不用了 ans[q[i].id] = res; } for(int i=1; i&lt;=qnum; i++){ cout&lt;&lt;ans[i]&lt;&lt;endl; } return 0;} 代码部分说明： 其他的我就不多说了，我们仔细读读代码就明白了，关于 changechangechange 函数最后的 swapswapswap 操作的说明，我们在移动时间戳的时候第一次处理这个修改即会将 aaa 中对应的值改为 ccc 中对应的值，而当我们第二次要处理这个修改就是相当于我们搞回去了，也就是这个修改不要了，所以对于第二次就是将 aaa 中对应的值改回去，也就是改成交换后 ccc 里的值，交换之后再次修改就可以实现这个功能","link":"/2022/04/05/modui/"}],"tags":[{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"}],"pages":[]}