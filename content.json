{"posts":[{"title":"ARC165F Make Adjacent","text":"【题解】ARC165F Make Adjacent 题目描述： 给定 nnn 和一个长度为 2n2n2n 的序列 aaa，满足 [1,n][1,n][1,n] 每个数恰好出现两次。 每一次操作可以交换相邻的两个数，询问最少多少次操作可以使得序列 aaa 满足 ∀i∈[1,n]a2i=a2i−1\\forall i\\in[1,n] \\quad a_{2i} = a_{2i-1}∀i∈[1,n]a2i​=a2i−1​。 1≤n≤2×1051 \\le n \\le 2 \\times 10^51≤n≤2×105 题目分析： 若只有两个数，则本质上只有下面这两种情况：121212121212 和 122112211221 可以发现对于第一种情况，最小的操作次数必然是变成 112211221122，而第二种则可以变成 112211221122 或者 221122112211 均可。 扩展一下，也就是说设 lil_ili​ 表示 iii 第一次出现的位置，rir_iri​ 表示 iii 最后一次出现的位置。 若存在 li&lt;ljl_i &lt; l_jli​&lt;lj​ 且 ri&lt;rjr_i &lt; r_jri​&lt;rj​，则 iii 必然排在 jjj 的前面。 暴力就是 O(n2)O(n^2)O(n2) 建边然后跑最小拓扑序即可。 优化的话有以下两种做法。 做法一： 考虑如果只有 li&lt;ljl_i &lt; l_jli​&lt;lj​ 这一维的限制很好做，就是前缀和优化建图。 既然一维我们会了，二维就是对第一维分治，这样就转化为了只剩一维限制的了。 做法二： 考虑这个其实就是一个二维偏序，所以可以使用线段树优化建图，也就是按照 lll 排序之后在线段树上维护 rrr。 但是我们因为存在 lll 的限制，所以我们不能只在一棵线段树上操作，要对线段树可持久化，这样才能保证贡献是对的。 代码： 做法一： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5+5;struct edge{ int nxt,to; edge(){} edge(int _nxt,int _to){ nxt = _nxt,to = _to; }}e[100 * N];int cnt,head[50 * N],tot,pos1[N],pos2[N],a[N],b[N],deg[50 * N],L[N],R[N];void add_edge(int from,int to){// printf(&quot;%d %d\\n&quot;,from,to); e[++cnt] = edge(head[from],to); head[from] = cnt; deg[to]++;}bool cmp(int a,int b){ return L[a] &lt; L[b];}void solve(int l,int r){ //分治 if(l == r) return; int mid = (l + r) &gt;&gt; 1; solve(l,mid);solve(mid+1,r); int posl = l,posr = mid+1; for(int i=l; i&lt;=mid; i++){ //前缀和优化 ++tot;pos1[i] = tot;add_edge(a[i],pos1[i]); if(i != l) add_edge(pos1[i-1],pos1[i]); } for(int i=r; i&gt;=mid+1; i--){ ++tot;pos2[i] = tot;add_edge(pos2[i],a[i]); if(i != r) add_edge(pos2[i],pos2[i+1]); } int sz = l-1; while(posl &lt;= mid &amp;&amp; posr &lt;= r){ //归并 if(R[a[posl]] &lt; R[a[posr]]) add_edge(pos1[posl],pos2[posr]),b[++sz] = a[posl],++posl; else b[++sz] = a[posr],++posr; } while(posl &lt;= mid) b[++sz] = a[posl],++posl; while(posr &lt;= r) add_edge(pos1[mid],pos2[posr]),b[++sz] = a[posr],++posr; for(int i=l; i&lt;=r; i++) a[i] = b[i];}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=2*n; i++){ int x;scanf(&quot;%d&quot;,&amp;x); if(!L[x]) L[x] = i; R[x] = i; } for(int i=1; i&lt;=n; i++) a[i] = i; sort(a+1,a+n+1,cmp); tot = n; solve(1,n); queue&lt;int&gt; q1;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2; for(int i=1; i&lt;=tot; i++){ if(!deg[i]){ if(i &lt;= n) q2.push(i); else q1.push(i); } } while(!q1.empty() || !q2.empty()){ //必须优先弹出新建的点，不然就寄了 int now; if(!q1.empty()) now = q1.front(),q1.pop(); else now = q2.top(),q2.pop(); if(now &lt;= n) printf(&quot;%d %d &quot;,now,now); for(int i=head[now]; i; i=e[i].nxt){ int to = e[i].to; deg[to]--; if(!deg[to]){ if(to &lt;= n) q2.push(to); else q1.push(to); } } } return 0;} 做法二： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5+5;struct edge{ int nxt,to; edge(){} edge(int _nxt,int _to){ nxt = _nxt,to = _to; }}e[100 * N];int l[N],r[N],cnt,tot,pos[100 * N],head[100 * N],deg[100 * N],a[N],ls[100*N],rs[100*N];void add_edge(int from,int to){// printf(&quot;%d %d\\n&quot;,from,to); e[++cnt] = edge(head[from],to); head[from] = cnt; deg[to]++;}bool cmp(int a,int b){ return l[a] &lt; l[b];}void modify(int &amp;now,int now_l,int now_r,int x,int y){ if(now){ ++tot;ls[tot] = ls[now],rs[tot] = rs[now]; now = tot; } else ++tot,now = tot; if(now_l == now_r){ add_edge(y,now); return; } int mid = (now_l + now_r)&gt;&gt;1; if(x &lt;= mid) modify(ls[now],now_l,mid,x,y); if(x &gt; mid) modify(rs[now],mid+1,now_r,x,y); if(ls[now]) add_edge(ls[now],now); if(rs[now]) add_edge(rs[now],now);}void query(int now,int now_l,int now_r,int l,int r,int x){ if(!now) return; if(l &lt;= now_l &amp;&amp; now_r &lt;= r){ add_edge(now,x); return; } int mid = (now_l + now_r)&gt;&gt;1; if(l &lt;= mid) query(ls[now],now_l,mid,l,r,x); if(r &gt; mid) query(rs[now],mid+1,now_r,l,r,x);}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=2*n; i++){ int x;scanf(&quot;%d&quot;,&amp;x); if(!l[x]) l[x] = i; r[x] = i; } for(int i=1; i&lt;=n; i++) a[i] = i; sort(a+1,a+n+1,cmp); tot = n; int rt = 0; for(int i=1; i&lt;=n; i++){ query(rt,1,2*n,1,r[a[i]]-1,a[i]); modify(rt,1,2*n,r[a[i]],a[i]); } queue&lt;int&gt; q1;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2; for(int i=1; i&lt;=tot; i++){ if(!deg[i]){ if(i &lt;= n) q2.push(i); else q1.push(i); } } while(!q1.empty() || !q2.empty()){ //必须优先弹出新建的点，不然就寄了 int now; if(!q1.empty()) now = q1.front(),q1.pop(); else now = q2.top(),q2.pop(); if(now &lt;= n) printf(&quot;%d %d &quot;,now,now); for(int i=head[now]; i; i=e[i].nxt){ int to = e[i].to; deg[to]--; if(!deg[to]){ if(to &lt;= n) q2.push(to); else q1.push(to); } } } return 0;}","link":"/2023/09/19/ARC165F/"},{"title":"AtCoder Beginner Contest 319","text":"【题解】 AtCoder Beginner Contest 319 没有写 F，不确定我的做法对不对。 评价：什么牛逼场次，代码大赛是嘛，从 A 开始就感觉到不对了，而且题面写的真答辩。 A.Legendary Players 题目分析： 直接按题目模拟即可。 代码： 点击查看代码 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ string s; cin&gt;&gt;s; if(s == &quot;tourist&quot;) printf(&quot;3858\\n&quot;); if(s == &quot;ksun48&quot;) printf(&quot;3679\\n&quot;); if(s == &quot;Benq&quot;) printf(&quot;3658&quot;); if(s == &quot;Um_nik&quot;) printf(&quot;3648&quot;); if(s == &quot;apiad&quot;) printf(&quot;3638&quot;); if(s == &quot;Stonefeang&quot;) printf(&quot;3630&quot;); if(s == &quot;ecnerwala&quot;) printf(&quot;3613&quot;); if(s == &quot;mnbvmar&quot;) printf(&quot;3555&quot;); if(s == &quot;newbiedmy&quot;) printf(&quot;3516&quot;); if(s == &quot;semiexp&quot;) printf(&quot;3481&quot;); return 0;} B.Measure 题目分析： 直接枚举 i,ji,ji,j 然后判断一下就好. 代码： 点击查看代码 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;=n; i++){ char s = '-'; for(int j=1; j&lt;=9; j++){ if(n % j != 0) continue; if(i % (n/j)== 0){ s = '1' + j - 1; break; } } cout&lt;&lt;s; } return 0;} C.False Hope 题目分析： 一个比较好写的写法就是：直接枚举看到的顺序。 然后枚举 i&lt;j&lt;ki &lt; j &lt; ki&lt;j&lt;k，若 pi,pj,pkp_i,p_j,p_kpi​,pj​,pk​ 这三个位于同一条线然后就判断一下是不是值满足条件即可。 对于判断同一条线，行和列是简单的，同一条对角线就是 x+yx+yx+y 或 x−yx-yx−y 为定值。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define PII pair&lt;int,int&gt;using namespace std;PII pos[100];int a[100],p[100],tot,ans;bool vis[100];void chk(){ ++tot; for(int i=1; i&lt;=9; i++){ for(int j=i+1; j&lt;=9; j++){ for(int k=j+1; k&lt;=9; k++){ if(a[p[i]] == a[p[j]] &amp;&amp; a[p[j]] != a[p[k]]){ PII b[4] = {pos[p[i]],pos[p[j]],pos[p[k]]}; bool flag = false; if(b[0].first + b[0].second == b[1].first + b[1].second &amp;&amp; b[0].first + b[0].second == b[2].first + b[2].second) flag = true; if(b[0].first - b[0].second == b[1].first - b[1].second &amp;&amp; b[0].first - b[0].second == b[2].first - b[2].second) flag = true; if(b[0].first == b[1].first &amp;&amp; b[0].first == b[2].first) flag = true; if(b[0].second == b[1].second &amp;&amp; b[0].second == b[2].second) flag = true; if(!flag) continue; ans += 1; return; } } } }}void dfs(int now){ if(now == 10){ chk(); return; } for(int i=1; i&lt;=9; i++){ if(vis[i]) continue; p[now] = i; vis[i] = true; dfs(now+1); vis[i] = false; }}int main(){ freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); for(int i=1; i&lt;=3; i++){ for(int j=1; j&lt;=3; j++){ scanf(&quot;%d&quot;,&amp;a[(i-1)*3 + j]); pos[(i-1)*3 + j] = {i,j}; } } dfs(1); double tmp = tot; tmp = 1.0 * ans / tmp; printf(&quot;%.9f&quot;,1 - tmp); return 0;} D.Minimum Width 题目分析： 所占的行数显然随着宽度的增加而单调不增，所以可以直接二分宽度。 判断占了多少行就是根据题目进行模拟。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1e6+5;int n,m,l[N];int get(int len){ int now = len; int cnt = 1; for(int i=1; i&lt;=n; i++){ if(l[i] &gt; len) return m + 1; if(l[i] &gt; now) now = len,++cnt; if(l[i] &lt;= now) now = now - l[i] - 1; } return cnt;}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;l[i]); int L = 1,R = 1e15,ans = 0; while(L &lt;= R){ int mid = (L + R) &gt;&gt; 1; if(get(mid) &lt;= m){ ans = mid; R = mid - 1; } else L = mid + 1; } printf(&quot;%lld\\n&quot;,ans); return 0;} E.Bus Stops 题目分析： 一个想法就是建分层图，对于每一个点拆成模 pip_ipi​ 下 0,1,2,pi−10,1,2,p_i-10,1,2,pi​−1 这 pip_ipi​ 个点，但是不同车站之间无法连边。 所以考虑将每一个点拆成模 lcm(p1,p2,p3,⋯ )lcm(p_1,p_2,p_3,\\cdots)lcm(p1​,p2​,p3​,⋯) 下的几个点，这样不同车站之间的边就很好连了。 但是其实建分层图是个很傻的行为，因为车站之间只能通过公交车相互到达，所以可以直接枚举 lcm(p1,p2,p3,⋯ )lcm(p_1,p_2,p_3,\\cdots)lcm(p1​,p2​,p3​,⋯) 个起始时间，然后贪心地得到答案即可。 这里的 lcmlcmlcm 经过计算不会超过 840840840。 代码： 点击查看代码 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1e5+5;int n,f[850],p[N],t[N];int solve(int now){ int ans = 0; for(int i=1; i&lt;n; i++){ int tmp = p[i] - now % p[i]; if(tmp == p[i]) tmp = 0; now = (now + tmp + t[i])%840; ans = ans + tmp + t[i]; } return ans;}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int x,y;scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;x,&amp;y); for(int i=1; i&lt;n; i++) scanf(&quot;%lld%lld&quot;,&amp;p[i],&amp;t[i]); for(int i=0; i&lt;=839; i++) f[i] = solve(i); int q;scanf(&quot;%lld&quot;,&amp;q); while(q--){ int k;scanf(&quot;%lld&quot;,&amp;k); printf(&quot;%lld\\n&quot;,f[(k+x)%840] + x + y + k); } return 0;} G.Counting Shortest Paths 题目分析： 注意到我们只需要在所有的边都被删完了，再进行询问。（我一开始以为每一次删边都需要询问，然后就被卡卡卡） 所以可以考虑直接从小到大枚举最短路长度，也就是从 111 开始一步步扩展直到扩展到 nnn。 所以一个直观的想法就是一步步预处理出 f[i][j]f[i][j]f[i][j] 表示 111 到 iii 路径长度为 jjj 的方案数，O(n)O(n)O(n) 转移显然。 考虑优化，f[i][j]f[i][j]f[i][j] 的第二维显然只有当 jjj 为 111 到 iii 的最短路时才有意义，所以可以将其它的所有忽略，总状态数变成了 O(n)O(n)O(n)。 对于转移，因为是现在的点对其余所有的点产生贡献，所以可以直接一起转移，只有 O(m)O(m)O(m) 次转移才是需要特殊注意的，所以只需要管这 O(m)O(m)O(m) 次转移，转移的总复杂度为 O(m)O(m)O(m)。 设 nmnmnm 同阶，则总时间复杂度为 O(n)O(n)O(n)。 代码中为了好写，使用了 set 复杂度会变成 O(nlog⁡n)O(n \\log n)O(nlogn)。 代码实现细节的话就是考虑我们使用 set 只维护有用的状态（就是代码里记录的 cur），也就是最短路长度等于枚举值的点，那么考虑这些有效的状态可以转移到哪些点呢。 这些有效的状态可以转移到的点就是之前没有被作为有用状态的点（就是代码里记录的 lst），因为如果一个点被当作有效状态了那么就意味着它的最短路长度一定不会低于我们当前枚举的值，那么再用当前枚举的值去更新这些点更新出来的就一定不是最短路。 然后最后更新 cur 和 lst 数组的时候，因为边操作边遍历在 set 上是很困难的，所以考虑先用 tmp 数组记录下 lst，因为我们可能转移到的点只有 lst 里的点，然后将 lst 与 cur 清空，之后直接遍历 tmp 然后对于一个点 iii 我们记录了一个 totitot_itoti​ 代表有多少个 cur 内的点通过 mmm 条给定边转移到 iii，显然如果 toti=res2tot_i = res2toti​=res2，也就是所有转移到 iii 的点都是通过给定的 mmm 条边转移过去的，也就是没有一个点是真实转移到它的，也就是其依然没有被更新，应放到 lst；反之则应放到 cur。 代码里还有的一点细节就是我们的 E[u]E[u]E[u] 记录的就是与 uuu 相连的 mmm 条边的另一个端点，这里要求另一个端点必须没有被更新到过，因为如果被更新到了那么显然这两者之间的转移就没有任何意义。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2e5+5;const int MOD = 998244353;set&lt;int&gt; E[N],cur,lst,tmp;int cnt[N],a[N],tot[N];signed main(){ int n,m;scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++){ int u,v;scanf(&quot;%lld%lld&quot;,&amp;u,&amp;v); E[u].insert(v); E[v].insert(u); } cnt[n] = 1; cur.insert(n); for(int i=1; i&lt;n; i++) lst.insert(i); while(!cur.empty()){ int res = 0,res2 = 0; for(auto now : cur) res = (res + cnt[now])%MOD,res2++; //因为每个点 now 转移到以后的点的贡献都是 cnt[now],所以 res 记录的就是转移造成的总贡献，当前是不考虑 m 条边影响下的 //res2 就是为了方便判断一个点是否被转移到，记录的总共有多少个点可以转移到以后的点 for(auto to : lst) cnt[to] = (cnt[to] + res)%MOD,tot[to] = 0; //这里就是不考虑 m 条边情况下的直接转移 for(auto now : cur){ //枚举每一条给定边，然后将通过这一条边的转移造成的贡献删掉 for(auto to : E[now]){ if(lst.find(to) != lst.end()) //这个 if 是为了防止 to 也在 cur 中直接减就会有影响 cnt[to] = (cnt[to] - cnt[now] + MOD)%MOD,tot[to]++; } } for(auto now : cur){ //因为此时 cur 内的点就都被更新到了，所以就相当于要将 cur 这些点删除 int tot = 0; for(auto to : E[now]) a[++tot] = to; for(int i=1; i&lt;=tot; i++){ //这里就是为了 E 内只维护有用的点 E[a[i]].erase(now); E[now].erase(a[i]); } } swap(tmp,lst); //这里就是更新下一轮的 cur 和 lst，这里本质就是进行了一个枚举的最短路长度加 1，只不过不需要记录长度的值 cur.clear(),lst.clear(); for(auto i : tmp){ if(tot[i] != res2){ cur.insert(i); if(i == 1){ printf(&quot;%lld\\n&quot;,cnt[1]); return 0; } } else lst.insert(i); } tmp.clear(); } printf(&quot;-1\\n&quot;); return 0;}","link":"/2023/09/10/AtCoder-Beginner-Contest-319/"},{"title":"AtCoder Regular Contest 161","text":"【题解】AtCoder Regular Contest 161 评价：感觉这场题目质量不咋地啊，都是一些乱搞题 A.Make M 题目描述： NNN 是一个正奇数。我们称一个长度为 NNN 的序列 SSS 是 M 型序列，当前仅当对于所有的 i=2,4,6,…,N−1i=2,4,6,\\dots,N-1i=2,4,6,…,N−1（即偶数位），都有 Si−1&lt;SiS_{i-1}&lt;S_{i}Si−1​&lt;Si​ 且 Si&gt;Si+1S_{i}&gt;S_{i+1}Si​&gt;Si+1​。 现在给定你一个长度为 NNN 的序列 AAA，请你判断能否通过将 AAA 序列里的元素打乱位置使其变为一个 M 型序列。 $ 1\\ \\leq\\ N\\ \\leq\\ 2\\ \\times\\ 10^5 $ 题目分析： 我们就是考虑让偶数位尽可能大，而奇数位尽可能小。 所以就是排序之后，让较大的一些认为放到偶数位，让较小的一些认为放到奇数位。 并且要让放到偶数位上尽可能小的，周围放的是奇数位上尽可能小的。 代码： B.Exactly Three Bits 题目描述： 对于一个正整数 XXX，定义 f(X)f(X)f(X) 为 XXX 在二进制表示下 111 的个数，比如，因为 6=110(2)6=110_{(2)}6=110(2)​，11=1101(2)11=1101_{(2)}11=1101(2)​，16=10000(2)16=10000_{(2)}16=10000(2)​，所以 f(6)=2f(6)=2f(6)=2，f(11)=3f(11)=3f(11)=3，f(16)=1f(16)=1f(16)=1。 现在给定你一个正整数 NNN，问是否存在一个小于等于 NNN 的正整数 XXX，满足 f(X)=3f(X)=3f(X)=3。如果存在，请输出满足条件的最大的 XXX，否则输出 -1。 本题有多组数据。 1≤N≤10181 \\le N \\le 10^{18}1≤N≤1018 题目分析： 可以直接枚举最高位和次高位，然后判断是简单的。 代码： C.Dyed by Majority (Odd Tree) 题目描述： 给定一棵 nnn 个节点的树，满足每个点的度数为奇数。你需要把每个点染成黑色或者白色，然后所有点同时变成其相邻点颜色的众数，求一个染色方案使得变化后的颜色为给定序列，或者报告无解。 2≤n≤2×1052 \\le n \\le 2\\times 10^52≤n≤2×105 题目分析： 考虑我们可以根据叶子节点变成什么直接推得其父亲节点是什么。 也就是说我们其实可以从下到上一层层确定节点的颜色。 如果 uuu 的某一个儿子 vvv 没有被确定颜色，那么也就是意味着无论这个点放什么在 vvv 的子树内都是合法的，我们就可以贪心地将 vvv 的颜色认为是 uuu 变成的颜色。 有了这个过程就很好做了。 代码： D.Everywhere is Sparser than Whole (Construction) 题目描述： 我们将非空简单无向图的密度定义为(number of edges)(number of vertices)\\displaystyle\\frac{(\\text{number\\ of\\ edges})}{(\\text{number\\ of\\ vertices})}(number of vertices)(number of edges)​。 给你正整数 NNN 和 DDD。请判断是否存在一个有 NNN 个顶点和 DNDNDN 条边的简单无向图 GGG ，它满足以下条件。如果存在，请找出一个这样的图。 条件： 让 VVV 是 GGG 的顶点集。对于VVV的任何非空的真子集XXX，由XXX诱导的GGG子图的密度严格小于DDD。 什么是诱导子图？ 对于图GGG的顶点子集XXX，XXX对GGG的诱导子图是顶点集为XXX且边集包含连接XXX中两个顶点的GGG的所有边的图。在上述条件中，请注意我们只考虑既不为空也不为全集的顶点子集。 题目分析： 首先就是怎么判断无解，如果 nd&gt;n(n−1)2nd &gt; \\frac{n(n-1)}{2}nd&gt;2n(n−1)​ 则无解，因为边数完全不够。 否则的话考虑贪心地构造，也就是让这些点连的边尽可能平衡，从每一个点向其后 ddd 个点连边，可以发现这样构造出来的图就是合法的。 代码： E.Not Dyed by Majority (Cubic Graph) 题目描述： 给定一个 nnn 点 32n\\dfrac32n23​n 边的简单无向图，其中 nnn 为偶数，且每个点的度数恰好为 333。 将每个点染上黑与白两种颜色后，进行以下操作： 将每个点的颜色变为其连接的点中颜色的众数。 请构造一个所有节点的颜色序列，使得无论原图如何染色，在经过一次操作后都不可能变为该颜色序列。多组数据。 4≤n≤5×1044 \\le n\\le 5 \\times 10^44≤n≤5×104 题目分析： 推荐做过 C 题之后再来做这个题。 会发现 C 题就已经不好做了，这个题估计根本不可做，所以大胆猜结论随机一个颜色序列大概率不合法。（这个结论也可以通过打表来证明） 考虑给定了一个颜色序列如何判断时候合法，因为每个点度数为 333，所以其实就是相当于：若 xxx 的颜色为 AAA，则 y,zy,zy,z 的颜色必然为 BBB，就是一个 2-sat 问题。","link":"/2023/09/08/AtCoder-Regular-Contest-161/"},{"title":"ABC275Ex Monster","text":"【题解】ABC275Ex Monster 题目描述： 给定 nnn 以及两个长度为 nnn 的正整数序列 Ai,BiA_i,B_iAi​,Bi​，你可以执行下述操作任意次： 选定任意整数 l,rl,rl,r，满足 1≤l≤r≤n1 \\le l \\le r \\le n1≤l≤r≤n。 花费 maxi=lr{Bi}max_{i=l}^{r} \\{B_i\\}maxi=lr​{Bi​} 的代价，将 Al,Al+1,…ArA_l,A_{l+1}, \\dots A_rAl​,Al+1​,…Ar​ 中每个都减去 111。 请求出使得 AiA_iAi​ 中元素全部 ≤0\\le 0≤0 所需的最小代价。 1≤n≤105,1≤Ai,Bi≤1091 \\le n \\le 10^5, 1 \\le A_i,B_i \\le 10^91≤n≤105,1≤Ai​,Bi​≤109。 题目分析： 考虑操作 [l,r][l,r][l,r] 的代价是这段区间 BBB 的最大值，也就是说设最大值为 BxB_xBx​，那么我们选择的区间一定是以 BxB_xBx​ 为最大值的极长的一段区间，对应笛卡尔树中 xxx 的子树，所以我们的一次操作就相当于花费 BxB_xBx​ 的代价，将 xxx 子树中所有点的 AAA 值减 111。 一个显然的 dpdpdp 就是设 dp[i][j]dp[i][j]dp[i][j] 表示以 iii 为根的子树中，对于所有 iii 子树内的点 xxx 都有 Ax≤jA_x \\le jAx​≤j 的最小代价。 转移是简单的： dp[i][j]=min⁡k=max⁡(j,Ai){dp[ls[i]][k]+dp[rs[i]][k]+(k−j)Bi}=−Bi×j+min⁡k=max⁡(j,Ai){dp[ls[i]][k]+dp[rs[i]][k]+k×Bi}\\begin{aligned} dp[i][j] &amp;= \\min_{k=\\max(j,A_i)} \\{dp[ls[i]][k] + dp[rs[i]][k] + (k-j) B_i\\} \\\\ &amp;= -B_i\\times j + \\min_{k=\\max(j,A_i)} \\{dp[ls[i]][k] + dp[rs[i]][k] + k \\times B_i\\} \\end{aligned} dp[i][j]​=k=max(j,Ai​)min​{dp[ls[i]][k]+dp[rs[i]][k]+(k−j)Bi​}=−Bi​×j+k=max(j,Ai​)min​{dp[ls[i]][k]+dp[rs[i]][k]+k×Bi​}​ 其中 kkk 的边界是由以下限制得来的： k≥jAi−(k−j)≥jk \\ge j \\\\ A_i - (k - j) \\ge j k≥jAi​−(k−j)≥j 其实看到这个 dpdpdp 状态就很有一种凸函数的感觉，所以打表之后会发现若将 dp[i][j]dp[i][j]dp[i][j] 视为一个关于 jjj 的函数，那么其是一个分段一次凸函数，即满足下图所示： 证明就是考虑几个分段一次凸函数相加依旧是一个分段一次凸函数即可。 考虑我们的转移对这个分段一次凸函数有什么影响，假设我们现在直接合并了 dp[ls[i]]dp[ls[i]]dp[ls[i]] 和 dp[rs[i]]dp[rs[i]]dp[rs[i]]。 就是将在 A[i]A[i]A[i] 之前的位置的图像抹平，在 A[i]A[i]A[i] 之后的位置的图像加入一条斜率为 B[i]B[i]B[i] 的一次函数。 然后再将所有位置加入一条斜率为 −B[i]-B[i]−B[i] 的一次函数。 所以可以发现其实我们每一次至多增加 O(1)O(1)O(1) 段，也就是说我们的段数为 O(n)O(n)O(n)。 上述过程如下图所示： 一个做法就是考虑使用可并堆维护每一个图像上的拐点和经过这个拐点之后一次函数斜率的变化量，堆内按拐点的 xxx 坐标从小到大排序。 维护变化量的主要原因是因为我们要支持加入斜率为 B[i]B[i]B[i] 和 −B[i]-B[i]−B[i] 的直线，如果暴力遍历所有的段然后加显然就炸了，不如直接维护变化量这样在某一个位置单点加入即可，以及这个时候我们合并两个 dpdpdp 值就直接堆的合并就可以实现斜率的相加。 代码实现的细节就是： 我们只需要维护出 dp[0]dp[0]dp[0] 处的值，其它的维护好斜率即可。 对于将某一段抹平这个操作，因为我们只有 O(n)O(n)O(n) 段所以可以暴力一段段地抹平，主要是这样可以直接维护出 dp[0]dp[0]dp[0] 的变化。 而对于增加斜率为 −B[i]-B[i]−B[i] 的直线对 dp[0]dp[0]dp[0] 的影响，可以考虑将增加斜率为 B[i]B[i]B[i] 的直线的操作放到序列的开头，这样直接扫过去就可以维护好对 dp[0]dp[0]dp[0] 的影响，也可以同时维护好对后面部分斜率的影响。","link":"/2023/09/22/ABC275Ex/"},{"title":"AtCoder Regular Contest 162","text":"【题解】AtCoder Regular Contest 162 A.Ekiden Race 题目描述： 有 nnn 个人参加了往返赛跑，每个人有一个编号 111 到 nnn。已知以下信息： 如果按照往路的成绩排序，那么任何两个人的成绩都不相同。同时第 iii 个人在往路中排名第 iii。 如果按照往返的成绩排序，那么任何两个人的成绩都不相同。同时第 iii 个人在往返中排名第 pip_ipi​。 如果復路的成绩最快，那么获得復路奖的人是復路成绩最快的人。 请计算有多少人可能得到了復路奖项。 有 TTT 个测试用例，请对于每个测试用例输出答案。 (翻译者注：往路指来回的第一段路程，復路指来回的第二段路程。) 2≤n≤1032 \\le n \\le 10^32≤n≤103 题目分析： 如果 aaa 在第一段路快于 bbb，而经过了第二段路之后 aaa 慢于 bbb，则必然有 aaa 第二段路慢于 bbb。 否则无法确定 a,ba,ba,b 的第二段路的快慢，也就是可以直接认为 a,ba,ba,b 都有可能。 直接这样判就可以了。 代码： 点击查看代码 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5+5;int a[N];int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); int ans = n+1; int tot = 0; for(int i=n; i&gt;=1; i--){ if(a[i] &lt; ans) ++tot; ans = min(ans,a[i]); } printf(&quot;%d\\n&quot;,tot); } return 0;} B.Insertion Sort 2 题目描述： 给定 1,2,...,N1,2,...,N1,2,...,N 的排列 P=(P1,P2,...,PN)P=(P_1,P_2,...,P_N)P=(P1​,P2​,...,PN​)。 最多进行 2×1032\\times 10^32×103 次操作，每次操作满足 1≤i≤N−1,0≤j≤N−21\\le i\\le N-1, 0\\le j\\le N-21≤i≤N−1,0≤j≤N−2，选取整数 i,ji,ji,j，从 PPP 中取出 (Pi,Pi+1)(P_i,P_{i+1})(Pi​,Pi+1​) 得到序列 Q=(Q1,Q2,...,QN−2)Q=(Q_1,Q_2,...,Q_{N-2})Q=(Q1​,Q2​,...,QN−2​)，则将 PPP 中 (Pi,Pi+1)(P_i,P_{i+1})(Pi​,Pi+1​) 替换成序列 QQQ 的 jjj 与 j+1j+1j+1 位置上的数，得到新的排列 P′P'P′。 判断是否能够通过这样的操作使 PPP 变成升序排列，如果可以，给出操作步骤。 2 ≤ N ≤ 1032\\ \\leq\\ N\\ \\leq\\ 10^32 ≤ N ≤ 103 题目分析： 一个显然的想法就是一个个数地确定，也就是先把 111 通过操作放到第一个，然后 222 放到第二个然后依次类推。 但是现在的有的一个问题就是如果我们现在要放 xxx，但是 xxx 是序列中的最后一个数就做不了这个操作了，可是我们可以做类似如下的操作：(n−2,n−1,n)(n-2,n-1,n)(n−2,n−1,n) →\\to→ (n−1,n,n−2)(n-1,n,n-2)(n−1,n,n−2) 这样 PnP_nPn​ 就不在最后了，我们就可以操作它了。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e3+5;vector&lt;pair&lt;int,int&gt; &gt; v;int n,a[N],b[N];void solve(int pos1,int pos2){ if(!(1 &lt;= pos1 &amp;&amp; pos1 &lt;= n-1)) return; if(!(0 &lt;= pos2 &amp;&amp; pos2 &lt;= n-2)) return; v.push_back({pos1,pos2}); int tot = 0; if(tot == pos2) b[++tot] = a[pos1],b[++tot] = a[pos1+1]; for(int i=1; i&lt;=n; i++){ if(i == pos1 || i == pos1 + 1) continue; b[++tot] = a[i]; if(tot == pos2) b[++tot] = a[pos1],b[++tot] = a[pos1+1]; } for(int i=1; i&lt;=n; i++) a[i] = b[i];}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=n; i++){ if(a[i] == i) continue; if(a[n] == i) solve(n-1,n-3); int pos = i; for(int j=i+1; j&lt;=n; j++){ if(a[j] == i) pos = j; } if(pos &gt; i) solve(pos,i-1); } if(a[n] != n) printf(&quot;No\\n&quot;); else{ printf(&quot;Yes\\n&quot;); printf(&quot;%d\\n&quot;,(int)v.size()); for(auto i : v) printf(&quot;%d %d\\n&quot;,i.first,i.second); } return 0;} C.Mex Game on Tree 题目描述： 有一棵 nnn 个节点且以 111 为根的数。 每个节点上有一个数表示颜色。 如果为 −1-1−1，表示没有填颜色。 否则，表示填的颜色。 Alice\\text{Alice}Alice 和 Bob\\text{Bob}Bob 轮流对没填颜色的节点填上 000 到 nnn（Alice\\text{Alice}Alice 先手）。 填完后，如果某个点和它的子树颜色的 mex\\mathrm{mex}mex 为 kkk，Alice\\text{Alice}Alice 胜，否则为 Bob\\text{Bob}Bob。 2 ≤ N ≤ 1032\\ \\leq\\ N\\ \\leq\\ 10^32 ≤ N ≤ 103 题目分析： BoB 的策略十分显然，就是填 kkk，所以只要让 Bob 走一步，那么 Alice 之前的所有布局就全没用了。 因为是考虑某一个子树，所以不妨对每一棵子树都求一下是不是可以使得它的 mex\\mathrm{mex}mex 为 kkk。 因为我们对每一棵子树都考虑了，所以若 Alice 走两步可以让某个子树变成合法，要么就是那棵子树走一步就可以合法，要么就是受到前一步的影响，而第二种情况显然 Bob 可以直接堵掉 Alice 的第二步，就结束了。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4+5;struct edge{ int nxt,to; edge(){} edge(int _nxt,int _to){ nxt = _nxt,to = _to; }}e[2 * N];int n,k,cnt,head[N],a[N];bool vis[N],ans;vector&lt;int&gt; v;void add_edge(int from,int to){ e[++cnt] = edge(head[from],to); head[from] = cnt;}void get_val(int now,int fath){ v.push_back(a[now]); for(int i=head[now]; i; i=e[i].nxt){ int to = e[i].to; if(to == fath) continue; get_val(to,now); }}void dfs(int now,int fath){ for(int i=head[now]; i; i=e[i].nxt){ int to = e[i].to; if(to == fath) continue; dfs(to,now); } get_val(now,fath); int flag = 0; for(auto i : v){ if(i == -1){ flag++; continue; } vis[i] = true; } int tmp = 0; while(vis[tmp]) ++tmp; if(flag &amp;&amp; tmp &lt; k){ ++tmp; while(vis[tmp]) ++tmp; } if(tmp == k &amp;&amp; flag &lt;= 1) ans = true; for(auto i : v){ if(i != -1) vis[i] = false; } v.clear();}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=2; i&lt;=n; i++){ int fa;scanf(&quot;%d&quot;,&amp;fa); add_edge(fa,i);add_edge(i,fa); } for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); dfs(1,0); if(ans) printf(&quot;Alice\\n&quot;); else printf(&quot;Bob\\n&quot;); cnt = 0; for(int i=1; i&lt;=n; i++) head[i] = 0; ans = false; } return 0;} D.Smallest Vertices 题目描述： 在本问题中，当我们提到有根有向树时，我们指的是所有边都指向从根到叶子的有根树。 给定一个使得其总和为 N−1N-1N−1 的非负整数序列 d=(d1,d2,…,dN)d=(d_1,d_2,\\ldots,d_N)d=(d1​,d2​,…,dN​)。 对于带编号从 111 到 NNN 的顶点，假设 111 是根，我们将其点度数定义为 did_idi​。 我们称满足以下条件的根付有向树为好树： 点 iii 的出度是 did_idi​。 此外，对于好树的顶点 vvv，定义 f(v)f(v)f(v) 为“包含顶点 vvv 的子树中的顶点（包括 vvv）的顶点编号的最小值”。我们将满足 f(v)=vf(v)=vf(v)=v 的顶点称为好顶点。 求好树中所有好顶点的总数，将其对 998244353998244353998244353 取模后的余数。 2 ≤ N ≤ 5002\\ \\leq\\ N\\ \\leq\\ 5002 ≤ N ≤ 500 0 ≤ di ≤ N−10\\ \\leq\\ d_i\\ \\leq\\ N-10 ≤ di​ ≤ N−1 d1 ≥ 1d_1\\ \\geq\\ 1d1​ ≥ 1 ∑i=1N di = N−1\\sum_{i=1}^N\\ d_i\\ =\\ N-1∑i=1N​ di​ = N−1 题目分析： 显然可以考虑对于每一个点作为好节点的方案数求和就是答案。 若 v=1v = 1v=1 或 dv=0d_v = 0dv​=0，则任意一个好树都是合法的，这个时候根据 pruferpruferprufer 序列，显然方案数就是： (n−2)!∏u(d1,u−1)!\\dfrac{(n-2)!}{\\prod_{u} (d_{1,u}-1)!} ∏u​(d1,u​−1)!(n−2)!​ 其中 di,jd_{i,j}di,j​ 表示以 iii 为根的时候 jjj 的度数。 否则的话，考虑以 vvv 为根的子树只能包含 [v,n][v,n][v,n] 这些点，但是好像除了这个就发现不了什么式子了，就不大能做。 所以不妨设 SSS 为 vvv 子树内的点的点集，看看这个时候的方案数是什么： (∣S∣−2)!∏u∈S(dv,u−1)!×(n−∣S∣+1−2)!∏u∉S(d1,u−1)!=(∣S∣−2)!(n−∣S∣−1)!d1dv∏u(du!)\\dfrac{(|S|-2)!}{\\prod\\limits_{u\\in S} (d_{v,u}-1)!} \\times \\dfrac{(n-|S|+1-2)!}{\\prod\\limits_{u\\not\\in S}(d_{1,u}-1)!} = \\dfrac{(|S|-2)!(n-|S|-1)!d_1d_v}{\\prod\\limits_u (d_u!)} u∈S∏​(dv,u​−1)!(∣S∣−2)!​×u∈S∏​(d1,u​−1)!(n−∣S∣+1−2)!​=u∏​(du​!)(∣S∣−2)!(n−∣S∣−1)!d1​dv​​ 第一个式子就是考虑 vvv 的子树的方案数，乘以其余点构成一棵树的方案数，其中在其余点构成的树中 vvv 所在子树充当一个叶子。 第二个式子就是考虑如下的事实： di,j={dji=jdj+1i≠jd_{i,j} = \\begin{cases} d_j &amp; i = j \\\\ d_j+1 &amp; i \\not= j \\end{cases} di,j​={dj​dj​+1​i=ji=j​ 所以带入就得到了第二个式子。 注意为了可以组成一棵树，一个隐形的限制就是：∑u∈Sdu=∣S∣−1\\sum\\limits_{u \\in S} d_u = |S| - 1u∈S∑​du​=∣S∣−1。 所以此时 dpdpdp 状态就相当显然了，dp[i][j][k]dp[i][j][k]dp[i][j][k] 表示大于等于 iii 的点，选择了 jjj 个点，dud_udu​ 之和为 kkk 的方案数。 这样就可以直接统计方案数，然后乘以上面的系数就可以得到答案。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 505;const int MOD = 998244353;int f[N][N][N],d[N],fac[N],inv[N];int power(int a,int b){ int res = 1; while(b){ if(b &amp; 1) res = res * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; } return res;}void add(int &amp;a,int b){ a = (a + b) % MOD;}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n;scanf(&quot;%lld&quot;,&amp;n); fac[0] = 1; for(int i=1; i&lt;=n; i++) fac[i] = fac[i-1] * i % MOD; inv[n] = power(fac[n],MOD-2); for(int i=n-1; i&gt;=0; i--) inv[i] = inv[i+1] * (i+1) % MOD; for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;d[i]); f[n+1][0][0] = 1; for(int i=n; i&gt;=1; i--){ for(int j=0; j&lt;=n; j++){ for(int k=0; k&lt;=n; k++){ add(f[i][j][k],f[i+1][j][k]); if(j-d[i]&gt;=0&amp;&amp;k-1&gt;=0) add(f[i][j][k],f[i+1][j-d[i]][k-1]); } } } int tmp = fac[n-2]; for(int i=1; i&lt;=n; i++){ if(i == 1) tmp = tmp * inv[d[i]-1] % MOD; else tmp = tmp * inv[d[i]] % MOD; } int mul = 1,ans = 0; for(int i=1; i&lt;=n; i++) mul = mul * inv[d[i]] % MOD; for(int i=1; i&lt;=n; i++){ //统计 i 为好节点的贡献 if(i == 1 || d[i] == 0){ add(ans,tmp);// printf(&quot;%lld %lld\\n&quot;,i,tmp); continue; } for(int j=1; j&lt;=n; j++){ //枚举 [i,n] 选择了多少个节点 int sum_d = j - 1; if(sum_d-d[i]&gt;=0 &amp;&amp; j-1&gt;=0 &amp;&amp; j-2&gt;=0 &amp;&amp; n-j-1&gt;=0) add(ans,f[i+1][sum_d-d[i]][j-1] * d[1] %MOD* d[i] %MOD* fac[j-2] %MOD* fac[n-j-1]%MOD * mul%MOD); }// printf(&quot;%lld %lld\\n&quot;,i,ans);// ans = 0; } printf(&quot;%lld\\n&quot;,ans); return 0;} E.Strange Constraints 题目描述： 给定长度为 nnn 的序列 AAA，求序列 BBB 的个数模 998244353998244353998244353，满足以下条件： 值域 [1,n][1, n][1,n]。 iii 的个数不超过 AiA_iAi​。 BiB_iBi​ 的个数不超过 AiA_iAi​。 1≤n≤5001 \\le n \\le 5001≤n≤500。 题目分析： 考虑设 did_idi​ 表示数 iii 出现的次数，则题目条件可以转化为： di≤Aid_i \\le A_idi​≤Ai​ 若 iii 可以放在位置 jjj，则必然满足 di≤Ajd_i \\le A_jdi​≤Aj​ 设 ci=∑j=1n[i≤Aj]c_i = \\sum_{j=1}^n [i \\le A_j]ci​=∑j=1n​[i≤Aj​]，则 cic_ici​ 就代表出现次数为 iii 的数可选的种类数，以及出现次数为 iii 的数在 BBB 中可以放的位置数。 所以这个东西直接 dpdpdp 去做就很简单了，也就是设 dp[i][j][k]dp[i][j][k]dp[i][j][k] 表示考虑了出现次数大于等于 iii 的数，总共选择了 jjj 种数，放在 BBB 的 kkk 个位置上。 转移就是枚举出现次数等于 iii 的数有 xxx 个： dp[i+1][j][k]×(ci−jx)×(ci−k)!(i!)x(ci−k−ix)!→dp[i][j+x][k+ix]dp[i+1][j][k] \\times \\binom{c_i-j}{x} \\times \\dfrac{(c_i-k)!}{(i!)^x(c_i-k-ix)!} \\to dp[i][j+x][k+ix] dp[i+1][j][k]×(xci​−j​)×(i!)x(ci​−k−ix)!(ci​−k)!​→dp[i][j+x][k+ix] 转移的两个系数：第一个就是选择哪些数，第二个就是这些数放在哪些位置。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 505;const int MOD = 998244353;int f[N][N][N],fac[N],inv[N],a[N],c[N];int binom(int n,int m){ if(n &lt; m || n &lt; 0 || m &lt; 0) return 0; return fac[n] * inv[m] % MOD * inv[n-m]%MOD; }int power(int a,int b){ int res = 1; while(b){ if(b &amp; 1) res = res * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; } return res;}void add(int &amp;a,int b){ a = (a + b)%MOD;}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n;scanf(&quot;%lld&quot;,&amp;n); fac[0] = 1; for(int i=1; i&lt;=n; i++) fac[i] = fac[i-1] * i % MOD; inv[n] = power(fac[n],MOD-2); for(int i=n-1; i&gt;=0; i--) inv[i] = inv[i+1] * (i+1) % MOD; for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=0; i&lt;=n; i++){ for(int j=1; j&lt;=n; j++){ if(a[j] &gt;= i) c[i]++; } } f[n+1][0][0] = 1; for(int i=n; i&gt;=1; i--){ for(int j=0; j*i&lt;=n; j++){ if(j &gt; c[i]) break; for(int k=0; k&lt;=n; k++){ if(k &gt; c[i]) break; for(int x=0; x*i&lt;=n; x++){ if(k + i * x &gt; c[i]) break; if(j+x&lt;=n &amp;&amp; k+i*x&lt;=n &amp;&amp; c[i]-j&gt;=0 &amp;&amp; c[i]-k&gt;=0 &amp;&amp; c[i]-k-i*x&gt;=0) add(f[i][j+x][k+i*x],f[i+1][j][k] * binom(c[i]-j,x) %MOD* fac[c[i]-k] %MOD* power(inv[i],x) %MOD* inv[c[i]-k-i*x]%MOD); } } } } int ans = 0; for(int i=1; i&lt;=n; i++) add(ans,f[1][i][n]); printf(&quot;%lld\\n&quot;,ans); return 0;}","link":"/2023/09/08/AtCoder-Regular-Contest-162/"},{"title":"CF643F Bears and Juice","text":"【题解】CF643F Bears and Juice 模拟赛的 T2，一车人过，感觉十分震撼。 题目描述： 有 nnn 只熊和 ppp 张床，还有若干个无限大的酒桶（至少一个），其中恰好只有一个酒桶里装着酒，其它酒桶里都装着果汁。 熊一开始不知道哪桶里面是酒，于是进行了一次挑战，目标是找到哪桶里面是酒。 每天，每只还醒着的熊会选择一个酒桶的子集（可以为空集），并且喝下选择的酒桶中的一小杯饮料。 如果一只熊喝到了酒，它会上床睡觉一直到挑战结束。但一张床只能容纳一只熊，如果有熊没有床睡觉，则挑战失败。 如果 iii 天后至少还剩一只熊没睡觉，且能根据前面的线索推理出哪桶里面是酒，则挑战成功。 请你求出对于 i∈[1,q]i \\in [1,q]i∈[1,q]，在可以确保挑战成功的情况下，最多有多少个酒桶。 设对于 iii 的答案为 RiR_iRi​，你需要求出 xor⁡i=1q((i×Ri) mod 232)\\operatorname{xor}_{i=1}^q ((i \\times R_i) \\bmod 2^{32})xori=1q​((i×Ri​)mod232)。 n≤109n \\le 10^9n≤109，p≤130p \\le 130p≤130，q≤2×106q \\le 2 \\times 10^6q≤2×106。 题目分析： 感觉这个题好高妙啊。 考虑通过【信息】的角度理解这个问题，我们知道的信息其实只有：熊睡没睡，如果睡了则在哪一天睡的。 以 n=3，p=2，k=1n=3，p=2，k=1n=3，p=2，k=1 这个样例为例，我们可以得到如下七种信息： 设 (i,j)(i,j)(i,j) 表示熊 iii 在第 jjj 天睡了。 熊都没有睡 (1,1)(1,1)(1,1) (1,1)(2,1)(1,1)(2,1)(1,1)(2,1) (1,1)(3,1)(1,1)(3,1)(1,1)(3,1) (2,1)(3,1)(2,1)(3,1)(2,1)(3,1) (2,1)(2,1)(2,1) (3,1)(3,1)(3,1) 如果要使得确定的数量仅可能多，一个想法就是让每一种信息对应一种酒的放置方案，而样例也恰好是如此。 有这种构造：如果在第 iii 条信息中，熊 jjj 在第 kkk 天睡了，则让熊 jjj 在第 kkk 天喝第 iii 个酒桶。 这样可以显然发现，如果恰好满足第 iii 条信息的情况，则酒必然是在第 iii 个酒桶中。 以上述为例，则三个熊喝酒桶的情况如下： 设 (i,j)(i,j)(i,j) 表示第 iii 天喝了酒 jjj。 (1,2)(1,3)(1,4)(1,2)(1,3)(1,4)(1,2)(1,3)(1,4) (1,3)(1,5)(1,6)(1,3)(1,5)(1,6)(1,3)(1,5)(1,6) (1,4)(1,5)(1,7)(1,4)(1,5)(1,7)(1,4)(1,5)(1,7) 所以也就是说，信息的数量与酒桶的最多数量是相等的，假设有 ddd 天，则显然： Rd=∑i=0min⁡(p,n−1)(ni)diR_d = \\sum_{i=0}^{\\min(p,n-1)} \\binom{n}{i} d^i Rd​=i=0∑min(p,n−1)​(in​)di 其实就是枚举哪头熊在哪一天睡/不睡的方案数。 这里就是枚举了 iii 头熊睡了，每头熊都可以在 ddd 天其中之一睡觉，iii 头熊可以是 nnn 个里面的任意 iii 头。 所以我们的答案就很显然了： xori=1q(i×∑j=0min⁡(p,n−1)(nj)ijmod 232)\\text{xor}_{i=1}^q (i \\times \\sum_{j=0}^{\\min(p,n-1)} \\binom{n}{j} i^j \\mod 2^{32}) xori=1q​(i×j=0∑min(p,n−1)​(jn​)ijmod232) 直接暴力枚举复杂度 O(pq)O(pq)O(pq) 可以通过。 但是注意到这个组合数就很难算，因为组合数需要计算 (j!)−1mod 232(j!)^{-1} \\mod 2^{32}(j!)−1mod232，而这个东西可能并不存在逆元。 有以下三种解决这个问题的方法： 方法一： 考虑： (ni)=ni‾i!=n×(n−1)×⋯×(n−i+1)1×2×⋯×i\\binom{n}{i} = \\frac{n^{\\underline{i}}}{i!} = \\frac{n \\times (n-1) \\times \\cdots \\times (n-i+1)}{1 \\times 2 \\times \\cdots \\times i} (in​)=i!ni​​=1×2×⋯×in×(n−1)×⋯×(n−i+1)​ 而组合数一定是一个整数，也就是说分子一定是分母的倍数，就可以考虑用分子的每一个数与分母的每一个数，求它们的 gcd⁡\\gcdgcd，然后上下同时除以这个 gcd⁡\\gcdgcd，最后一定会将分母约成 111，就不需要逆元这个问题了。 方法二： 考虑： (ni)=A×2aB×2b\\binom{n}{i} = \\frac{A \\times 2^{a}}{B \\times 2^b} (in​)=B×2bA×2a​ 也就是把 222 的幂提出来，因为分子一定是分母的倍数，即 a&gt;ba &gt; ba&gt;b，所以可以直接将 222 的幂丢出去，即求： AB×2a−b\\frac{A}{B} \\times 2^{a-b} BA​×2a−b 因为我们将 222 的幂全部提出来了，即 gcd⁡(B,232)=1\\gcd(B,2^{32}) = 1gcd(B,232)=1，所以就可以求得 BBB 的逆元了，使用 exgcd 求解即可。 方法三： exLucas，但是太难写了。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e6+5;unsigned int C[N],a[N],b[N];int n,p,q;unsigned int get(int x){ for(int i=1; i&lt;=x; i++){ a[i] = n - i + 1; b[i] = i; } for(int i=1; i&lt;=x; i++){ for(int j=1; j&lt;=x; j++){ int gc = __gcd(a[i],b[j]); a[i] /= gc,b[j] /= gc; } } unsigned int ans = 1; for(int i=1; i&lt;=x; i++) ans = ans * a[i]; return ans;}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;p,&amp;q); for(int i=0; i&lt;=min(p,n-1); i++) C[i] = get(i);// for(int i=0; i&lt;=min(p,n-1); i++) printf(&quot;%u\\n&quot;,C[i]); long long ans = 0; for(int i=1; i&lt;=q; i++){ unsigned int tmp = 0; unsigned int k = i; for(int j=0; j&lt;=min(p,n-1); j++,k=(unsigned int)k*i){ tmp = tmp + C[j] * k; } ans = ans ^ tmp; } printf(&quot;%lld\\n&quot;,ans); return 0;}","link":"/2023/09/20/CF643F/"},{"title":"CF840C On the Bench","text":"【题解】CF840C On the Bench 题目描述： 给定一个序列 a(ai≤109)a(a_i\\le 10^9)a(ai​≤109)，长度为 n(n≤300)n(n\\le 300)n(n≤300)。 试求有多少 111 到 nnn 的排列 pip_ipi​，满足对于任意的 2≤i≤n2\\le i\\le n2≤i≤n 有 api−1×apia_{p_{i-1}}\\times a_{p_i}api−1​​×api​​ 不为完全平方数，答案对 109+710^9+7109+7 取模。 题目分析： （我竟然场切了，太离谱了） 如果对于这个题面硬做的话，其实就是若 ai×aja_i \\times a_jai​×aj​ 不为完全平方数，则连边 (i,j)(i,j)(i,j)。 问题就转化为了给定一张图，求其哈密顿路的条数，这个东西显然不能做。 所以也就是说这张图必然存在某些特殊性质。 考虑若 A×BA \\times BA×B 为完全平方数那么意味着什么呢，考虑将 A,BA,BA,B 写成它的标准分解式也就是 A=∏piaiA = \\prod p_i^{a_i}A=∏piai​​，B=∏pibiB = \\prod p_i^{b_i}B=∏pibi​​，这样 A×B=∏piai+biA \\times B = \\prod p_i^{a_i + b_i}A×B=∏piai​+bi​​，其为完全平方数也就是对于每一个 ai+bia_i + b_iai​+bi​ 其均为偶数，即 ai≡bi(mod2)a_i \\equiv b_i \\pmod 2ai​≡bi​(mod2)。 所以我们可以一开始就对所有的数分解为其标准分解式，然后将其指数模 222，这样的问题就转化为了相邻两个位置上的数不相等。 可以考虑一种一种数地插入，然后 dpdpdp 去统计这个过程的方案数。 也就是设 dpi,jdp_{i,j}dpi,j​ 表示插入了前 iii 种数，有 jjj 个位置存在相邻两个位置的数相等。 转移就是考虑新加入的这一种数，会将多少个原本相邻且相等的位置占据，又会产生多少个相邻且相等的位置，带上一些组合系数去转移即可。 可以发现当我们确定了当前新加入的数内部会造成多少个相邻且相等的位置时，我们就相当于将其分成了固定的几段，也就是可以视为几个小球插入到序列里。 因为所有的数的出现次数之和为 nnn，所以复杂度为 O(n3)O(n^3)O(n3)。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 305;const int MOD = 1e9+7;int a[N],b[N],tot,dp[N][N],pre[N],inv[N],fac[N];int power(int a,int b){ int res = 1; while(b){ if(b &amp; 1) res = res * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; } return res;}int binom(int n,int m){ if(n &lt; m || n &lt; 0 || m &lt; 0) return 0; return fac[n] * inv[m] %MOD * inv[n-m] % MOD;}int get(int x){ int tmp = 1; for(int i=2; i*i&lt;=x; i++){ int cnt = 0; while(x % i == 0){ x /= i,++cnt; } if(cnt &amp; 1) tmp = tmp * i; } if(x &gt; 1) tmp = tmp * x; return tmp;}void add(int &amp;a,int b){ a = (a + b) % MOD;}signed main(){ int n;scanf(&quot;%lld&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); bool flag = false; for(int i=1; i&lt;=n; i++){ if(a[i] == 0) flag = true; } if(flag){ if(n == 1) printf(&quot;1\\n&quot;); else printf(&quot;0\\n&quot;); return 0; } for(int i=1; i&lt;=n; i++) a[i] = get(a[i]); sort(a+1,a+n+1); int sz = 1,pos = 1; for(int i=2; i&lt;=n; i++){ if(a[i] == a[pos]) ++sz; else b[++tot] = sz,sz = 1,pos = i; } b[++tot] = sz; for(int i=1; i&lt;=tot; i++) pre[i] = pre[i-1] + b[i]; fac[0] = 1; for(int i=1; i&lt;=n; i++) fac[i] = (fac[i-1] * i)%MOD; inv[n] = power(fac[n],MOD-2); for(int i=n-1; i&gt;=0; i--) inv[i] = (inv[i+1] * (i+1)) % MOD; dp[0][0] = 1; for(int i=0; i&lt;tot; i++){ for(int j=0; j&lt;=pre[i]+1; j++){ if(!dp[i][j]) continue; for(int k=0; k&lt;=b[i+1]-1; k++){ //i 新形成了 k 个 int p = (b[i+1]-1) - k + 1; //相当于要放 p 个物品 int tmp = binom(b[i+1]-1,p-1) * fac[b[i+1]] % MOD; //阶乘的原因是题目的方案数不同顺序算不同的 for(int x=0; x&lt;=j; x++){ //断掉之前的 x 个，即钦定有 x 个放在特殊位置，p - x 个放在不特殊地位置 add(dp[i+1][j+k-x], dp[i][j] * binom(j,x) % MOD * binom(pre[i] + 1 - j,p-x) % MOD * tmp %MOD); } } } } printf(&quot;%lld\\n&quot;,dp[tot][0]); return 0;}","link":"/2023/09/19/CF840C/"},{"title":"DP选练（23.9.11 - 23.9.12）","text":"【题解】DP选练（23.9.11 - 23.9.12） 一些写过题解的题我就直接挂连接了。 [NOIP2018 提高组] 货币系统 题目描述： 在网友的国度中共有 nnn 种不同面额的货币，第 iii 种货币的面额为 a[i]a[i]a[i]，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 nnn、面额数组为 a[1..n]a[1..n]a[1..n] 的货币系统记作 (n,a)(n,a)(n,a)。 在一个完善的货币系统中，每一个非负整数的金额 xxx 都应该可以被表示出，即对每一个非负整数 xxx，都存在 nnn 个非负整数 t[i]t[i]t[i] 满足 a[i]×t[i]a[i] \\times t[i]a[i]×t[i] 的和为 xxx。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 xxx 不能被该货币系统表示出。例如在货币系统 n=3n=3n=3, a=[2,5,9]a=[2,5,9]a=[2,5,9] 中，金额 1,31,31,3 就无法被表示出来。 两个货币系统 (n,a)(n,a)(n,a) 和 (m,b)(m,b)(m,b) 是等价的，当且仅当对于任意非负整数 xxx，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 现在网友们打算简化一下货币系统。他们希望找到一个货币系统 (m,b)(m,b)(m,b)，满足 (m,b)(m,b)(m,b) 与原来的货币系统 (n,a)(n,a)(n,a) 等价，且 mmm 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 mmm。 【数据范围】 对于 100%100\\%100% 的数据，满足 1≤T≤20,n,a[i]≥11 ≤ T ≤ 20, n,a[i] ≥ 11≤T≤20,n,a[i]≥1。 题目分析： 一个结论：bbb 必然为 aaa 除去其中的部分元素得到。 考虑如果 bbb 中拥有 aaa 没有的元素，如果这个元素可以被表示出来那么多出这个元素是没有意义的，如果这个元素不可以被表示出来那么这个元素会多表示出一些数。 所以我们只需要判断 aaa 中哪些元素会被内部的元素表示出，然后将这些元素删除即可，这个直接做一次背包就可以求得。 [CSP-S2020] 函数调用 题目描述： 函数是各种编程语言中一项重要的概念，借助函数，我们总可以将复杂的任务分解成一个个相对简单的子任务，直到细化为十分简单的基础操作，从而使代码的组织更加严密、更加有条理。然而，过多的函数调用也会导致额外的开销，影响程序的运行效率。 某数据库应用程序提供了若干函数用以维护数据。已知这些函数的功能可分为三类： 将数据中的指定元素加上一个值； 将数据中的每一个元素乘以一个相同值； 依次执行若干次函数调用，保证不会出现递归（即不会直接或间接地调用本身）。 在使用该数据库应用时，用户可一次性输入要调用的函数序列（一个函数可能被调用多次），在依次执行完序列中的函数后，系统中的数据被加以更新。某一天，小 A 在应用该数据库程序处理数据时遇到了困难：由于频繁而低效的函数调用，系统在执行操作时进入了无响应的状态，他只好强制结束了数据库程序。为了计算出正确数据，小 A 查阅了软件的文档，了解到每个函数的具体功能信息，现在他想请你根据这些信息帮他计算出更新后的数据应该是多少。 【数据范围】 测试点编号 n,m,Q≤n, m, Q \\len,m,Q≤ ∑Cj\\sum C_j∑Cj​ 其他特殊限制 19∼2019 \\sim 2019∼20 10510^5105 ≤106\\le 10^6≤106 无 对于所有数据：0≤ai≤1040 \\le a_i \\le 10^40≤ai​≤104，Tj∈{1,2,3}T_j \\in \\{1,2,3\\}Tj​∈{1,2,3}，1≤Pj≤n1 \\le P_j \\le n1≤Pj​≤n，0≤Vj≤1040 \\le V_j \\le 10^40≤Vj​≤104，1≤gk(j)≤m1 \\le g^{(j)}_k \\le m1≤gk(j)​≤m，1≤fi≤m1 \\le f_i \\le m1≤fi​≤m。 题目分析： 一个想法就是倒序操作，因为注意到如果有以下四个操作：+2,×4,+3,×5+2,\\times 4,+3,\\times 5+2,×4,+3,×5 那么 +2+2+2 贡献了 4×54 \\times 54×5 次，+3+3+3 贡献了 555 次，也就是加法操作的贡献次数等于其后面执行的乘法的乘积。 这样直接建图跑拓扑序，再拼点部分分就有了 757575 分。 这种类型的题如果想要快速维护，一个显然的想法就是求出每一个操作的操作次数，这样就直接跑一遍拓扑序就可以得到答案。 但是这样显然不行，因为乘法操作会对加法操作产生影响，但是我们可以将这个影响化为等次数的操作，也就是后面的 ×x\\times x×x 操作，我们将其看作这个加法操作需要执行 xxx 次。 这样我们就可以得到加法的等效操作次数，这样直接跑一遍拓扑序然后将这个等效次数每次向下传递就好了。 现在的一个问题就是我们需要知道到底乘了多少，才能得到等效操作次数，这个东西可以直接维护 mulimul_imuli​ 表示跑完了 iii 点开始的拓扑序之后，对乘法造成的贡献为 ×muli\\times mul_i×muli​，建反图跑拓扑序这个东西就可以被维护出来。 注意我们要求倒叙操作。 [APIO2010] 特别行动队 题目描述： 你有一支由 nnn 名预备役士兵组成的部队，士兵从 111 到 nnn 编号，你要将他们拆分成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号应该连续，即为形如 (i,i+1,⋯i+k)(i, i + 1, \\cdots i + k)(i,i+1,⋯i+k)的序列。所有的队员都应该属于且仅属于一支特别行动队。 编号为 iii 的士兵的初始战斗力为 xix_ixi​ ，一支特别行动队的初始战斗力 XXX 为队内士兵初始战斗力之和，即 X=xi+xi+1+⋯+xi+kX = x_i + x_{i+1} + \\cdots + x_{i+k}X=xi​+xi+1​+⋯+xi+k​。 通过长期的观察，你总结出对于一支初始战斗力为 XXX 的特别行动队，其修正战斗力 X′=aX2+bX+cX'= aX^2+bX+cX′=aX2+bX+c，其中 a, b, ca,~b,~ca, b, c 是已知的系数（a&lt;0a &lt; 0a&lt;0）。 作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队的修正战斗力之和最大。试求出这个最大和。 对于 100%100\\%100% 的数据，1≤n≤1061 \\leq n \\leq 10^61≤n≤106，−5≤a≤−1-5 \\leq a \\leq -1−5≤a≤−1，−107≤b≤107-10^7 \\leq b \\leq 10^7−107≤b≤107，−107≤c≤107-10^7 \\leq c \\leq 10^7−107≤c≤107，1≤xi≤1001 \\leq x_i \\leq 1001≤xi​≤100。 题目分析： 这个题显然需要用 dpdpdp 来做，可以设 dpidp_idpi​ 表示考虑了前 iii 个士兵战斗力之和的最大值，转移就是枚举最后一段是什么，为了方便记 si=∑j=1iajs_i = \\sum_{j=1}^i a_jsi​=∑j=1i​aj​： dpi=max⁡j=0i−1{dpj+a(si−sj)2+b(si−sj)+c}dp_i = \\max\\limits_{j=0}^{i-1}\\{dp_j + a(s_i - s_j)^2 + b(s_i - s_j) + c\\} dpi​=j=0maxi−1​{dpj​+a(si​−sj​)2+b(si​−sj​)+c} 这个东西就给人一种可以斜率优化的感觉，所以拆拆式子看看是不是可以： dpi=dpj+asi2−2asisj+asj2+bsi−bsj+cdpj+asj2−bsj=dpi−asi2−bsi−c+2asisjdp_i = dp_j + as_i^2 - 2as_is_j + as_j^2 + bs_i - bs_j + c \\\\ dp_j + as_j^2 - bs_j = dp_i - as_i^2 - bs_i - c + 2as_is_j dpi​=dpj​+asi2​−2asi​sj​+asj2​+bsi​−bsj​+cdpj​+asj2​−bsj​=dpi​−asi2​−bsi​−c+2asi​sj​ 这个东西就可以化简为 y=kx+by = kx + by=kx+b 的形式，其中： y=dpj+asj2−bsjk=2asix=sjb=dpi−asi2−bsi−c\\begin{aligned} y &amp;= dp_j + as_j^2 - bs_j \\\\ k &amp;= 2as_i \\\\ x &amp;= s_j \\\\ b &amp;= dp_i - as_i^2-bs_i-c \\end{aligned} ykxb​=dpj​+asj2​−bsj​=2asi​=sj​=dpi​−asi2​−bsi​−c​ 所以如果我们将所有的 (x,y)(x,y)(x,y) 拿出来放到二维平面上，这个东西就相当于拿一条斜率为 kkk 的直线去切这些点，使得其 yyy 轴的截距最大。 使得截距最大的点一定是在上凸包上，所以可以直接维护上凸包，而我们在枚举的过程中斜率一定单调递增，所以可以直接单调队列维护一下凸包就可以了。 [NOI2015] 寿司晚宴 题目描述： 为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。 在晚宴上，主办方为大家提供了 n−1n−1n−1 种不同的寿司，编号 1,2,3,…,n−11,2,3,\\ldots,n-11,2,3,…,n−1，其中第 iii 种寿司的美味度为 i+1i+1i+1。（即寿司的美味度为从 222 到 nnn） 现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 G 品尝的寿司种类中存在一种美味度为 xxx 的寿司，小 W 品尝的寿司中存在一种美味度为 yyy 的寿司，而 xxx 与 yyy 不互质。 现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 ppp 取模）。注意一个人可以不吃任何寿司。 2≤n≤500,0&lt;p≤1092 \\le n\\le 500,0 &lt; p \\le 10^92≤n≤500,0&lt;p≤109 题目分析： 互质就是 gcd(a,b)=1gcd(a,b) = 1gcd(a,b)=1，这个东西放到质因数分解的形势下就是没有公共的质因数。 这样的话当 nnn 比较小的时候就直接记录两个人分别选了哪些质因数就好了。 当 nnn 比较大的时候直接记录就炸了，但是我们知道一个数大于 n\\sqrt{n}n​ 的质因子只会有最多一个，所以可以按照这个质因子分类讨论。 也就是将大于 n\\sqrt{n}n​ 的质因子相同的数看作一组，这样一组只能被第一个人选择或者只能被第二个人选择，可以分别做 dpdpdp 记录小于 n\\sqrt{n}n​ 的质因子的选择情况，然后最后合并在一起就好了。 较小的质因子我们只需要取到前 888 个质数，所以时间复杂度为 O(216n)O(2^{16}n)O(216n) [NOIP2018 普及组] 摆渡车 题目描述： 有 nnn 名同学要乘坐摆渡车从人大附中前往人民大学，第 iii 位同学在第 tit_iti​ 分钟去 等车。只有一辆摆渡车在工作，但摆渡车容量可以视为无限大。摆渡车从人大附中出发、 把车上的同学送到人民大学、再回到人大附中（去接其他同学），这样往返一趟总共花费 mmm 分钟（同学上下车时间忽略不计）。摆渡车要将所有同学都送到人民大学。 凯凯很好奇，如果他能任意安排摆渡车出发的时间，那么这些同学的等车时间之和最小为多少呢？ 注意：摆渡车回到人大附中后可以即刻出发。 n≤500,m≤100,0≤ti≤4×106n ≤ 500, m ≤ 100, 0 ≤ t_i ≤ 4 \\times 10^6n≤500,m≤100,0≤ti​≤4×106。 题目分析： 首先一个显然的结论就是，一个人一定是选择到达时间最近的摆渡车被送走，所以考虑如果我们已经知道了摆渡车出发的时间 T1,T2,T3,⋯ ,TkT_1,T_2,T_3,\\cdots,T_kT1​,T2​,T3​,⋯,Tk​，要求 Ti−Ti−1≥mT_i - T_{i-1} \\ge mTi​−Ti−1​≥m，那么最小的等车时间是多少。 考虑如果 Tp≤ti≤Tp+1T_p \\le t_i \\le T_{p+1}Tp​≤ti​≤Tp+1​，那么 iii 的等车时间就是 Tp+1−tiT_{p+1} - t_iTp+1​−ti​，所以总的等车时间就是很好算的就是将贡献拆开统计，设 sis_isi​ 表示到达时间在 [1,i][1,i][1,i] 的同学个数，则： ∑i=1k(sTi−sTi−1)Ti−∑i=1nti\\sum_{i=1}^{k} (s_{T_i} - s_{T_{i-1}})T_i - \\sum_{i=1}^n t_i i=1∑k​(sTi​​−sTi−1​​)Ti​−i=1∑n​ti​ 需要注意的一点是这里默认 T0=0T_0 = 0T0​=0。 因为后面的 ttt 之和固定，所以最优化答案的时候不用管，只需要管前面的部分，而前面的部分显然就是枚举摆渡车在什么时候出发，也就是设 dpidp_idpi​ 表示摆渡车最后一次出发时候为 iii 的最小等车时间，转移就是枚举上一次出发的时间： dpi=min⁡j=0i−1{dpj+(si−sj)×i}dp_i = \\min \\limits_{j=0}^{i-1}\\{ dp_j + (s_i - s_j) \\times i \\} dpi​=j=0mini−1​{dpj​+(si​−sj​)×i} 这东西可以拆成斜率优化的形式，也就是： dpi=dpj+si×i−sj×idpj=dpi−si×i+sj×idp_i = dp_j + s_i \\times i - s_j \\times i \\\\ dp_j = dp_i - s_i \\times i + s_j \\times i dpi​=dpj​+si​×i−sj​×idpj​=dpi​−si​×i+sj​×i 可以令 y=dpjy = dp_jy=dpj​，k=ik = ik=i，x=sjx = s_jx=sj​，b=dpi−si×ib = dp_i - s_i \\times ib=dpi​−si​×i 所以直接维护凸包然后就好了，因为斜率递增可以单调队列维护。 [NOI2009] 诗人小G 题目描述： 小 G 是一个出色的诗人，经常作诗自娱自乐。但是，他一直被一件事情所困扰，那就是诗的排版问题。 一首诗包含了若干个句子，对于一些连续的短句，可以将它们用空格隔开并放在一行中，注意一行中可以放的句子数目是没有限制的。小 G 给每首诗定义了一个行标准长度（行的长度为一行中符号的总个数），他希望排版后每行的长度都和行标准长度相差不远。显然排版时，不应改变原有的句子顺序，并且小 G 不允许把一个句子分在两行或者更多的行内。在满足上面两个条件的情况下，小 G 对于排版中的每行定义了一个不协调度, 为这行的实际长度与行标准长度差值绝对值的 PPP 次方，而一个排版的不协调度为所有行不协调度的总和。 小 G 最近又作了几首诗，现在请你对这首诗进行排版，使得排版后的诗尽量协调（即不协调度尽量小），并把排版的结果告诉他。 数据规模与约定 测试点 TTT NNN LLL PPP 101010 ≤5\\le 5≤5 ≤105\\le 10^5≤105 ≤3×106\\le 3\\times 10^6≤3×106 ≤10\\le10≤10 所有句子的长度不超过 303030 。 题目分析： 一个显然的想法就是 dpdpdp 解决这个问题，我们 dpdpdp 所做的决策显然是每一行放哪些句子，也就是可以显然想到设 dpidp_idpi​ 表示考虑了前 iii 个句子最小的不协调度之和。 转移就是枚举最后这一行放了哪些句子，设 sis_isi​ 表示前 iii 个句子的和： dpi=min⁡j=0i−1{dpj+∣(si−sj)−(j−i−1)−L∣P}dp_i = \\min_{j=0}^{i-1} \\{ dp_j + \\left|(s_i-s_j)-(j-i-1)-L\\right|^P \\} dpi​=j=0mini−1​{dpj​+∣(si​−sj​)−(j−i−1)−L∣P} 转移需要注意的一点就是有空格，需要减去空格。 通过一些显然的观察或者是打表可以发现这个 dpdpdp 满足决策单调性，所以直接上套路做法就可以了。 [Cnoi2020] 线形生物 题目描述： 线形生物要从 111 号台阶走到 n+1n+1n+1 号台阶。 最开始，1,2,3,…,n1,2,3,\\ldots,n1,2,3,…,n 号台阶都有一条连向下一台阶的有向边 i→i+1i\\rightarrow i+1i→i+1。 之后 Cirno 加入了 mmm 条返祖边 ui→vi(ui≥vi)u_i \\rightarrow v_i (u_i \\ge v_i)ui​→vi​(ui​≥vi​)，它们构成了一个返祖图。 线形生物每步会 等概率地 选取当前台阶的一条出边并走向对应的台阶。 当走到 n+1n+1n+1 号台阶时，线形生物就会停止行走。 同时，Cirno 会统计线性生物总共走的步数，记作 δ\\deltaδ。 Cirno 想知道 E(δ)E(\\delta)E(δ)（即 δ\\deltaδ 的数学期望）对 998244353998244353998244353 取模后的结果。 对于 100%100\\%100% 的数据，保证：id∈{1,2,3,4,5}id \\in \\{1,2,3,4,5\\}id∈{1,2,3,4,5}，0&lt;n,m≤1060 &lt; n,m \\le 10^60&lt;n,m≤106，1≤vi≤ui≤n1 \\le v_i \\le u_i \\le n1≤vi​≤ui​≤n。 题目分析： 显然需要使用 dpdpdp 解决这个问题，这种问题的一种经典 dpdpdp 设法就是设 dpidp_idpi​ 表示从 iii 号台阶到 i+1i+1i+1 号台阶的期望步数，为了方便设 si,j=∑k=ijdpks_{i,j} = \\sum_{k=i}^j dp_ksi,j​=∑k=ij​dpk​，给定的 mmm 条边构成边集 EEE，则转移就是： dpi=1∣E∣+1+∑(i,j)∈Esj,i+1∣E∣+1dp_i = \\frac{1}{|E|+1} + \\sum_{(i,j) \\in E} \\frac{s_{j,i} + 1}{|E|+1} dpi​=∣E∣+11​+(i,j)∈E∑​∣E∣+1sj,i​+1​ 转移就是枚举下一步走的是什么，这样的转移就会造成自环的情况，所以考虑把这种情况移项直接搞掉： dpi=1∣E∣+1+∑(i,j)∈Esj,i−1+1∣E∣+1+∣E∣×dpi∣E∣+11∣E∣+1dpi=1∣E∣+1+∑(i,j)∈Esj,i−1∣E∣+1dpi=1+∑(i,j)∈Esj,i−1\\begin{aligned} dp_i &amp;= \\frac{1}{|E|+1} + \\sum_{(i,j) \\in E} \\frac{s_{j,i-1} + 1}{|E|+1} + \\frac{|E| \\times dp_i}{|E|+1} \\\\ \\frac{1}{|E|+1}dp_i &amp;= \\frac{1}{|E|+1} + \\sum_{(i,j) \\in E} \\frac{s_{j,i-1}}{|E|+1} \\\\ dp_i &amp;= 1 + \\sum_{(i,j) \\in E} s_{j,i-1} \\end{aligned} dpi​∣E∣+11​dpi​dpi​​=∣E∣+11​+(i,j)∈E∑​∣E∣+1sj,i−1​+1​+∣E∣+1∣E∣×dpi​​=∣E∣+11​+(i,j)∈E∑​∣E∣+1sj,i−1​​=1+(i,j)∈E∑​sj,i−1​​ 因为我们转移是从小到大枚举 iii，所以每次只需要维护以 i−1i-1i−1 为右端点的 sss 的值，可以使用树状数组增量维护。 最后我们的答案显然就是 ∑i=1ndpi\\sum \\limits_{i=1}^n dp_ii=1∑n​dpi​ [NOI2019] 回家路线 题目描述： 猫国的铁路系统中有 nnn 个站点，从 1−n1 - n1−n 编号。小猫准备从 111 号站点出发，乘坐列车回到猫窝所在的 nnn 号站点。它查询了能够乘坐的列车，这些列车共 mmm 班，从1−m1 - m1−m编号。小猫将在 000 时刻到达 111 号站点。对于 iii 号列车，它将在时刻 pip_ipi​ 从站点 xix_ixi​ 出发，在时刻 qiq_iqi​ 直达站点 yiy_iyi​，小猫只能在时刻 pip_ipi​ 上 iii 号列车，也只能在时刻 qiq_iqi​ 下 iii 号列车。小猫可以通过多次换乘到达 nnn 号站点。一次换乘是指对于两班列车，假设分别为 uuu号与 vvv 号列车，若 yu=xvy_u = x_vyu​=xv​ 并且 qu≤pvq_u \\leq p_vqu​≤pv​，那么小猫可以乘坐完 uuu 号列车后在 yuy_uyu​ 号站点等待 pv−qup_v - q_upv​−qu​ 个时刻，并在时刻 pvp_vpv​ 乘坐 vvv 号列车。 小猫只想回到猫窝并且减少途中的麻烦，对此它用烦躁值来衡量。 小猫在站点等待时将增加烦躁值，对于一次 t(t≥0)t (t \\geq 0)t(t≥0) 个时刻的等待，烦躁值将增加 At2+Bt+CAt^2 + Bt + CAt2+Bt+C，其中 A,B,CA, B,CA,B,C 是给定的常数。注意：小猫登上第一班列车前，即从 000 时刻起停留在 111 号站点的那些时刻也算作一次等待。 若小猫最终在时刻 zzz 到达 nnn 号站点，则烦躁值将再增加 zzz。 形式化地说，若小猫共乘坐了 kkk 班列车，依次乘坐的列车编号可用序列 s1,s2,⋯ ,sks_1, s_2, \\cdots , s_ks1​,s2​,⋯,sk​表示。该方案被称作一条可行的回家路线，当且仅当它满足下列两个条件： xs1=1x_{s1} = 1xs1​=1 , ysk=ny_{sk} = nysk​=n 对于所有 j(1≤j&lt;k)j (1 \\leq j &lt; k)j(1≤j&lt;k)，满足 ysj=xsj+1y_{sj} = x_{s_{j+1}}ysj​=xsj+1​​ 且 qsj≤psj+1q_{sj}\\leq p_{s_{j+1}}qsj​≤psj+1​​ 对于该回家路线，小猫得到的烦躁值将为： qsk+(A×ps12+B×ps1+C)+∑j=1k−1(A(psj+1−qsj)2+B(psj+1−qsj)+C)q_{s_k}+(A\\times p_{s_1}^2+B\\times p_{s_1}+C)+\\sum_{j=1}^{k-1}(A(p_{s_{j+1}}-q_{s_j})^2+B(p_{s_{j+1}}-q_{s_j})+C) qsk​​+(A×ps1​2​+B×ps1​​+C)+j=1∑k−1​(A(psj+1​​−qsj​​)2+B(psj+1​​−qsj​​)+C) 小猫想让自己的烦躁值尽量小，请你帮它求出所有可行的回家路线中，能得到的最 小的烦躁值。题目保证至少存在一条可行的回家路线。 对于所有测试点：2≤n≤105,1≤m≤2×105,0≤A≤10,0≤B,C≤106,1≤xi,yi≤n,xi≠yi,0≤pi&lt;qi≤1032\\le n\\le 10^5,1\\le m\\le 2\\times 10^5,0 \\le A \\le 10 , 0 \\le B, C \\le 10^6,1 \\le x_i, y_i \\le n , x_i \\neq y_i , 0 \\le p_i &lt; q_i \\le 10^32≤n≤105,1≤m≤2×105,0≤A≤10,0≤B,C≤106,1≤xi​,yi​≤n,xi​=yi​,0≤pi​&lt;qi​≤103。 题目分析： 至少感觉写出来 dpdpdp 之后就十分类似 [APIO2010] 特别行动队了。 显然我们可以考虑设 fi,jf_{i,j}fi,j​ 表示现在在 iii 号车站，时间为 jjj 的最少烦恼值，转移就是枚举是由之前的车站移动过来还是由之前的车站转移过来。 只有 O(m)O(m)O(m) 种有用的状态，以及第一种转移最多 O(m)O(m)O(m) 次，所以可以把重心放在第二种转移上，也就是下面这种形式： fi,j=min⁡{fi,k+A(k−j)2+B(k−j)+C}f_{i,j} = \\min\\{f_{i,k} + A(k-j)^2 + B(k-j) + C\\} fi,j​=min{fi,k​+A(k−j)2+B(k−j)+C} 这个东西就是一个斜率优化的形式，我就不推了。 但是注意到我们的转移顺序特别离谱，如果枚举 iii 进行转移就会出大问题，所以考虑对时间从小到大扫描线，然后每一次将第二维为枚举时间的状态更新，这样顺序就合法了。 以及如果我们直接从 fi,k→fi,jf_{i,k} \\to f_{i,j}fi,k​→fi,j​ 因为可能 fi,kf_{i,k}fi,k​ 这个状态本身就是等待一段时间得来的，所以要分别记录等待了一段时间的 dpdpdp 值和没有等待时间也就是只由第一种转移得来的 dpdpdp 值。 还有一点细节就是即使我们没有等待任何时间，对烦恼值也有 CCC 的贡献。 斜率优化就是对于每一个 iii 都维护一个凸包就好了，代码不是很难写。 [ZJOI2008] 骑士 题目描述： Z 国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。他们劫富济贫，惩恶扬善，受到社会各界的赞扬。 最近发生了一件可怕的事情，邪恶的 Y 国发动了一场针对 Z 国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的 Z 国又怎能抵挡的住 Y 国的军队。于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。 骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出征的。 战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况），并且，使得这支骑士军团最具有战斗力。 为了描述战斗力，我们将骑士按照 111 至 nnn 编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。 对于 100%100\\%100% 的测试数据，满足 1≤n≤1061\\le n \\le 10^61≤n≤106，每名骑士的战斗力都是不大于 10610^6106 的正整数。 题目分析： 我们其实就是要解决最大权独立集问题，一般图的话根本不能做。 但是注意我们这一张图是一个基环树，也就是我们可以使用处理环的一般方法断环为链，这样就变成了一棵树的问题，就可以随便做了。 断环为链其实就是直接钦定环上相邻的某两个点不能同时被选。 因为对于每一个环我们选择一对点即可，所以总时间复杂度 O(n)O(n)O(n)。 [NOIP2009 提高组] 最优贸易 题目描述： CCC 国有 nnn 个大城市和 mmm 条道路，每条道路连接这 nnn 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 mmm 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 111 条。 CCC 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。 商人阿龙来到 CCC 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 CCC 国 nnn 个城市的标号从 1∼n1\\sim n1∼n，阿龙决定从 111 号城市出发，并最终在 nnn 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 nnn 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 CCC 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。 假设 CCC 国有 555 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。 假设 1∼n1\\sim n1∼n 号城市的水晶球价格分别为 4,3,5,6,14,3,5,6,14,3,5,6,1。 阿龙可以选择如下一条线路：1→2→3→51\\to2\\to3\\to51→2→3→5，并在 222 号城市以 333 的价格买入水晶球，在 333 号城市以 555 的价格卖出水晶球，赚取的旅费数为 222。 阿龙也可以选择如下一条线路：1→4→5→4→51\\to4\\to5\\to4\\to51→4→5→4→5，并在第 111 次到达 555 号城市时以 111 的价格买入水晶球，在第 222 次到达 444 号城市时以 666 的价格卖出水晶球，赚取的旅费数为 555。 现在给出 nnn 个城市的水晶球价格，mmm 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 对于 100%100\\%100% 的数据，1≤n≤1000001\\leq n\\leq 1000001≤n≤100000，1≤m≤5000001\\leq m\\leq 5000001≤m≤500000，1≤x,y≤n1\\leq x,y\\leq n1≤x,y≤n，1≤z≤21\\leq z\\leq 21≤z≤2，$1\\leq $ 各城市的编号 ≤n\\leq n≤n。 水晶球价格 ≤100\\leq 100≤100。 题目分析： 一个显然的想法就是对图缩点，这样被缩到一起的点就可以相互到达，缩完点后的图就是一个 DAG。 要使得价值最大，我们显然就是要低买高卖，也就是可以考虑设 fif_ifi​ 表示从 111 到 iii 的路径中最低的水晶球价格是多少，然后考虑在 iii 点卖掉，可以设 gig_igi​ 表示从 111 到 iii 进行一次交易的最优贡献，然后每次更新 ggg 并向下传递即可。 最后的答案就是 gng_ngn​。 一些写过题解的题 可能以后会把题解直接搬过来吧，或者自己再写一份。 P6748 『MdOI R3』Fallen Lord [CSP-S2019] Emiya 家今天的饭 [九省联考 2018] 一双木棋 chess [八省联考 2018] 林克卡特树 不同子串个数 [六省联考 2017] 分手是祝愿","link":"/2023/09/12/DP-xuanlian-23-9-11-23-9-12/"},{"title":"Educational Codeforces Round 141（CF1783）","text":"【题解】Educational Codeforces Round 141（CF1783） 评价：educational A.Make it Beautiful 题目描述： 如果一个数组中存在一个数恰好等于该数前面所有数之和，那么这个数组就是丑的。如果一个数组不是丑的，就是美的。 比如说： 数组 [6,3,9,6][6, 3, 9, 6][6,3,9,6] 是丑的，因为 9=6+39 = 6 + 39=6+3 ； 数组 [5,5,7][5, 5, 7][5,5,7] 是丑的，因为第二个 5=55 = 55=5 。 数组 [8,4,10,14][8, 4, 10, 14][8,4,10,14] 是美的，因为 8≠08 \\ne 08=0 , 4≠84 \\ne 84=8 , 10≠8+410 \\ne 8 + 410=8+4 , 14≠8+4+1014 \\ne 8 + 4 + 1014=8+4+10 ，没有任何一个数等于它前面的数之和。 给定数组 aaa 满足 1≤a1≤a2≤⋯≤an≤1001 \\le a_1 \\le a_2 \\le \\dots \\le a_n \\le 1001≤a1​≤a2​≤⋯≤an​≤100 。 你可以任意调整元素的顺序，也可以不调整，使它变成一个美的数组。 题目分析： 我们可以考虑从大到小排序，这样除了最大值可能出问题，其它的都没问题。 而最大值就可以只保留一个在序列开头，其余的放到结尾即可。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100;int a[N];int main(){ int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); vector&lt;int&gt; v; for(int i=n; i&gt;=1; i--){ if(a[i] == a[n] &amp;&amp; i != n) continue; v.push_back(a[i]); } for(int i=n; i&gt;=1; i--){ if(a[i] == a[n] &amp;&amp; i != n) v.push_back(a[i]); } bool flag = true; int sum = 0; for(int i=0; i&lt;(int)v.size(); i++){ if(v[i] == sum) flag = false; sum += v[i]; } if(flag){ printf(&quot;YES\\n&quot;); for(int i=0; i&lt;(int)v.size(); i++) printf(&quot;%d &quot;,v[i]); printf(&quot;\\n&quot;); } else printf(&quot;NO\\n&quot;); } return 0;} B.Matrix of Differences 题目描述： 对于一个 n×nn\\times nn×n 的矩阵，对于每一对相邻（有公共边）的值 a,ba,ba,b，写下 ∣a−b∣|a-b|∣a−b∣（即 aaa 与 bbb 差的绝对值）。定义这个矩阵的美丽度为写下的不同的值的个数。以如下的矩阵为例： (1342)\\left(\\begin{matrix}1&amp;3\\\\4&amp;2\\end{matrix}\\right) (14​32​) 则所有相邻值的绝对值分别是 ∣1−3∣=2,∣1−4∣=3,∣3−2∣=1,∣4−2∣=2|1-3|=2,|1-4|=3,|3-2|=1,|4-2|=2∣1−3∣=2,∣1−4∣=3,∣3−2∣=1,∣4−2∣=2。共有 1,2,31,2,31,2,3 三种不同的值，则这个矩阵的美丽度为 333。 给你 ttt 次询问，每次询问给定一个正整数 nnn。输出任意一个 n×nn\\times nn×n 的矩阵，满足 1∼n21\\sim n^21∼n2 在矩阵中各出现一遍，并且该矩阵的美丽度最大。 1≤t≤49,2≤n≤501\\le t\\le49,2\\le n\\le501≤t≤49,2≤n≤50。 题目分析： 手摸了半天才搞出来的做法。 考虑 n−1n-1n−1 会怎么得到，只有可能是 1,n1,n1,n，那 n−2n-2n−2 呢？ 可以是 1,n−11,n-11,n−1 或者 2,n2,n2,n，为了构造的漂亮程度我们就不妨将 n,n−1n,n-1n,n−1 放到 111 的旁边，然后 222 继续放到下面，也就是下面这种方式： 1n−14n−5⋯n3n−4⋯2n−3⋯n−2⋯⋯\\begin{matrix} 1 &amp;n-1 &amp;4 &amp;n-5 &amp;\\cdots\\\\ n &amp;3 &amp;n-4 &amp;\\cdots\\\\ 2 &amp;n-3 &amp;\\cdots\\\\ n-2 &amp;\\cdots\\\\ \\cdots \\end{matrix} 1n2n−2⋯​n−13n−3⋯​4n−4⋯​n−5⋯⋯ 然后就可以过了。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100;int a[N][N];int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n;scanf(&quot;%d&quot;,&amp;n); int l = 1,r = n*n,tot = 0; for(int i=1; i&lt;=n; i++){ ++tot; int nx = i,ny = 1; while(nx &gt;= 1 &amp;&amp; ny &lt;= n){ if(tot &amp; 1) a[nx][ny] = l,l++; else a[nx][ny] = r,--r; nx --,ny ++; } } for(int i=2; i&lt;=n; i++){ ++tot; int nx = n,ny = i; while(nx &gt;= 1 &amp;&amp; ny &lt;= n){ if(tot &amp; 1) a[nx][ny] = l,l++; else a[nx][ny] = r,--r; nx --,ny ++; } } for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=n; j++){ printf(&quot;%d &quot;,a[i][j]); } printf(&quot;\\n&quot;); } } return 0;} C.Yet Another Tournament 题目描述： 有 nnn 个选手，编号为 111 至 nnn ，每两个选手对战时，编号大的将会胜利。 你可以准备 mmm 单位时间，每准备 aia_iai​ 时间就可以赢 iii 号选手。 按胜利的总次数排名，求你最高多少名。 题目分析： 一个想法就是我们直接将 aaa 最小到大排序，这样就可以赢尽可能多的场，看上去就是很好的排名。 但是我们的排名还与我们赢了哪些人有关，所以就有点不可做的样子。 注意到，当我们赢了 xxx 场就相当于要选择 n−xn-xn−x 个人多赢一场，然后寻找赢场数大于 xxx 的人的个数，而只有赢场数等于 xxx 的人会受到我们选择加一的影响，所以其实此时只需要判断能不能通过调整使得我们可以赢过胜场为 xxx 的人即可。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 5e5+5;int a[N],b[N];signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%lld&quot;,&amp;T); while(T--){ int n,m;scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]),b[i] = a[i]; sort(b+1,b+n+1); int pos = 0; for(int i=1; i&lt;=n; i++){ if(m - b[i] &gt;= 0){ pos = i; m -= b[i]; } } if(!pos){ printf(&quot;%lld\\n&quot;,n+1); continue; } if(pos != n &amp;&amp; a[pos+1] &lt;= m + b[pos]) ++pos; printf(&quot;%lld\\n&quot;,n-pos + 1); } return 0;} D.Different Arrays 题目描述： 给你一个有 nnn 个元素的序列，你需要进行 n−2n-2n−2 次操作。 对于第 iii 次操作，你可以选择让 ai−ai+1a_i-a_{i+1}ai​−ai+1​ 且 ai+2+ai+1a_{i+2}+a_{i+1}ai+2​+ai+1​ 或者可以选择让 ai+ai+1a_i+a_{i+1}ai​+ai+1​ 且 ai+2−ai+1a_{i+2}-a_{i+1}ai+2​−ai+1​ 问最后能产生多少个不同的序列。 题目分析： 一个想法就是判断什么样的序列是能被表示的，但是想了一会发现根本没有任何头绪，所以考虑换个想法，也就是直接使用 dpdpdp 去决策每一次的操作。 为了方便理解，我们将第 iii 次操作，成为操作第 i+1i+1i+1 个数。 但是这样看上去有很多重复的情况就很难办，注意一点就是要使得产生相同的序列则必然满足存在 ai=0a_i = 0ai​=0 的情况，然后操作 aia_iai​，否则一定不会产生相同的情况，所以我们完全不用考虑什么去重之类的问题，只需要判断 ai=0a_i = 0ai​=0 即可。 所以可以考虑设 dpi,jdp_{i,j}dpi,j​ 表示操作完了前 iii 个数，ai+1=ja_{i+1} = jai+1​=j 的方案数，记第二维的原因是我们此时需要决策第 i+1i+1i+1 次操作就必须知道对应的 aaa 是什么。 转移就是显然的，也就是直接枚举 ai+1a_{i+1}ai+1​ 是怎么操作的，以及特判 ai+1=0a_{i+1} = 0ai+1​=0。 注意到第二维可以为负，所以加一个偏移量。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int MOD = 998244353;const int MAX = 90000;int dp[305][90005 * 2];int a[305];void add(int &amp;a,int b){ a = (a + b)%MOD;}int main(){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); dp[1][MAX+a[2]] = 1; for(int i=1; i&lt;n; i++){ for(int k=-MAX; k&lt;=MAX; k++){ if(!dp[i][k+MAX]) continue; if(k == 0){ dp[i+1][a[i+2]+MAX] = (dp[i+1][a[i+2]+MAX] + dp[i][k+MAX])%MOD; } else{ dp[i+1][a[i+2]+k+MAX] = (dp[i+1][a[i+2]+k+MAX] + dp[i][k+MAX])%MOD; dp[i+1][a[i+2]-k+MAX] = (dp[i+1][a[i+2]-k+MAX] + dp[i][k+MAX])%MOD; } } } int ans = 0; for(int j=-MAX; j&lt;=MAX; j++) add(ans,dp[n-1][j+MAX]); printf(&quot;%d\\n&quot;,ans); return 0;} E.Game of the Year 题目描述： Monocarp 和 Polycarp 正在玩电脑游戏。游戏特点：nnn 个编号从 111 到 nnn 的BOSS。 他俩将用以下方式与BOSS战斗 Monocarp 进行 kkk 次尝试撒掉boss; Polycarp 进行 kkk 次尝试撒掉boss; Monocarp 进行 kkk 次尝试撒掉boss; Polycarp 进行 kkk 次尝试撒掉boss; … Monocarp 在第 aia_iai​ 次尝试中撒掉了第 iii 只BOSS。Polycarp 在第 bib_ibi​ 次尝试中撒掉了第 iii 只BOSS。其中一个人撒掉第 iii 只BOSS后，他们就会尝试撒第 (i+1)(i+1)(i+1) 只BOSS。并且他们的尝试计数器都会清空。撒掉第 nnn 只BOSS后，游戏结束。 找到从111 到 nnn所有的 kkk 值， 使得 Monocarp 可以杀死所有的BOSS。 1≤n≤2×1051 \\le n \\le 2\\times 10^51≤n≤2×105 题目分析： 题目说的实在是太抽象了，转化一下题意就是要找到满足以下条件的 kkk： ∀i∈[1,n]⌈aik⌉≤⌈bik⌉\\begin{aligned} &amp;\\forall i\\in[1,n] &amp; \\lceil \\frac{a_i}{k} \\rceil \\le \\lceil \\frac{b_i}{k} \\rceil \\end{aligned} ​∀i∈[1,n]​⌈kai​​⌉≤⌈kbi​​⌉​ 首先就是可以直接整除分块就能找到所有满足条件的 kkk，复杂度 O(nn)O(n\\sqrt{n})O(nn​) 但是常数有点逆天据说不能过，考虑优化。 一个经典的想法就是既然不能枚举约数，那么我们就枚举倍数，即枚举 kkk 然后枚举 kkk 的倍数。 可以发现 kkk 的倍数将序列分成了 O(nk)O(\\frac{n}{k})O(kn​) 段，而要使得上述条件满足就是 aia_iai​ 所在的块不在 bib_ibi​ 所在的块后面。 如果原来就满足 ai≤bia_i \\le b_iai​≤bi​ 则无论如何都满足条件，就不管了。 如果 ai&gt;bia_i &gt; b_iai​&gt;bi​ 条件其实就是 aia_iai​ 所在的块与 bib_ibi​ 所在的块相同，这个不是很好判，那么什么时候是不在一块呢？ 既然不在一块也就是说 [bi,ai][b_i,a_i][bi​,ai​] 跨过了一个分界点，如果我们以 kkk 的倍数作为每一段的右端点，也就是 [bi,ai)[b_i,a_i)[bi​,ai​) 包含 kkk 的倍数。 可以直接预处理出每一个位置是否可以作为右端点，然后对于每一个 kkk 的倍数判断一下即可。 复杂度 O(nlog⁡n)O(n \\log n)O(nlogn) 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5+5;int a[N],b[N],sum[N];vector&lt;int&gt; v;int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1; i&lt;=n; i++){ if(a[i] &gt; b[i]) sum[b[i]]++,sum[a[i]]--; } for(int i=1; i&lt;=n; i++) sum[i] += sum[i-1]; for(int i=1; i&lt;=n; i++){ bool flag = true; for(int j=i; j&lt;=n; j+=i){ if(sum[j]) flag = false; } if(flag) v.push_back(i); } printf(&quot;%d\\n&quot;,v.size()); for(int i=0; i&lt;v.size(); i++) printf(&quot;%d &quot;,v[i]); printf(&quot;\\n&quot;); for(int i=0; i&lt;=n; i++) sum[i] = 0; v.clear(); } return 0;} F.Double Sort II 题目描述： 有两个 1..n1..n1..n 的排列 a,ba,ba,b。 你可以进行若干次操作，每次操作流程如下： 选择一个整数 i∈[1,n]i \\in [1,n]i∈[1,n]。 找出两个整数 x,yx,yx,y，使得 ax=by=ia_x=b_y=iax​=by​=i。 交换 axa_xax​ 和 aia_iai​，以及 byb_yby​ 和 bib_ibi​。 问把 aaa 和 bbb 从小到大排序的最小操作次数 题目分析： 考虑将排列看作一个置换，然后建图，也就是连边 i→aii \\to a_ii→ai​ 与 i→bii \\to b_ii→bi​，注意这是两张图。 我们的一次操作相当于将某个点缩成一个自环，其他点不受影响，所以对于每一个置换环设其长度为 lenlenlen 只需要操作 len−1len-1len−1 次就可以将所有点缩成自环，即我们可以对于每一个环钦定一个点使得这个点不被操作，要最大化钦定点的数量。 而两张图其实也是差不多的，如果钦定 iii 不被操作，也就是说 iii 在 a,ba,ba,b 中的环上均只能选择 iii 这一个点不被操作，这个其实就是一个匹配的感觉。 所以可以对于每一个点 iii，找到其在 a,ba,ba,b 上的环，将这两个环连边，最后跑一个最大匹配就是最多的不用被操作的点数。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;struct edge{ int nxt,to,id; edge(){} edge(int _nxt,int _to,int _id){ nxt = _nxt,to = _to,id = _id; }}e[2 * N];int cnt,col1[N],col2[N],head[N],flag[N],match[N],a[N],b[N];bool vis[N],tag[N];void add_edge(int from,int to,int id){ e[++cnt] = edge(head[from],to,id); head[from] = cnt;}bool dfs(int now){ if(vis[now]) return false; vis[now] = true; for(int i=head[now] ;i ; i=e[i].nxt){ int to = e[i].to; if(!match[to] || dfs(match[to])){ match[now] = to,match[to] = now; flag[now] = flag[to] = e[i].id; return true; } } return false;}void dfs1(int now,int col){ if(col1[now]) return; col1[now] = col; if(!col1[a[now]]) dfs1(a[now],col);}void dfs2(int now,int col){ if(col2[now]) return; col2[now] = col; if(!col2[b[now]]) dfs2(b[now],col);}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;b[i]); int tot = 0; for(int i=1; i&lt;=n; i++){ if(col1[i]) continue; ++tot;dfs1(i,tot); } int tmp = tot; memset(vis,false,sizeof(vis)); for(int i=1; i&lt;=n; i++){ if(col2[i]) continue; ++tot;dfs2(i,tot); } for(int i=1; i&lt;=n; i++){ add_edge(col1[i],col2[i],i); add_edge(col2[i],col1[i],i);// printf(&quot;%d %d\\n&quot;,col1[i],col2[i]); } int ans = 0; for(int i=1; i&lt;=tmp; i++){ memset(vis,false,sizeof(vis)); ans += dfs(i); } printf(&quot;%d\\n&quot;,n - ans); for(int i=1; i&lt;=tmp; i++){ tag[flag[i]] = true; } for(int i=1; i&lt;=n; i++){ if(!tag[i]) printf(&quot;%d &quot;,i); } return 0;} G.Weighed Tree Radius 题目描述： 给你一个nnn个点的树和n−1n-1n−1条边。第iii个点的初始权值为aia_iai​。 定义结点vvv到结点uuu的距离dv(u)d_v(u)dv​(u)等于vvv和uuu之间的边的数量。注意:dv(u)=du(v),dv(v)=0d_v(u)=d_u(v),d_v(v)=0dv​(u)=du​(v),dv​(v)=0 定义结点vvv到结点uuu的权值距离wv(u)=dv(u)+auw_v(u)=d_v(u)+a_uwv​(u)=dv​(u)+au​。注意：wv(v)=av,wv(u)≠wu(v)w_v(v)=a_v,w_v(u) \\neq w_u(v)wv​(v)=av​,wv​(u)=wu​(v)如果au≠ava_u \\neq a_vau​=av​ 与通常的距离类似，让我们定义结点vvv的偏心距e(v)e(v)e(v)是从vvv到其他结点的最大权值距离（包括vvv本身），即e(v)=max⁡1≤u≤nwv(u)e(v)=\\max\\limits_{1\\leq u \\leq n} w_v(u)e(v)=1≤u≤nmax​wv​(u)。 最后，我们定义树的半径rrr是所有偏心距的最小值，即r=min⁡1≤v≤ne(v)r=\\min\\limits_{1\\leq v\\leq n} e(v)r=1≤v≤nmin​e(v) 你需要对mmm次询问进行回答，对于第jjj次询问，给出两个数vjv_jvj​和xjx_jxj​，表示将avja_{v_j}avj​​的值修改为xjx_jxj​。 在每次询问后，输出当前该树的半径rrr。 2≤n≤2×105，1≤m≤1052 \\le n \\le 2 \\times 10^5，1\\le m \\le 10^52≤n≤2×105，1≤m≤105 题目分析： 题目已经提示了这东西叫做半径，那么是不是直接求直径然后除以 222 就可以呢？ 我们定义 w′(u,v)=au+av+dis(u,v)w'(u,v) = a_u + a_v + dis(u,v)w′(u,v)=au​+av​+dis(u,v)，那么满足 w′(u,v)w'(u,v)w′(u,v) 最大的两个点 u,vu,vu,v 之间的路径的长度我们称为直径。 这里我们将 aua_uau​ 理解为挂在 uuu 上长度为 aua_uau​ 的链，ava_vav​ 理解为挂在 vvv 上长度为 ava_vav​ 的链。 设直径的中点为 midmidmid，若 midmidmid 在直径的某一个节点上，则显然 r=⌈w′(u,v)2⌉r = \\lceil \\frac{w'(u,v)}{2} \\rceilr=⌈2w′(u,v)​⌉，可是如果 midmidmid 不在直径的某一个节点上呢。 若 midmidmid 在 aua_uau​ 对应的链上，则必然满足 eu=aue_u = a_ueu​=au​，则对于其它的任意一个点 xxx 都必然满足 ex≥dis(u,x)+au&gt;au=eue_x \\ge dis(u,x) + a_u &gt; a_u = e_uex​≥dis(u,x)+au​&gt;au​=eu​，即 r=aur = a_ur=au​，但是这样的话就必然满足直径为 w′(u,u)w'(u,u)w′(u,u) 就不可能不存在了。 下面我们的问题就转化为了维护直径。 考虑假设我们原来的直径为 (u,v)(u,v)(u,v) 现在将 axa_xax​ 增大了一些，那么我们新直径的端点必然是 u,v,xu,v,xu,v,x 其中的两个，可以直接分类讨论得到答案。 而如果我们将 axa_xax​ 减小了一些，我们就无法判断直径端点的变化，所以可以考虑使用线段树分治维护修改，这样每次将值从 000 开始变化，这样每次都是加的操作了。","link":"/2023/09/13/Educational-Codeforces-Round-141-CF1783/"},{"title":"Educational Codeforces Round 142（CF1792）","text":"【题解】Educational Codeforces Round 142（CF1792） 没有手速，再加上被 E 卡了，废掉了。 A.GamingForces 题目描述： Monocarp 正在玩电脑游戏。他打算杀死 nnn 个怪兽，第 iii 个的血量为 hih_ihi​。 Monocarp 的角色有两个魔法咒语如下，都可以以任意顺序用任意次（可以不用），每次使用相当于一次操作。 选择两个怪兽并各扣一滴血。 选择一个怪兽并且直接杀死。 当一个怪兽血量为 000 时，他死了。 求杀死所有怪兽的最少操作次数。 题目分析： 只有两个怪兽同为 111 点血，这个时候我们通过 111 操作直接把它们弄死才会比直接通过操作 222 直接弄死更优。 所以判一下这个就好了。 代码： 点击查看代码 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 10005;int a[N];int main(){ int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); int cnt = 0; for(int i=1; i&lt;=n; i++){ if(a[i] == 1) ++cnt; } printf(&quot;%d\\n&quot;,n - cnt / 2); } return 0;} B.Stand-up Comedian 题目描述： Eve 是个单口相声新手。她的第一场表演聚集了总计 222 个观众：Alice 和 Bob。 Eve 准备了 a1+a2+a3+a4a_1+a_2+a_3+a_4a1​+a2​+a3​+a4​ 个相声表演节目。aia_iai​ 表示第 iii 类相声的数目，每类的的特征如下： Alice 和 Bob 都喜欢这类相声。 Alice 喜欢，Bob 不喜欢。 Bob 喜欢，Alice 不喜欢。 Alice 和 Bob 都不喜欢这类相声。 一开始，两位观众的心情都为 000。 当一位观众听到他喜欢的相声表演时心情会加 111，当听到的是自己不喜欢的相声时，心情减 1。 当某位观众心情严格小于 000 时，这位观众会离场。只要有一位这样的观众离场，Eve 会特别伤心并且结束整个表演。若演完了所有节目，也会结束表演。 求某种安排表演顺序的方式，使得 Eve 在结束表演前能表演的节目最多。输出最多能表演的节目数。 译者注：若演完某个节目有观众退场，这个节目也算在总数之中。 0≤a1,a2,a3,a4≤1080 \\le a_1,a_2,a_3,a_4 \\le 10^80≤a1​,a2​,a3​,a4​≤108。 题目分析： 好像是个大细节题，但是我一遍过就很爽[狂笑] 考虑最优的一个操作顺序肯定是：1→2,3→41 \\to 2,3 \\to 41→2,3→4。 关键是中间 2,32,32,3 造成的贡献比较难算，可以显然发现我们先操作一次 222 后操作一次 333 它们的代价就抵消了，而且会多出两次节目，但是要注意如果 111 操作数量为 000 就不能相互抵消了。 所以就按照：操作 111、2,32,32,3 抵消、操作 2,32,32,3、操作 444，这样的顺序模拟一下即可。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int cnt[10];signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%lld&quot;,&amp;T); while(T--){ for(int i=1; i&lt;=4; i++) scanf(&quot;%lld&quot;,&amp;cnt[i]); int ans = 0; int a = cnt[1],b = cnt[1];ans += cnt[1]; if(a == 0){ if(cnt[2] + cnt[3] + cnt[4] &gt; 0) printf(&quot;1\\n&quot;); else printf(&quot;0\\n&quot;); continue; } int tmp = min(cnt[2],cnt[3]);ans += 2 * tmp; cnt[2] -= tmp,cnt[3] -= tmp; if(cnt[2] &gt; 0){ tmp = min(cnt[2],b+1);ans += tmp; a += tmp,b -= tmp; } if(cnt[3] &gt; 0){ tmp = min(cnt[3],a+1);ans += tmp; a -= tmp,b += tmp; } if(a &gt;= 0 &amp;&amp; b &gt;= 0){ ans += min(min(a+1,b+1),cnt[4]); } printf(&quot;%lld\\n&quot;,ans); } return 0;} C.Min Max Sort 题目描述： 对于一个排列，定义一次操作为：在排列中任选两个数字，将它们中的最大值插入至队尾，最小值插入至队首。 现在给定多个排列，问每个排列最少各需多少次操作才能变得严格递增。 1≤n≤2×1051 \\le n\\le 2\\times 10^51≤n≤2×105 题目分析： 如果我们要进行操作，那么最后 111 操作必然是 1,n1,n1,n，然后倒推一下就会发现倒数第 222 次操作必然是 2,n−12,n-12,n−1，然后就可以发现倒数第 iii 次操作必然是 i,n−i+1i,n-i+1i,n−i+1。 所以假设我们通过 kkk 次操作可以使排列严格递增，也就是说值在 [k+1,n−k][k+1,n-k][k+1,n−k] 是不用我们管的了，已经符合条件了，将两头的 kkk 个进行排完序就结束了。 这个“不用管”用形式化的语言说其实就是，设 posipos_iposi​ 表示数 iii 出现的位置，则 posk+1&lt;posk+2&lt;⋯&lt;posn−kpos_{k+1} &lt; pos_{k+2} &lt; \\cdots &lt; pos_{n-k}posk+1​&lt;posk+2​&lt;⋯&lt;posn−k​。 所以可以直接一个个枚举 kkk 判断是否合法即可，也就是将 kkk 从 ⌊n2⌋\\lfloor \\frac{n}{2} \\rfloor⌊2n​⌋ 开始依次减 111，然后判断条件是否满足。 代码： 点击查看代码 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5+5;int a[N],p[N];int main(){ int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]),p[a[i]] = i; int k = n / 2; while(k &amp;&amp; p[k] &lt; p[k+1] &amp;&amp; p[n-k] &lt; p[n-k+1]) --k; printf(&quot;%d\\n&quot;,k); } return 0;} D.Fixed Prefix Permutations 题目描述： 对于一个排列 ppp，定义其美丽度 kkk 为 p1=1,p2=2,⋯ ,pk=k,pk+1≠k+1p_1=1,p_2=2,\\cdots,p_k=k,p_{k+1} \\neq k+1p1​=1,p2​=2,⋯,pk​=k,pk+1​=k+1 若 p,qp,qp,q 均为长度为 nnn 的排列，定义排列的运算 p⋅qp \\cdot qp⋅q 为： p⋅q=rp \\cdot q = rp⋅q=r，p,q,rp,q,rp,q,r 均为长度为 nnn 的排列 rj=qpjr_j = q_{p_j}rj​=qpj​​ 现在给出 nnn 个长度为 mmm 的排列，对于每一个 aia_iai​，求 ai⋅aj(1≤j≤n)a_i \\cdot a_j(1 \\le j \\le n)ai​⋅aj​(1≤j≤n) 美丽值最大为多少，允许有 i=ji=ji=j。 多测，T≤104T \\le 10^4T≤104，∑n≤5×104\\sum n \\le 5 \\times 10^4∑n≤5×104，m≤10m \\le 10m≤10 题目分析： 考虑如果就是给定了两个排列 p,qp,qp,q 怎么算它的美丽值。 要让 iii 经过两个排列的置换后依旧是在 iii 的位置，其实就是说设 posipos_iposi​ 表示 iii 在 qqq 中的位置，则 pi=posip_i = pos_ipi​=posi​，可以将置换理解为走路这种东西然后就很好理解了。 所以其实就是求出 pospospos 之后两者的 lcplcplcp。 那么这个题就很好解决了，可以直接对于每一个排列都求出 pospospos，然后插入到 trie 树里，计算答案就是枚举每一个排列然后让它在字典树上走即可。 （我竟然一开始用了 bitset 维护这个过程，差点就过了） 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5e4+5;int n,m,a[N][11],tot = 1,pos[N][11],ch[100 * N][11];void insert(int x){ int now = 1; for(int i=1; i&lt;=m; i++){ int to = pos[x][i]; if(!ch[now][to]) ch[now][to] = ++tot; now = ch[now][to]; }}int find(int x){ int now = 1; int ans = 0; for(int i=1; i&lt;=m; i++){ if(ch[now][a[x][i]]){ ++ans,now = ch[now][a[x][i]]; } else break; } return ans;}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=m; j++){ scanf(&quot;%d&quot;,&amp;a[i][j]); pos[i][a[i][j]] = j; } insert(i); } for(int i=1; i&lt;=n; i++) printf(&quot;%d &quot;,find(i)); printf(&quot;\\n&quot;); for(int i=1; i&lt;=tot; i++){ for(int j=1; j&lt;=10; j++){ ch[i][j] = 0; } } tot = 1; } return 0;} E.Divisors and Table 题目描述： 给定一张 n×nn \\times nn×n 的表格和一个正整数 m=m1×m2m = m_1 \\times m_2m=m1​×m2​，表格第 iii 行第 jjj 列的数 ai,j=i×ja_{i, j} = i \\times jai,j​=i×j。 现在需要你求出 mmm 的每个因子 ddd 是否在表格中出现，若出现，则求出其出现在表格中的最小行号。 1≤n,m1,m2≤1091 \\le n, m_1, m_2 \\le 10^91≤n,m1​,m2​≤109 题目分析： （一种乱搞做法） 101810^{18}1018 以内的数，因子个数最多有大约 10510^5105 个，所以显然可以将 mmm 的的所有因子都拿出来然后挨个判断。 要求所有的因子其实就是要对 mmm 质因数分解，可以直接用科技对 mmm 分解，也可以分别为 m1,m2m_1,m_2m1​,m2​ 分解后合起来，这样我们就得到了 mmm 的所有因子。 我们要做的其实就是分解 d=a×bd = a \\times bd=a×b，且 a,b≤na,b \\le na,b≤n，要求 aaa 尽可能小。 因为 ddd 为 mmm 的因子，所以 a,ba,ba,b 也必然是 mmm 的因子，所以可以将因子排序之后二分。 具体来说就是二分最小的 aaa 使得 ⌈da⌉≤n\\lceil \\frac{d}{a} \\rceil \\le n⌈ad​⌉≤n，这样只需要向后枚举一些 aaa 使得 a∣da \\mid da∣d 此时 aaa 就是最优的 aaa 了。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;#define int long longint t, n, m1, m2;vector&lt;int&gt; a, b, c;signed main(){ scanf(&quot;%lld&quot;, &amp;t); while (t -- ) { int cnt = 0, ans = 0; a.clear(); b.clear(); c.clear(); scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m1, &amp;m2); for (int i = 1; i &lt;= m1 / i; i ++ ) { if(m1 % i == 0) { a.push_back(i); if(m1 / i != i) a.push_back(m1 / i); } } for (int i = 1; i &lt;= m2 / i; i ++ ) { if(m2 % i == 0) { b.push_back(i); if(m2 / i != i) b.push_back(m2 / i); } } sort(a.begin(), a.end()); sort(b.begin(), b.end()); for (int i = 0; i &lt; a.size(); i ++ ) for (int j = 0; j &lt; b.size(); j ++ ) c.push_back(a[i] * b[j]); sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); for (int i = 0; i &lt; c.size(); i ++ ) { int l = 0, r = i; while (l &lt;= r) { int mid = l + r &gt;&gt; 1; if ((c[i] + c[mid] - 1) / c[mid] &lt;= n) r = mid - 1; else l = mid + 1; } for (int j = l; j &lt; c.size(); j ++ ) { if(c[j] &gt; n) break; if(c[i] % c[j] == 0) { ans ^= c[j]; cnt ++; break; } } } printf(&quot;%lld %lld\\n&quot;, cnt, ans); }} F1.Graph Coloring 题目描述： 简单版和困难版之间的唯一区别是 nnn 的数据范围不同。 给出一个 nnn 个顶点的无向完全图。完全图是指图上任意两个顶点皆有一条边相连。你需要给图上的每条边染上红色或蓝色。 一个顶点的集合 SSS 被称作是红色连接的，如果对于 SSS 中每对顶点 (v1,v2)(v_1,v_2)(v1​,v2​)，都存在只通过红边和 SSS 中顶点的路径。相仿地，一个顶点的集合 SSS 被称作是蓝色连接的，如果对于 SSS 中每对顶点 (v1,v2)(v_1,v_2)(v1​,v2​)，都存在只通过蓝边和 SSS 中顶点的路径。 你需要以如下方式对图进行染色： 至少有一条红边。 至少有一条蓝边。 对于每个大小不小于 222 的顶点集 SSS（也即 ∣S∣⩾2|S|\\geqslant 2∣S∣⩾2），SSS 或者是红色连接的，或者是蓝色连接的，但不能同时是红色和蓝色连接的。 计算染色方法数对 998244353998244353998244353 取模后的结果。 1≤n≤5×1031\\le n \\le 5\\times 10^31≤n≤5×103 题目分析： （不写 F2 了，是一个多项式科技） 题目条件就是要求对于任意一个导出子图，要么通过红色边可以联通，要么通过蓝色边可以联通，但是不能通过两种边都可以联通。 注意到一点就是：这是一个完全图，所以蓝色边和红色边互为补图，也就是如果蓝色边不连通则红色边必然联通，反之亦然。 所以我们可以直接 dpndp_ndpn​ 表示节点个数为 nnn 的图，不能通过蓝色边联通的合法的方案数。 转移就是考虑枚举点 nnn 所在的蓝色连通块大小 xxx： dpn=∑x=1n−1(n−1x−1)dpx×(2−[x=n−1])dpn−xdp_n = \\sum_{x=1}^{n-1} \\binom{n-1}{x-1} dp_x \\times (2 - [x = n-1])dp_{n-x} dpn​=x=1∑n−1​(x−1n−1​)dpx​×(2−[x=n−1])dpn−x​ 对于 nnn 所在的连通块这 xxx 个点必然满足蓝色联通也就是红色不连通，方案数等同于 dpxdp_xdpx​。 对于其余的 n−xn-xn−x 个点，它们之间蓝色联通或者红色联通都可以，所以就是系数有 222 的贡献，但当 n−x=1n-x = 1n−x=1 时，显然只有一种方案。 因为题目要求必须同时出现红边和蓝边，所以将答案减 222 即可。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 5e3+5;const int MOD = 998244353;int fac[N],inv[N],f[N];int binom(int n,int m){ if(n &lt; m || n &lt; 0 || m &lt; 0) return 0; return fac[n] * inv[m] % MOD * inv[n-m] % MOD;}int power(int a,int b){ int res = 1; while(b){ if(b &amp; 1) res = res * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; } return res;}signed main(){ int n;scanf(&quot;%lld&quot;,&amp;n); fac[0] = 1; for(int i=1; i&lt;=n; i++) fac[i] = fac[i-1] * i % MOD; inv[n] = power(fac[n],MOD-2); for(int i=n-1; i&gt;=0; i--) inv[i] = inv[i+1] * (i+1) % MOD; f[1] = 1; for(int i=2; i&lt;=n; i++){ for(int j=1; j&lt;=i-1; j++){ f[i] = (f[i] + f[j] * f[i-j] %MOD* binom(i-1,j-1) * (2 - (j == i-1))%MOD)%MOD; } } printf(&quot;%lld\\n&quot;,(2 * f[n] %MOD - 2 + MOD)%MOD); return 0;}","link":"/2023/09/11/Educational-Codeforces-Round-142-CF1792/"},{"title":"Educational Codeforces Round 143（CF1795）","text":"【题解】Educational Codeforces Round 143（CF1795） A.Two Towers 题目描述： 有 a,ba,ba,b 两座由红蓝色方块垒成的塔,其中 aaa 的高度为 nnn ； bbb 的高度为 mmm ，用 R 代表红色；用B代表蓝色。 你可以多次把其中一座顶端的方块移到另一座的顶端（可以不移动）。问有没有一种方法可以使两座塔中均没有连续的同颜色方块。 题目分析： 可以先全部将方块移动到一座塔上，这样我们的一种塔的方案数就相当于选择一个分界点将这一个序列分成两半。 所以有解显然当且仅当仅有一个位置，使得这个位置有连续两个相同颜色的数，或者所有颜色都不连续。 代码： 点击查看代码 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100;char s[N],t[N];int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%s%s&quot;,s+1,t+1); for(int i=1; i&lt;=m; i++) s[n+i] = t[m - i + 1]; int cnt = 0; for(int i=1; i&lt;=n+m; i++){ int pos = i; while(s[pos] == s[i] &amp;&amp; pos &lt;= n + m) ++pos; --pos; if(pos - i + 1 == 2) ++cnt; if(pos - i + 1 &gt; 2) cnt = 2; } if(cnt &lt;= 1) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } return 0;} B.Ideal Point 题目描述： 在一条数轴上，有 nnn 条线段和一个点 kkk，问能否删去若干条线段使得 kkk 的被覆盖次数比其他所有点的被覆盖次数都大。 题目分析： 显然就是要让点 kkk 覆盖次数变多不可能，就是要让其他点的覆盖次数减少。 也就是如果一个线段没有覆盖了 kkk，那么将它删去一定是更优的，而如果一个线段覆盖了 kkk 那么将它删除一定是不会更优的。 删完了，判断一下即可。 代码： 点击查看代码 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100;int cnt[N];int main(){ int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n,k;scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1; i&lt;=n; i++){ int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); if(k &lt; l || k &gt; r) continue; for(int j=l; j&lt;=r; j++) cnt[j]++; } bool flag = true; for(int i=1; i&lt;=50; i++){ if(i == k) continue; if(cnt[i] &gt;= cnt[k]) flag = false; } if(flag) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); for(int i=1; i&lt;=50; i++) cnt[i] = 0; } return 0;} C.Tea Tasting 题目描述： 有 nnn 个人和 nnn 杯茶，第 iii 个人每次会喝 bib_ibi​ 毫升的茶。第 iii 杯茶有 aia_iai​ 毫升。总共会喝 nnn 轮茶，第 jjj 轮第 iii 个人会尝试喝第 i+1−ji+1-ji+1−j 杯茶。喝的量为 min⁡(ai+1−j,bi)\\min(a_{i+1-j},b_i)min(ai+1−j​,bi​) 毫升，并且使 ai+1−ja_{i+1-j}ai+1−j​ 减少 min⁡(ai+1−j,bi)\\min(a_{i+1-j},b_i)min(ai+1−j​,bi​) 。问 nnn 轮后每个人喝了多少毫升茶。 1≤n≤2×1051 \\le n\\le 2\\times 10^51≤n≤2×105 题目分析： 因为茶会有喝完的时候，所以如果我们直接对于每一个人去统计茶对他产生的贡献，就很不好做。 所以考虑对于每一杯茶，统计它对每一个人造成的贡献，对于第 iii 杯茶，在第 jjj 轮喝它的人就是 i+j−1i + j - 1i+j−1，所以可以考虑直接二分得到这一杯茶在哪个人那里被喝没了，这样对于这个人前面喝过这个茶的人都完全喝了 bbb 毫升，而对于这个人就是减一下就知道他喝了多少毫升。 代码： 点击查看代码 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2e5+5;const int INF = 1e18+5;int a[N],b[N],cnt[N],res[N];signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%lld&quot;,&amp;T); while(T--){ int n;scanf(&quot;%lld&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;b[i]),b[i] += b[i-1]; b[n+1] = INF; for(int i=1; i&lt;=n; i++){ int pos = upper_bound(b+i,b+n+2,a[i] + b[i-1]) - b; cnt[i]++,cnt[pos]--; res[pos] += a[i] - (b[pos-1] - b[i-1]); } for(int i=1; i&lt;=n; i++) cnt[i] += cnt[i-1]; for(int i=1; i&lt;=n; i++) printf(&quot;%lld &quot;,cnt[i] * (b[i] - b[i-1]) + res[i]); printf(&quot;\\n&quot;); for(int i=1; i&lt;=n+1; i++) cnt[i] = 0,b[i] = 0,res[i] = 0; } return 0;} D.Triangle Coloring 题目描述： 一共有 nnn 条边（ nnn 是 666 的倍数） ，每连续三条边构成一个三角形（比如若 n=6n=6n=6 那么第 1,2,31,2,31,2,3 条边构成一个三角形， 4,5,64,5,64,5,6 条边构成另一个三角形 ），每条边有一个权值 wiw_iwi​ ，现在你可以把所有三角形的顶点涂成蓝色或红色，且要求有 n2\\frac{n}{2}2n​ 个蓝点和 n2\\frac{n}{2}2n​ 个红点，定义总权值为所有两端点颜色不同的边的权值和，问有多少种涂色方案可以使总权值最大（答案模 998244353998244353998244353 ）。 6≤n≤4×105，1≤wi≤10006 \\le n \\le 4 \\times 10^5，1 \\le w_i \\le 10006≤n≤4×105，1≤wi​≤1000 题目分析： 对于一个三角形，因为边权全部大于 000，所以全部染成蓝色和红色一定不是权值和最大的答案，而染成蓝蓝红和红红蓝最优的方案数显然是一样的，就是让某两条边的边权之和最大的方案数。 要求染一半的红点一半的蓝点，本质上就是选一半的三角形染蓝蓝红另一半的三角形染红红蓝，而对于每一种钦定每个三角形染色方案的方式，其实际方案数为定值，所以只需要求出选择染色方案的方案数即可。 而选择的方案数显然是： (n÷3n÷6)\\binom{n \\div 3}{n \\div 6} (n÷6n÷3​) 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MOD = 998244353;const int N = 1e6+5;int a[N],fac[N],inv[N];int power(int a,int b){ int res = 1; while(b){ if(b &amp; 1) res = res * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; } return res;}int binom(int n,int m){ if(n &lt; m || n &lt; 0 || m &lt; 0) return 0; return fac[n] * inv[m] % MOD * inv[n-m] %MOD; }signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n;scanf(&quot;%lld&quot;,&amp;n); fac[0] = 1; for(int i=1; i&lt;=n; i++) fac[i] = fac[i-1] * i % MOD; inv[n] = power(fac[n],MOD-2); for(int i=n-1; i&gt;=0; i--) inv[i] = inv[i+1] * (i+1) % MOD; int res = 1; for(int i=1; i&lt;=n/3; i++){ for(int j=1; j&lt;=3; j++) scanf(&quot;%lld&quot;,&amp;a[j]); int ans = 0,cnt = 0; for(int j=1; j&lt;=3; j++){ for(int k=j+1; k&lt;=3; k++){ if(a[j] + a[k] &gt; ans) ans = a[j] + a[k],cnt = 1; else if(a[j] + a[k] == ans) cnt++; } } res = res * cnt % MOD; } res = res * binom(n/3,n/6) % MOD; printf(&quot;%lld\\n&quot;,res); return 0;} E.Explosions? 题目描述： 你在玩一个利用魔法杀怪物的游戏。具体地，有一排 nnn 个格子，第 iii 个格子里有编号为 iii、初始生命值为 hih_ihi​ 的怪物。怪物生命值小于等于 000 则被杀死，所有怪物被杀死则游戏结束。 你有两种攻击方式：一种是普通攻击，你将消耗 111 点能量对选中的怪物进行 111 点伤害（也就是怪物的生命值减 111），你可以使用普通攻击任意次数。同时，你还可以使用恰好一次“爆炸”攻击。你想要游戏以“爆炸”攻击结束，也就是说，你会先进行若干次普通攻击（可以为 000 次），然后使用一次“爆炸”攻击结束游戏。 “爆炸”攻击的机制如下：你可以选择消耗的能量数 xxx，然后选中一个怪物 iii，之后： 若怪物 iii 当前的生命值 hi&gt;xh_i &gt; xhi​&gt;x，那么该怪物生命值减去 xxx； 若 hi≤xh_i\\le xhi​≤x，则该怪物被击杀，同时向两旁的怪物（即第 i−1i-1i−1 和 i+1i+1i+1 只怪物，如果有且还存活的话）造成 hi−1h_i - 1hi​−1 的伤害； 若 hi−1h_i - 1hi​−1 的伤害足以杀死第 i−1i-1i−1 （或 i+1i+1i+1）只怪物，即 hi−1≤hi−1h_{i-1}\\le h_i - 1hi−1​≤hi​−1（或 hi+1≤hi−1h_{i+1}\\le h_i - 1hi+1​≤hi​−1），那么这只怪物同样被击杀并向两旁的怪物造成 hi−1−1h_{i-1} - 1hi−1​−1（或 hi+1−1h_{i+1} - 1hi+1​−1）的伤害。如此循环只到杀不死一直怪物为止。 你的目标就是先用普通攻击减少某些怪物的生命值或直接杀死某些怪物，然后用这样“链式”的“爆炸”攻击杀死所有怪物。注意怪物不会移动，例如第 iii 只怪物和第 i+2i+2i+2 只怪物永远不会相邻。 你需要消耗最少的能量值来达成目标（包括普通攻击和“爆炸”攻击的），求出这个最小值。 1≤n≤1051 \\le n \\le 10^51≤n≤105 题目分析： 考虑使用爆炸操作之前的状态一定是前面一段 000 + 一个严格单峰的段 + 后面一段 000 所以可以考虑直接枚举这个峰在那里，那么就是要求前面严格单调递增后面严格单调递减，000 的问题其实可以理解为负数变成 000。 显然这两段问题是对称的，也就是解决一个问题即可，考虑解决前面的这个问题。 记 L[i]L[i]L[i] 表示让 [1,i][1,i][1,i] 严格单调递增的最小操作次数，可以发现若存在 j&lt;ij &lt; ij&lt;i 满足 aj≤ai−(i−j)a_j \\le a_i - (i-j)aj​≤ai​−(i−j)，也就是 aja_jaj​ 可以在不被操作的情况下爆掉，那么 [1,j][1,j][1,j] 的贡献就是 L[j]L[j]L[j] 下面直接考虑 [j+1,i][j+1,i][j+1,i] 的贡献即可，显然可以找到最大的一个 jjj 满足上述条件。 那么该怎么求这个 jjj 呢，显然上述条件可以转化为 aj−j≤ai−ia_j - j \\le a_i - iaj​−j≤ai​−i，直接用单调栈就可以维护了。 对于 [j+1,i][j+1,i][j+1,i] 的贡献，不妨假设 x∈[j+1,i]x \\in [j+1,i]x∈[j+1,i]，则这个点的操作次数就是 ax−[ai−(i−x)]a_x - [a_i - (i-x)]ax​−[ai​−(i−x)]，如果放到这一整段来看的话，axa_xax​ 就是相当于区间和 ai−(i−x)a_i - (i-x)ai​−(i−x) 就是一个等差数列求和，都很好维护。 要注意的细节就是，若 ai−(i−x)a_i - (i-x)ai​−(i−x) 为负数，要认为是 000。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 4e5+5;const int INF = 1e18+5;int a[N],L[N],R[N],sum[N];int get(int x,int len){ int y = x - len + 1; return (x + y) * len / 2;}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%lld&quot;,&amp;T); while(T--){ int n;scanf(&quot;%lld&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=1; i&lt;=n; i++) sum[i] = sum[i-1] + a[i]; stack&lt;pair&lt;int,int&gt; &gt; st; for(int i=1; i&lt;=n; i++){ while(!st.empty() &amp;&amp; st.top().first &gt; a[i] - i) st.pop(); int pos = 0; if(st.empty()) pos = 0; else pos = st.top().second; //注意的细节：减成负的相当于减成 0 if(pos != 0) L[i] = L[pos] + sum[i] - sum[pos] - get(a[i],min(i-pos,a[i])); else L[i] = sum[i] - get(a[i],min(i,a[i])); st.push({a[i]-i,i}); } reverse(a+1,a+n+1); for(int i=1; i&lt;=n; i++) sum[i] = sum[i-1] + a[i]; while(!st.empty()) st.pop(); for(int i=1; i&lt;=n; i++){ while(!st.empty() &amp;&amp; st.top().first &gt; a[i] - i) st.pop(); int pos = 0; if(st.empty()) pos = 0; else pos = st.top().second; //注意的细节：减成负的相当于减成 0 if(pos != 0) R[i] = R[pos] + sum[i] - sum[pos] - get(a[i],min(i-pos,a[i])); else R[i] = sum[i] - get(a[i],min(i,a[i])); st.push({a[i]-i,i}); } for(int l=1,r=n; l&lt;=r; l++,r--) swap(R[l],R[r]); int ans = INF; reverse(a+1,a+n+1); for(int i=1; i&lt;=n; i++) ans = min(ans,L[i] + a[i] + R[i]); printf(&quot;%lld\\n&quot;,ans); } return 0;} F.Blocking Chips 题目描述： 一棵大小为 nnn 的树，有 kkk 个人，第 iii 个人在结点 aia_iai​。 从第 111 秒开始，依次操作第 1,2,3,...,k,1,2,3,...,k,1,2,3,...,k,...1,2,3,...,k,1,2,3,...,k,1,2,3,...,k,...1,2,3,...,k,1,2,3,...,k,1,2,3,...,k,... 个人，每秒操作一个人，把这个人移动到没有被走过的结点（包括其他人走过的）。当不能移动时结束。 问最多能操作多少次，多测。 1≤n≤2×1051 \\le n \\le 2\\times 10^51≤n≤2×105 题目分析： 不妨直接钦定 111 节点为根，然后考虑这个问题。 一个想法就是贪心地移动每一个点，但是这样我们无法判断到底是向下移动还是向上移动更优。 注意到答案具有可二分性，所以直接二分答案然后就转化为了判定性问题，也就是对于每一个点判断其移动 bib_ibi​ 次是否可行。 可以按深度从下向上考虑每个点，一个点的最优策略就是向下走，如果向下走满足不了它了再向上走，直接一遍 dfsdfsdfs 就完成了。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5+5;struct edge{ int nxt,to; edge(){} edge(int _nxt,int _to){ nxt = _nxt,to = _to; }}e[2 * N];int n,k,cnt,head[N],dw[N],len[N],a[N];bool flag[N];void add_edge(int from,int to){ e[++cnt] = edge(head[from],to); head[from] = cnt;}void dfs(int now,int fath){ dw[now] = 0; for(int i=head[now]; i; i=e[i].nxt){ int to = e[i].to; if(to == fath) continue; dfs(to,now); if(!flag[to]) dw[now] = max(dw[now],dw[to] + 1); } if(!flag[now]) return; if(dw[now] &gt;= len[now]) len[now] = 0; else{ if(fath &amp;&amp; !flag[fath]) len[fath] = len[now] - 1,len[now] = 0,flag[fath] = true; }}bool check(int x){ for(int i=1; i&lt;=n; i++) len[i] = 0,flag[i] = false; for(int i=1; i&lt;=k; i++){ flag[a[i]] = true; len[a[i]] = (x / k) + ((x % k) &gt;= i); } dfs(1,0); for(int i=1; i&lt;=n; i++){ if(len[i] &gt; 0) return false; } return true;}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;n; i++){ int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add_edge(u,v);add_edge(v,u); } scanf(&quot;%d&quot;,&amp;k); for(int i=1; i&lt;=k; i++) scanf(&quot;%d&quot;,&amp;a[i]); int l = 0,r = n,ans = 0; while(l &lt;= r){ int mid = (l + r)&gt;&gt;1; if(check(mid)){ ans = mid,l = mid + 1; } else r = mid - 1; } printf(&quot;%d\\n&quot;,ans); for(int i=1; i&lt;=n; i++) head[i] = 0; cnt = 0; } return 0;} G.Removal Sequences 题目描述： 你有一张简单无向图，这张图上有 nnn 个点 mmm 条边，顶点编号为 1∼n1 \\sim n1∼n，第 iii 个顶点的权值是 aia_iai​。 你将删除一些顶点，特别的，定义删除顶点 iii 是合法的仅当 iii 的度数为 aia_iai​，删除某个顶点后，与这个顶点相连的边也会被删除。 我们称一个移除序列 ppp 是有效的当且仅当 p1,p2,...pnp_1,p_2,...p_np1​,p2​,...pn​ 是一个 1∼n1 \\sim n1∼n 的排列，且若依次删除 p1,p2,...pnp_1,p_2,...p_np1​,p2​,...pn​，每次删除都是合法的。 若存在两个合法的移除序列分别满足 xxx 在 yyy 前删除，yyy 在 xxx 前删除，且 x&lt;yx&lt;yx&lt;y，则点对 (x,y)(x,y)(x,y) 是美好的。 请统计所有“美好”的点对数量。 1≤n≤1051 \\le n \\le 10^51≤n≤105 题目分析： （感觉很结论题） 考虑这个过程很像拓扑排序的过程，那么怎么样才能真正变成拓扑排序。 设 pi=degi−aip_i = deg_i - a_ipi​=degi​−ai​，那么每次删除 pi=0p_i = 0pi​=0 的点就将与 iii 相邻的点 jjj 的 pj−1→pjp_j - 1\\to p_jpj​−1→pj​，然后这样就可以得到一种合法的序列。 有一个结论就是：若要让 pip_ipi​ 变成 000，则其相邻的点里必须有 pip_ipi​ 个点比它提前删除，而且在任何一个合法的删除序列中，这 pip_ipi​ 个点永远不变。 所以就可以直接根据一种合法的序列就可以得到相邻点之间的先后顺序，设 uuu 必须先于 vvv，则连边 (u,v)(u,v)(u,v)，那么若两个点可以相互到达也就是它们的先后顺序一定了，问题转化为有 DAG 联通点对计数。 这东西可以直接使用 bitset 暴力做，但是空间复杂度就爆了，可以直接分段，比如每次只考虑 100010001000 个点就好了。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define mpr make_pair#define debug() cerr&lt;&lt;&quot;Yoshino\\n&quot;#define pii pair&lt;int,int&gt;#define pb push_back using namespace std; typedef long long ll;typedef unsigned long long ull;typedef long long LL; const int inf = 1e9, INF = 0x3f3f3f3f, maxn = 1e5+5; int n,m,a[maxn],de[maxn];vector&lt;int&gt;g[maxn]; void solve(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]), g[i].clear(), de[i] = 0; for(int i=1;i&lt;=m;i++){ int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); g[x].pb(y), g[y].pb(x); de[x] ++, de[y] ++; } queue&lt;int&gt;Q; for(int i=1;i&lt;=n;i++){ de[i] -= a[i]; if(de[i] == 0)Q.push(i), de[i] = -1; } vector&lt;pii&gt;ed; while(!Q.empty()){ int u = Q.front(); Q.pop(); for(int v : g[u])if(de[v] &gt;= 0){ ed.emplace_back(v, u); // v-&gt;u if(!--de[v]){ Q.push(v); de[v] = -1; } } }// reverse(ed.begin(), ed.end()); vector&lt;ull&gt;S(n+1); ll ans = 1ll*n*(n+1) / 2; for(int l=1;l&lt;=n;l+=64){ int r = min(n, l+63); for(int i=l;i&lt;=r;i++){ S[i] = 1ull &lt;&lt; (i-l); } for(pii e : ed){ int u=e.first, v=e.second; S[u] |= S[v]; } for(int i=1;i&lt;=n;i++)ans -= __builtin_popcountll(S[i]), S[i] = 0; } cout &lt;&lt; ans &lt;&lt; '\\n';} signed main(){ int te;scanf(&quot;%d&quot;,&amp;te); while(te--)solve(); return 0;}","link":"/2023/09/09/Educational-Codeforces-Round-143-CF1795/"},{"title":"号爸 NOIP 模拟赛（2023.9.27）","text":"被 T2 创死了。 A.运输 题目描述： 给定一棵 nnn 个点的树，点 iii 上有 aia_iai​ 个物品，每条边有边权 wiw_iwi​。 将 xxx 个物品由 uuu 运向 vvv 的花费为树上 u,vu,vu,v 两点间的最短路径的长度乘以 xxx。 要求树上物品构成的序列的方差最小，求最小的花费。 1≤n≤50001 \\le n \\le 50001≤n≤5000，0≤ai,wi≤1040 \\le a_i,w_i \\le 10^40≤ai​,wi​≤104 题目分析： 要让方差最小，一个感觉就是尽可能平均地分，设 s=∑i=1nais = \\sum_{i=1}^n a_is=∑i=1n​ai​，则每个点都应该被分到 ⌊sn⌋\\lfloor \\frac{s}{n}\\rfloor⌊ns​⌋ 个物品，以及会有一些点会被分到 ⌈sn⌉\\lceil \\frac{s}{n} \\rceil⌈ns​⌉ 个物品，可以令 t1=⌊sn⌋t_1 = \\lfloor \\frac{s}{n} \\rfloort1​=⌊ns​⌋，令 t2t_2t2​ 表示会有多少点被分到 ⌈sn⌉\\lceil \\frac{s}{n} \\rceil⌈ns​⌉ 个物品，其实就是 t2=s%nt_2 = s \\% nt2​=s%n。 这种动来动去的题，统计答案一个经典的 trick 就是枚举每一条边，判断这一条边的答案。 设边 (u,v)(u,v)(u,v) 表示连接 uuu 这棵子树与 uuu 的父亲 vvv 的边，设子树内 aaa 的和为 s1s_1s1​ 即 s1,u=∑v∈sonuavs_{1,u} = \\sum_{v \\in \\textup{son}_u} a_vs1,u​=∑v∈sonu​​av​，设我们钦定完成每个点要分配多少个物品之后子树内的和为 s2s_2s2​，则 wu,vw_{u,v}wu,v​ 的贡献就是 ∣s1−s2∣×wu,v|s_1 - s_2| \\times w_{u,v}∣s1​−s2​∣×wu,v​。 所以我们显然可以使用 dpdpdp 来进行 “钦定每个点要分配多少个物品” 这个决策，也就是设 dpi,jdp_{i,j}dpi,j​ 表示以 iii 为根的子树有 jjj 个点的物品数量为 t1+1t_1 + 1t1​+1 的最小花费。 可以发现当我们状态确定了之后，就意味着当前子树内钦定之后的物品之和确定了，我们就可以直接计算出边 (i,fai)(i,fa_i)(i,fai​) 的贡献了。 所以一种比较好写的写法就是，因为当状态一定，边 (i,fai)(i,fa_i)(i,fai​) 的贡献就一定了，所以我们在转移的时候并不需要考虑这一条边的贡献，可以转移完成之后统一考虑，这样转移就是一个模板形式的树上背包了，经典复杂度分析 O(n2)O(n^2)O(n2)。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 5e3+5;const int INF = 1e18+5;struct edge{ int nxt,to,val; edge(){} edge(int _nxt,int _to,int _val){ nxt = _nxt,to = _to,val = _val; }}e[2 * N];int cnt,s,t1,t2,head[N],dp[N][N],val[N],sum[N],sz[N],a[N],g[N];void add_edge(int from,int to,int val){ e[++cnt] = edge(head[from],to,val); head[from] = cnt;}void dfs(int now,int fath){ sum[now] = a[now]; for(int i=head[now]; i; i=e[i].nxt){ int to = e[i].to; if(to == fath) continue; dfs(to,now); sum[now] += sum[to]; val[to] = e[i].val; }}void get_dp(int now,int fath){ dp[now][0] = dp[now][1] = 0; //对于外部的贡献我们最后再算 sz[now] = 1; for(int i=head[now]; i; i=e[i].nxt){ int to = e[i].to; if(to == fath) continue; get_dp(to,now); for(int j=0; j&lt;=min(sz[now]+sz[to],t2); j++) g[j] = INF; for(int j=0; j&lt;=min(sz[now],t2); j++){ for(int k=0; k&lt;=min(sz[to],t2); k++){ g[j+k] = min(g[j+k],dp[now][j] + dp[to][k]); } } for(int j=0; j&lt;=min(sz[now]+sz[to],t2); j++) dp[now][j] = g[j]; sz[now] += sz[to]; } for(int i=0; i&lt;=min(sz[now],t2); i++){ int tmp = sz[now] * t1 + i; dp[now][i] += abs(tmp - sum[now]) * val[now]; // printf(&quot;dp[%lld][%lld] = %lld\\n&quot;,now,i,dp[now][i]); }}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%lld&quot;,&amp;T); while(T--){ int n;scanf(&quot;%lld&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]),s += a[i]; t1 = s / n,t2 = s % n; for(int i=1; i&lt;n; i++){ int u,v,w;scanf(&quot;%lld%lld%lld&quot;,&amp;u,&amp;v,&amp;w); add_edge(u,v,w);add_edge(v,u,w); } dfs(1,0); memset(dp,0x3f,sizeof(dp)); get_dp(1,0); printf(&quot;%lld\\n&quot;,dp[1][t2]); cnt = 0;s=0; memset(head,0,sizeof(head)); } return 0;} B.或 题目描述： 给定两个数 L,RL,RL,R，要求在 [L,R][L,R][L,R] 中任意选择几个数，不可以不选，其二进制按位或之后，得到的值有多少种。 1≤L≤R≤10181 \\le L \\le R \\le 10^{18}1≤L≤R≤1018 题目分析： 感觉比较 ad-hoc 的一道题，可惜我感觉这种 ad-hoc 的想法推到一半感觉不大行，就没继续想。 一个显然的想法就是找到 L,RL,RL,R 二进制下第一个不同的位 pos1pos_1pos1​，这样在 pos1pos_1pos1​ 之前的位无论我们选择哪些数或起来都一定一样，所以我们就可以只考虑 L,RL,RL,R 在 pos1pos_1pos1​ 位及以后的位。 考虑如果第 pos1pos_1pos1​ 位选择 000，则可以发现我们必然可以或出来 [L,2pos1−1][L,2^{pos_1}-1][L,2pos1​−1]，因为这一位 LLL 为 000 而 RRR 为 111 所以中间必然经过了 2pos1−1=0111111⋯2^{pos_1}-1 = 0111111\\cdots2pos1​−1=0111111⋯ 这个分界点。 如果第 pos1pos_1pos1​ 位选择 111，可以考虑直接选择一个 2pos1=100000⋯2^{pos_1} = 100000\\cdots2pos1​=100000⋯ 这样就相当于将问题转化为在区间 [L,2pos1−1]⋃[0,R][L,2^{pos_1}-1] \\bigcup [0,R][L,2pos1​−1]⋃[0,R] 里选择一些数，询问它们或出来的值的种类数，注意此时的 L,RL,RL,R 为仅保留 pos1−1pos_1-1pos1​−1 以及之后的位的时候的值。 但是这个东西看上去就是把问题变复杂了就很不好。 考虑对于 [L,2pos1−1][L,2^{pos_1}-1][L,2pos1​−1]，因为我们保留 pos1−1pos_1-1pos1​−1 以及之后的位之后，2pos1−12^{pos_1}-12pos1​−1 是我们可以选择的数的上界，以及我们或起来之后其也不会超过这个上界，所以我们可以通过选择 [L,2pos1−1][L,2^{pos_1}-1][L,2pos1​−1] 得到所有大于等于 LLL 的值，其实就只需要考虑能不能或出来那些小于 LLL 的数。 要求或起来小于 LLL 就必然要求每个数都小于 LLL，所以我们可以选择的区间变成了 [0,R][0,R][0,R]，此时会发现这是一个满足 L=0L = 0L=0 特殊性质的问题，其能或起来得到的数就相当于：设 pos2pos_2pos2​ 为 RRR 最高的为 111 的位，则可以得到 [0,2pos2+1−1][0,2^{pos_2+1}-1][0,2pos2​+1−1]。 这个东西的证明就是考虑 20,21,22,⋯ ,2pos22^0,2^1,2^2,\\cdots,2^{pos_2}20,21,22,⋯,2pos2​ 必然都单独地出现在了 [0,R][0,R][0,R] 中，所以可以从中任意选取，就可以构造出 [0,2pos2+1−1][0,2^{pos_2+1}-1][0,2pos2​+1−1] 的所有数。 所以针对第 pos1pos_1pos1​ 选择 111 的情况只需要对于 [0,2pos2+1−1][0,2^{pos_2+1}-1][0,2pos2​+1−1] 与 [L,2pos1−1][L,2^{pos_1}-1][L,2pos1​−1] 取一个并集即可。 所以最终的答案就是直接对于两种情况的答案相加即可，复杂度 O(log⁡n)O(\\log n)O(logn) 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;signed main(){ int l,r;scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r); int pos1 = 60; //寻找最高的不同的位 while(pos1 &gt;= 0){ if(((l &gt;&gt; pos1) &amp; 1) ^ ((r &gt;&gt; pos1) &amp; 1)) break; pos1--; } if(pos1 == -1){ printf(&quot;1\\n&quot;); return 0; } l %= (1ll&lt;&lt;pos1); r %= (1ll&lt;&lt;pos1); int ans = ((1ll&lt;&lt;pos1) - 1) - l + 1; //钦定当前位为 0 //这里加 1 其实加的是 l int limit1 = l; //大于等于 l 的都可以被选择出来 int pos2 = 60; while(pos2 &gt;= 0){ if((r &gt;&gt; pos2) &amp; 1) break; --pos2; } int limit2 = (1ll&lt;&lt;(pos2+1)) - 1; //小于等于 limit2 的都可以被表示出来 if(limit1 &lt;= limit2) ans += (1ll&lt;&lt;pos1) - 1 + 1; else ans += ((1ll&lt;&lt;pos1)-1) - limit1 + 1 + limit2 + 1; printf(&quot;%lld\\n&quot;,ans); return 0;} C.数 题目描述： 给定正整数 n,mn,mn,m。 对于一个长度为 nnn 的序列 aaa，我们定义其价值为 lcmgcd⁡\\textup{lcm}^{\\gcd}lcmgcd，其中 lcm\\textup{lcm}lcm 与 gcd⁡\\gcdgcd 分别代表这个序列所有数的最小公倍数与最大公约数。 要求解所有长度为 nnn 值域为 [1,m][1,m][1,m] 的序列的权值之积。 n≤109n \\le 10^9n≤109，m≤2⋅105m \\le 2\\cdot 10^5m≤2⋅105 题目分析： 既然是要求 lcmgcd⁡\\textup{lcm}^{\\gcd}lcmgcd 的乘积，一个想法就是直接枚举 gcd⁡\\gcdgcd，这样就是设 g(i)=∏gcd⁡=ilcmg(i) = \\prod_{\\gcd = i} \\textup{lcm}g(i)=∏gcd=i​lcm，答案就是 ∏ig(i)i\\prod_{i} g(i)^i∏i​g(i)i，但是我们钦定 gcd⁡=i\\gcd = igcd=i 显然不如钦定 gcd⁡\\gcdgcd 为 iii 的倍数简单，设 f(i)=∏i∣gcd⁡lcm(a)=∏∀j,i∣ajlcm(a)f(i) = \\prod_{i \\mid \\gcd} \\textup{lcm}(a) = \\prod_{\\forall j,i \\mid a_j} \\textup{lcm}(a)f(i)=∏i∣gcd​lcm(a)=∏∀j,i∣aj​​lcm(a)，那么其实我们只要可以求出 fff 就可以直接求出 ggg 的值。 具体根据 fff 求 ggg 的方法就是一个经典的 trick，也就是一个类似数学归纳法的过程，首先 g(m)=f(m)g(m) = f(m)g(m)=f(m)，然后从大到小枚举 iii，假定对于 j&gt;ij &gt; ij&gt;i 都有 g(j)g(j)g(j) 为已知的值，则有： g(i)=f(i)∏i∣j&amp;j≠ig(j)g(i) = \\frac{f(i)}{\\prod_{i | j \\&amp; j \\not= i} g(j)} g(i)=∏i∣j&amp;j=i​g(j)f(i)​ 这样我们就可以根据 fff 将 ggg 搞出来了。 因为 mmm 很小，所以其实可以考虑枚举每一个 f(i)f(i)f(i) 然后求值，也就是我们要求解下面这个式子的值： ∏∀j,i∣ajlcm(a)\\prod_{\\forall j,i \\mid a_j} \\textup{lcm}(a) ∀j,i∣aj​∏​lcm(a) 首先我们可以将所有的数都除以 iii，这样 i∣aji \\mid a_ji∣aj​ 的限制就没了，但是在最后计算贡献的时候不要忘记把这里除的 iii 算上。 其实就是每一个序列都会除以一个 iii，而对于每一个数其取值范围是 [1,⌊mi⌋][1,\\lfloor \\frac{m}{i}\\rfloor][1,⌊im​⌋]，所以总共有 (⌊mi⌋)n(\\lfloor \\frac{m}{i}\\rfloor)^n(⌊im​⌋)n 个序列，所以最后乘以 i(⌊mi⌋)ni^{(\\lfloor \\frac{m}{i}\\rfloor)^n}i(⌊im​⌋)n 的贡献即可。 这个额外的贡献说完了，下面就是考虑原问题会被转化为什么，设 lim=⌊mi⌋lim = \\lfloor \\frac{m}{i} \\rfloorlim=⌊im​⌋，也就是要求解长度为 nnn 且值域为 [1,lim][1,lim][1,lim] 的序列的 lcm\\textup{lcm}lcm 之积。 一个想法就是按每一个质数分别来求解，也就是设 s(pc)s(p^c)s(pc) 表示有多少个满足条件的序列的 lcm\\textup{lcm}lcm 的标准分解式中 ppp 的指数恰好为 ccc 的方案数，则答案显然为： ∏p,cpc×s(pc)\\prod_{p,c} p^{c \\times s(p^c)} p,c∏​pc×s(pc) sss 并不好算，所以考虑容斥，注意到 lcm\\textup{lcm}lcm 本质上是对所有的指数求 max⁡\\maxmax，所以若我们只要求 ppp 的指数小于等于 ccc 是好求的，设 s′(pc)s'(p^c)s′(pc) 表示满足条件的序列的标准分解式中 ppp 的指数小于等于 ccc 的方案数，那么就有 s(pc)=s′(pc)−s′(pc−1)s(p^c) = s'(p^c) - s'(p^{c-1})s(pc)=s′(pc)−s′(pc−1)。 s′(pc)s'(p^c)s′(pc) 就很好求了，既然要求 ppp 的指数全部小于等于 ccc，就是意味着不能存在 pc+1p^{c+1}pc+1 的倍数，那么每一个数可以选择的方案就是：lim−⌊limpc+1⌋lim - \\lfloor \\frac{lim}{p^{c+1}} \\rfloorlim−⌊pc+1lim​⌋，所以就有： s′(pc)=(lim−⌊limpc+1⌋)ns'(p^c) = \\left(lim - \\left\\lfloor \\frac{lim}{p^{c+1}} \\right\\rfloor\\right)^n s′(pc)=(lim−⌊pc+1lim​⌋)n 所以直接倒推回去就好了。 复杂度大概是 O(mlog⁡nlog⁡m)O(m \\log n \\log m)O(mlognlogm) 的。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2e5+5;const int MOD = 998244353;int n,m,val[N],f[N];bool flag[N];int power(int a,int b,int mod){ int res = 1; while(b){ if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return res;}int calc(int d){ int lim = m / d; int ans = power(d,power(lim,n,MOD-1),MOD); if(val[lim]) return ans * val[lim] % MOD; val[lim] = 1; for(int i=2; i&lt;=lim; i++){ //枚举质数 if(flag[i]) continue; int lst = power(lim-(lim/i),n,MOD-1); //s'(p^{c-1}) for(int j=i; j&lt;=lim; j*=i){ //枚举几次方 int cur = power(lim-(lim/(j*i)),n,MOD-1); //s'(p^c) int tmp = (cur-lst+MOD-1)%(MOD-1); //s(p^c) lst = cur; val[lim] = val[lim] * power(j,tmp,MOD) % MOD; } } return ans * val[lim] % MOD;}signed main(){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=2; i&lt;=200000; i++){ if(flag[i]) continue; for(int j=i+i; j&lt;=200000; j+=i){ flag[j] = true; } } for(int i=1; i&lt;=m; i++) f[i] = calc(i); int ans = 1; for(int i=m; i&gt;=1; i--){ int tmp = 1; for(int j=i+i; j&lt;=m; j+=i){ tmp = tmp * f[j] % MOD; } tmp = power(tmp,MOD-2,MOD); f[i] = f[i] * tmp % MOD; ans = ans * power(f[i],i,MOD) % MOD; } printf(&quot;%lld\\n&quot;,ans); return 0;}","link":"/2023/09/28/HB-NOIP-2023-9-27/"},{"title":"JSOI2016 位运算","text":"【题解】[JSOI2016] 位运算 题目描述： JYY 最近在研究位运算。他发现位运算中最有趣的就是异或 (xor) 运算。对于两个数的异或运算，JYY 发现了一个结论：两个数的异或值为 000 当且仅当他们相等。于是 JYY 又开始思考，对于 NNN 个数的异或值会有什么性质呢？ JYY 想知道，如果在 000 到 R−1R-1R−1 的范围内，选出 NNN 个不同的整数，并使得这 NNN 个整数的异或值为 000，那么一共有多少种选择的方法呢？（选择的不同次序并不作重复统计，请参见样例） JYY 是一个计算机科学家，所以他脑海里的 RRR 非常非常大。为了能够方便的表达，如果我们将 RRR 写成一个 010101 串，那么 RRR 是由一个较短的 010101 串 SSS 重复 KKK 次得到的。比如，若 S=101S=101S=101，K=2K=2K=2，那么 RRR 的二进制表示则为 101101101101101101。由于计算的结果会非常大，JYY 只需要你告诉他选择的总数对 109+710^9+7109+7 取模的结果即可。 对于 100%100\\%100% 的数据，3≤N≤73 \\le N \\le 73≤N≤7，1≤k≤1051 \\le k \\le 10^51≤k≤105，1≤∣S∣≤501 \\le |S| \\le 501≤∣S∣≤50。 题目分析： 首先若异或值为 000 也就是说按每一位考虑，每一位 111 的个数都为偶数。 所以可以按每一位分别考虑，使用 dpdpdp 解决这个问题。 因为题目要求选择的数不同，所以为了方便转移我们可以考虑使用最小表示法记录数的相同情况，也就是维护一个长度为 777 的序列，其中第 iii 个数表示第一个与 iii 相同的数的位置。 直接爆搜可以发现有用状态数为 877877877 个。 把这个东西推推就会发现，根本做不了，因为状态数太多了，所以考虑能不能优化状态。 首先我们如果用这种状态转移我们最后还要除以一个阶乘，因为一种方案的不同排列方式也被我们当作了不同方案，所以优化状态可以考虑从这个入口。 令我们的选择的数为 x1,x2,x3,⋯ ,xnx_1,x_2,x_3,\\cdots,x_nx1​,x2​,x3​,⋯,xn​，那么我们强制令 R&gt;x1&gt;x2&gt;x3&gt;⋯&gt;xnR &gt; x_1 &gt; x_2 &gt; x_3 &gt; \\cdots &gt; x_nR&gt;x1​&gt;x2​&gt;x3​&gt;⋯&gt;xn​，这样我们最后的方案数就不重不漏了。 我们的状态就是仅考虑二进制下前几位的时候的情况，因为仅考虑前几位有可能出现 xi=xi+1x_i = x_{i+1}xi​=xi+1​ 的情况，所以不妨直接记录一个 010101 状态 SSS，如果 Si=1S_i = 1Si​=1 则意味着 xi=xi−1x_i = x_{i-1}xi​=xi−1​，如果 Si=0S_i = 0Si​=0 则意味着 xi&lt;xi−1x_i &lt; x_{i-1}xi​&lt;xi−1​，这里默认 x0=Rx_0 = Rx0​=R。 这样的话转移其实就是枚举当前这一位每一个数都是 000 还是 111，直接暴力做的复杂度就是 O(k×∣S∣×2n×2n×n)O(k \\times |S| \\times 2^n \\times 2^n \\times n)O(k×∣S∣×2n×2n×n)。 但是注意到我们的 RRR 是循环的，所以可以处理出一个循环节里 dp[S]dp[S]dp[S] 对 dp[T]dp[T]dp[T] 的贡献系数，然后使用矩阵快速幂就可以实现快速转移了。 而一个循环节里 dp[S]dp[S]dp[S] 对 dp[T]dp[T]dp[T] 的贡献并没有什么公式可以求，所以可以对于每一个 SSS 都将 dp[S]dp[S]dp[S] 作为 dpdpdp 的初值然后跑一遍 dpdpdp 就可以得到贡献系数。 时间复杂度为 O(∣S∣×23n×n+23n×log⁡k)O(|S| \\times 2^{3n} \\times n + 2^{3n} \\times \\log k)O(∣S∣×23n×n+23n×logk) 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MOD = 1e9+7;const int N = 100;void add(int &amp;a,int b){ a = (a + b) % MOD;}struct Matrix{ int n,m; int a[200][200]; Matrix(){ memset(a,0,sizeof(a)); } void init(){ for(int i=0; i&lt;n; i++) a[i][i] = 1; }}; Matrix operator * (Matrix a,Matrix b){ Matrix c; c.n = a.n,c.m = b.m; for(int i=0; i&lt;c.n; i++){ for(int j=0; j&lt;c.m; j++){ for(int k=0; k&lt;a.m; k++){ add(c.a[i][j],a.a[i][k]*b.a[k][j]); } } } return c;}int dp[100][200],flag[N];char s[N];signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n,k;scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); scanf(&quot;%s&quot;,s+1); int len = strlen(s+1); Matrix tmp; tmp.n = tmp.m = 1&lt;&lt;n; for(int T=0; T&lt;(1&lt;&lt;n); T++){ memset(dp,0,sizeof(dp)); dp[0][T] = 1; for(int i=0; i&lt;len; i++){ for(int S=0; S&lt;(1&lt;&lt;n); S++){// printf(&quot;%lld &quot;,dp[i][S]); if(!dp[i][S]) continue; for(int tmp=0; tmp&lt;(1&lt;&lt;n); tmp++){ if(__builtin_popcount(tmp) % 2 == 1) continue; int res = 0,tag = 1; flag[0] = s[i+1] - '0'; for(int j=1; j&lt;=n; j++) flag[j] = (tmp &gt;&gt; (j-1)) &amp; 1; for(int j=1; j&lt;=n; j++){ if((S &gt;&gt; (j-1)) &amp; 1){ if(flag[j] &amp;&amp; !flag[j-1]) tag = 0; if(flag[j] == flag[j-1]) res |= (1&lt;&lt;(j-1)); } } if(!tag) continue; add(dp[i+1][res],dp[i][S]); } }// printf(&quot;\\n&quot;); } for(int S=0; S&lt;(1&lt;&lt;n); S++){ tmp.a[T][S] = dp[len][S]; } } Matrix res; res.n = res.m = 1&lt;&lt;n; res.init(); while(k){ if(k &amp; 1) res = res * tmp; tmp = tmp * tmp; k &gt;&gt;= 1; } Matrix f; f.n = 1,f.m = (1&lt;&lt;n); f.a[0][(1&lt;&lt;n)-1] = 1; f = f * res; printf(&quot;%lld\\n&quot;,f.a[0][0]); return 0;}","link":"/2023/09/21/JSOI2016-weiyunsuan/"},{"title":"Manacher","text":"对于 Manacher 部分的理解，推荐阅读前有一定了解 ##对算法本身的部分理解： 1234if(2 * maxn - i &gt;= 1) f[i] = min(f[2 * maxn - i],maxr - i);else f[i] = maxr - i; 关于这个算法，最难以理解的部分也就这里，也就是判断 iii 的最长回文长度的下界。 首先定义 jjj 为 iii 关于 maxnmaxnmaxn 的对称点，mxrmxrmxr 为已有回文半径覆盖到的最右点，maxnmaxnmaxn 为其的中心点 首先关于 jjj 的寻找，因为 maxn=i−j2maxn = \\frac{i-j}{2}maxn=2i−j​，所以可以化简得：2×maxn=i−j2\\times maxn = i - j2×maxn=i−j，所以 j=2×maxn−ij = 2\\times maxn - ij=2×maxn−i 关于第一行的判断条件，也就是在判断 jjj 的存在，然后看后面的两种情况。 1：若 f[j]&lt;maxr−if[j] &lt; maxr - if[j]&lt;maxr−i，我们选择的下界会是 f[j]f[j]f[j]，则有下图 ​ 其中用红线代表 i,ji,ji,j 的回文范围，maxr−imaxr- imaxr−i 也就是 iii 到 maxrmaxrmaxr 的距离。首先因为这一长段都是以 maxnmaxnmaxn 为中心的回文子串，所以其实以 jjj 为中心的回文子串也在以 iii 为中心的回文子串那里（不一定完整），因为 jjj 的回文半径小于 iii 到 maxrmaxrmaxr 的距离，所以以 jjj 为中心的整个回文串都完整地到了 iii 的地方，所以对于 iii 来说它的回文半径的下界也就是 jjj 的回文半径。之所以说是下界，因为超过这个下界的 iii 的右边可能有一些值仍然可以和 iii 的左边匹配，因为超过部分不一定和 jjj 那里一样，所以是下界。 2：若 f[j]&gt;maxr−if[j] &gt; maxr - if[j]&gt;maxr−i，我们选择的下界会是 maxr−imaxr - imaxr−i，则有下图： 此时也就相当于 jjj 的回文半径的长度超过了 maxnmaxnmaxn 的限制，也就是以 jjj 为中心的回文串只有一部分因为 maxnmaxnmaxn 的限制而来到了 iii 的位置，而这一部分的长度也就是 jjj 到 maxnmaxnmaxn 限制的左端点的距离，也就是 maxr−imaxr - imaxr−i 那么因为这一段有 maxnmaxnmaxn 的限制再加上在 jjj 是回文的，所以也一定是回文的","link":"/2022/03/29/Manacher/"},{"title":"SNOI2019 通信","text":"【题解】[SNOI2019]通信 评价：一眼秒了，两个板子合在一起就成难题了是嘛 /怄火 题目描述： nnn 个排成一列的哨站要进行通信。第 iii 个哨站的频段为 aia_iai​。 每个哨站 iii 需要选择以下二者之一： 直接连接到控制中心，代价为 WWW； 连接到前面的某个哨站 jjj (j&lt;ij&lt;ij&lt;i)，代价为 ∣ai−aj∣|a_i-a_j|∣ai​−aj​∣。 每个哨站只能被后面的至多一个哨站连接。 请你求出最小可能的代价和。 对于所有数据，1≤n≤10001 \\leq n \\leq 10001≤n≤1000，0≤W,ai≤1090 \\leq W,a_i \\leq 10^90≤W,ai​≤109。 题目分析： 一个想法就是 dpdpdp，但是这样的话我们就要记录每个点选/不选，这种东西就很不能做。 注意到一个哨站最多连接到前面的一个和后面的一个哨站。 这个东西就有一种匹配的感觉，而这个东西显然不是二分图，所以只有网络流这一种思路了。 所以就有一个显然的建图： 设源点为 sss，汇点为 ttt，控制中心为 ppp，将哨站 iii 拆成一个入点 iniin_iini​ 和一个出点 outiout_iouti​。 对于每一个哨站建边：(s,ini,1,0)(s,in_i,1,0)(s,ini​,1,0)，(outi,t,1,0)(out_i,t,1,0)(outi​,t,1,0)，(ini,p,1,W)(in_i,p,1,W)(ini​,p,1,W)，(ini,outj,1,∣ai−aj∣)(in_i,out_j,1,\\left| a_i-a_j \\right|)(ini​,outj​,1,∣ai​−aj​∣)。 主要是最后这一种建边数量 O(n2)O(n^2)O(n2)，所以直接费用流的复杂度是接受不了的。 可以发现最后一种建边就相当于一个二维偏序，因为我们可以将绝对值拆开，即： 若 j&lt;ij &lt; ij&lt;i 且 aj&lt;aia_j &lt; a_iaj​&lt;ai​，建边 (ini,outj,1,ai−aj)(in_i,out_j,1,a_i-a_j)(ini​,outj​,1,ai​−aj​)。 若 j&lt;ij &lt; ij&lt;i 且 aj&gt;aia_j &gt; a_iaj​&gt;ai​，建边 (ini,outj,1,aj−ai)(in_i,out_j,1,a_j-a_i)(ini​,outj​,1,aj​−ai​)。 可以使用分治去掉第一维，这样第二维就可以使用前缀和优化建图解决了。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 3005;const int INF = 1e18+5;struct edge{ int nxt,to,cost,val; edge(){} edge(int _nxt,int _to,int _val,int _cost){ nxt = _nxt,to = _to,cost = _cost,val = _val; }}e[5000 * N];int cnt=1,tot,s,t,pre[N],suf[N],b[N],tmp[N],in[5 * N],out[5 * N],a[5 * N],dis[5 * N],cur[5 * N],head[5 * N];bool in_que[5 * N],vis[5 * N];void add_edge(int from,int to,int val,int cost){ e[++cnt] = edge(head[from],to,val,cost); head[from] = cnt; e[++cnt] = edge(head[to],from,0,-cost); head[to] = cnt;}bool spfa(){ for(int i=1; i&lt;=tot; i++) dis[i] = INF,in_que[i] = false,cur[i] = head[i]; dis[s] = 0; queue&lt;int&gt; q;q.push(s);in_que[s] = true; while(!q.empty()){ int now = q.front();q.pop(); in_que[now] = false; for(int i=head[now]; i; i=e[i].nxt){ int to = e[i].to; if(dis[to] &gt; dis[now] + e[i].cost &amp;&amp; e[i].val){ dis[to] = dis[now] + e[i].cost; if(!in_que[to]) q.push(to),in_que[to] = true; } } } return dis[t] != INF;}int dfs(int now,int limit){ if(now == t) return limit; int flow = 0;vis[now] = true; for(int i=cur[now]; i &amp;&amp; flow &lt; limit; i=e[i].nxt){ int to = e[i].to; cur[now] = i; if(e[i].val &amp;&amp; dis[to] == dis[now] + e[i].cost &amp;&amp; !vis[to]){ int h = dfs(to,min(e[i].val,limit-flow)); e[i].val -= h,e[i^1].val += h; flow += h; if(!h) dis[to] = INF; } } return flow;}int dinic(){ int ans = 0; while(spfa()){ memset(vis,false,sizeof(vis)); int flow = dfs(s,INF); ans += flow * dis[t]; } return ans;}int find(int l,int r,int val){ int ans = r + 1; while(l &lt;= r){ int mid = (l + r) &gt;&gt; 1; if(a[b[mid]] &gt; val){ ans = mid,r = mid - 1; } else l = mid + 1; } return ans;}void solve(int l,int r){ if(l == r) return; int mid = (l + r) &gt;&gt; 1; solve(l,mid);solve(mid+1,r); for(int i=l; i&lt;=mid; i++){ pre[i] = ++tot; add_edge(pre[i],out[b[i]],1,-a[b[i]]); if(i != l) add_edge(pre[i],pre[i-1],INF,0); } for(int i=mid; i&gt;=l; i--){ suf[i] = ++tot; add_edge(suf[i],out[b[i]],1,a[b[i]]); if(i != mid) add_edge(suf[i],suf[i+1],INF,0); } for(int i=mid+1; i&lt;=r; i++){ int pos = find(l,mid,a[b[i]]); //第一个大于 a[b[i]] 的数 if(pos-1 &gt;= l) add_edge(in[b[i]],pre[pos-1],1,a[b[i]]); if(pos &lt;= mid) add_edge(in[b[i]],suf[pos],1,-a[b[i]]); } int sz = l-1; int posl = l,posr = mid+1; while(posl &lt;= mid &amp;&amp; posr &lt;= r){ if(a[b[posl]] &lt; a[b[posr]]) tmp[++sz] = b[posl++]; else tmp[++sz] = b[posr++]; } while(posl &lt;= mid) tmp[++sz] = b[posl++]; while(posr &lt;= r) tmp[++sz] = b[posr++]; for(int i=l; i&lt;=r; i++) b[i] = tmp[i];}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n,W;scanf(&quot;%lld%lld&quot;,&amp;n,&amp;W); s = ++tot; t = ++tot; int p = ++tot;add_edge(p,t,INF,0); for(int i=1; i&lt;=n; i++) in[i] = ++tot,out[i] = ++tot; for(int i=1; i&lt;=n; i++){ scanf(&quot;%lld&quot;,&amp;a[i]); add_edge(s,in[i],1,0);add_edge(out[i],t,1,0); add_edge(in[i],p,1,W); } for(int i=1; i&lt;=n; i++) b[i] = i; solve(1,n); printf(&quot;%lld\\n&quot;,dinic()); return 0;}","link":"/2023/09/21/SNOI2019-tongxin/"},{"title":"ZJOI2017 树状数组","text":"【题解】[ZJOI2017] 树状数组 题目描述： 漆黑的晚上，九条可怜躺在床上辗转反侧。难以入眠的她想起了若干年前她的一次悲惨的 OI 比赛经历。那是一道基础的树状数组题。 给出一个长度为 nnn 的数组 AAA，初始值都为 000，接下来进行 mmm 次操作，操作有两种： 1 x1\\ x1 x，表示将 AxA_xAx​ 变成 (Ax+1) mod 2(A_x + 1) \\bmod 2(Ax​+1)mod2。 2 l r2\\ l\\ r2 l r，表示询问 (∑i=lrAi) mod 2(\\sum_{i=l}^r A_i) \\bmod 2(∑i=lr​Ai​)mod2。 尽管那个时候的可怜非常的 simple，但是她还是发现这题可以用树状数组做。当时非常 young 的她写了如下的算法： 其中 lowbit(x)\\mathrm{lowbit}(x)lowbit(x) 表示数字 xxx 最低的非 000 二进制位，例如 lowbit(5)=1,lowbit(12)=4\\text{lowbit}(5) = 1, \\text{lowbit}(12) = 4lowbit(5)=1,lowbit(12)=4。进行第一类操作的时候就调用 Add(x)\\mathrm{Add}(x)Add(x)，第二类操作的时候答案就是 Query(l,r)\\mathrm{Query}(l, r)Query(l,r)。 如果你对树状数组比较熟悉，不难发现可怜把树状数组写错了：Add\\text{Add}Add 和 Find\\text{Find}Find 中 xxx 变化的方向反了。因此这个程序在最终测试时华丽的爆 0 了。 然而奇怪的是，在当时，这个程序通过了出题人给出的大样例——这也是可怜没有进行对拍的原因。 现在，可怜想要算一下，这个程序回答对每一个询问的概率是多少，这样她就可以再次的感受到自己是一个多么非的人了。然而时间已经过去了很多年，即使是可怜也没有办法完全回忆起当时的大样例。幸运的是，她回忆起了大部分内容，唯一遗忘的是每一次第一类操作的 xxx 的值，因此她假定这次操作的 xxx 是在 [li,ri][l_i, r_i][li​,ri​] 范围内等概率随机的。 具体来说，可怜给出了一个长度为 nnn 的数组 AAA，初始为 000，接下来进行了 mmm 次操作： 1 l r1\\ l\\ r1 l r，表示在区间 [l,r][l, r][l,r] 中等概率选取一个 xxx 并执行 Add(x)\\text{Add}(x)Add(x) 。 2 l r2\\ l\\ r2 l r，表示询问执行 Query(l,r)\\text{Query}(l, r)Query(l,r) 得到的结果是正确的概率是多少。 数据范围 测试点编号 nnn mmm 其他约定 101010 10510^5105 10510^5105 无 对于 100%100\\%100% 的数据，保证 1≤l≤r≤n1\\leq l\\leq r\\leq n1≤l≤r≤n。 题目分析： 事实证明不逼自己一把永远没有进步，我竟然独立地做出来了这道题，包括代码。 树状数组倒着做应该就是我们在学习树状数组的时候会接触到的奇技淫巧，倒着做的话每次查询就相当于后缀查询。 这样代码里查询答案时的 al−1−ara_{l-1} - a_ral−1​−ar​ 其实就是在 [l,r][l,r][l,r] 的答案的基础上新增加了 al−1a_{l-1}al−1​ 并且多删除了 ara_rar​，所以要使得其答案正确就是 al−1a_{l-1}al−1​ 和 ara_rar​ 的贡献可以相互抵消。 也就是 al−1=ara_{l-1} = a_ral−1​=ar​。 这里如果对于每一个数单独维护的话会出现相互影响就很不好做，一个经典的 trick 就是维护 al−1−ar=0a_{l-1} - a_r = 0al−1​−ar​=0，也就是维护它们的差值。 暴力的想法就是设 dpidp_idpi​ 表示 al−1−ara_{l-1} - a_ral−1​−ar​ 的差值为 iii 的概率，因为我们都是模 222 意义下的，所以差值只可能为 000 或者 111 然后从前到后扫每一个 111 操作更新 dpdpdp 值即可，这样的复杂度就是 O(q2)O(q^2)O(q2)。 考虑优化，也就是这个 dpdpdp 可以写成矩阵乘法的形式，所以我们只需要能快速维护对应的转移矩阵的乘积即可。 可以分类讨论： 对于 l,rl,rl,r，若一个区间只覆盖了其中一个点则会让差改变的概率为 1r−l+1\\frac{1}{r-l+1}r−l+11​，若一个区间同时覆盖了这两个点则会让差改变的概率为 2r−l+1\\frac{2}{r-l+1}r−l+12​。 所以就可以对于这个写出对应的矩阵，然后使用二维线段树快速维护矩阵乘法即可。 一个细节就是给定的代码里特判了若 xxx 为 000 则询问的值为 000，这个时候就是相当于 rrr 这个前缀与 rrr 这个后缀的值相同的时候答案才正确，所以可以再进行包含不包含 rrr 的分类讨论然后得到矩阵即可。 但是直接维护矩阵实在是太慢了，可以考虑维护差值变/不变的概率，然后类似矩阵乘法地形式合并即可。 因为变的概率+不变的概率为 111，所以只需要维护变的概率即可。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define PII pair&lt;int,int&gt;using namespace std;const int N = 1e5 + 500;const int MOD = 998244353;int val[200 * N][5];int tot,inv[10 * N],n,m,ls[200 * N],rs[200 * N],rt[10 * N];int times(int a,int b){ int c; c = (1ll * a * b % MOD + 1ll * (1-a)%MOD * (1-b) % MOD)%MOD; c = (c + MOD)%MOD; return c;}int power(int a,int b){ int res = 1; while(b){ if(b &amp; 1) res = 1ll * res * a % MOD; a = 1ll * a * a % MOD; b &gt;&gt;= 1; } return res;}void modify_y(int &amp;now,int now_l,int now_r,int pos,int len){ if(!now){ now = ++tot; for(int i=0; i&lt;=3; i++) val[now][i] = 1; } if(now_l == now_r){ int tmp; // 1 / len 的概率变 tmp = (1 - inv[len] + MOD)%MOD; val[now][0] = times(val[now][0],tmp); // 2 / len 的概率变 if(len &gt;= 2){ tmp = (1 - 1ll * 2 * inv[len]%MOD + MOD) % MOD; val[now][1] = times(val[now][1],tmp); } // 1 / len 的概率不变 tmp = inv[len]; val[now][2] = times(val[now][2],tmp); // 一定变 tmp = 0; val[now][3] = times(val[now][3],tmp); return; } int mid = (now_l + now_r)&gt;&gt;1; if(pos &lt;= mid) modify_y(ls[now],now_l,mid,pos,len); if(pos &gt; mid) modify_y(rs[now],mid+1,now_r,pos,len); for(int i=0; i&lt;=3; i++){ val[now][i] = 1; if(ls[now]) val[now][i] = times(val[now][i],val[ls[now]][i]); if(rs[now]) val[now][i] = times(val[now][i],val[rs[now]][i]); }}void modify_x(int now,int now_l,int now_r,int x,int y,int len){ modify_y(rt[now],1,n,y,len); if(now_l == now_r) return; int mid = (now_l + now_r)&gt;&gt;1; if(x &lt;= mid) modify_x(now&lt;&lt;1,now_l,mid,x,y,len); if(x &gt; mid) modify_x(now&lt;&lt;1|1,mid+1,now_r,x,y,len);}int query_y(int now,int now_l,int now_r,int l,int r,int opt){ if(!now) return 1; if(l &lt;= now_l &amp;&amp; now_r &lt;= r) return val[now][opt]; int mid = (now_l + now_r)&gt;&gt;1; int ans = 1; if(l &lt;= mid) ans = times(ans,query_y(ls[now],now_l,mid,l,r,opt)); if(r &gt; mid) ans = times(ans,query_y(rs[now],mid+1,now_r,l,r,opt)); return ans;}int query_x(int now,int now_l,int now_r,int xl,int xr,int yl,int yr,int opt){ if(xl &gt; xr || yl &gt; yr) return 1; if(xl &lt;= now_l &amp;&amp; now_r &lt;= xr) return query_y(rt[now],1,n,yl,yr,opt); int mid = (now_l + now_r)&gt;&gt;1; int ans = 1; if(xl &lt;= mid) ans = times(ans,query_x(now&lt;&lt;1,now_l,mid,xl,xr,yl,yr,opt)); if(xr &gt; mid) ans = times(ans,query_x(now&lt;&lt;1|1,mid+1,now_r,xl,xr,yl,yr,opt)); return ans;}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); inv[0] = 1; for(int i=1; i&lt;=n; i++) inv[i] = power(i,MOD-2); while(m--){ int opt,l,r;scanf(&quot;%d%d%d&quot;,&amp;opt,&amp;l,&amp;r); if(opt == 1) modify_x(1,1,n,l,r,r-l+1); if(opt == 2){ l = l-1; int ans; if(l == 0) ans = times(times(query_x(1,1,n,1,r-1,1,r-1,3),query_x(1,1,n,r+1,n,r+1,n,3)),query_x(1,1,n,1,r,r,n,2)); else ans = times(times(query_x(1,1,n,1,l,l,r-1,0),query_x(1,1,n,l+1,r,r,n,0)),query_x(1,1,n,1,l,r,n,1)); printf(&quot;%d\\n&quot;,ans); } } return 0;}","link":"/2023/09/19/ZJOI2017-shuzhuangshuzu/"},{"title":"ZJOI2018 胖","text":"【题解】[ZJOI2018] 胖 题目描述： Cedyks 是一个富有的男孩子。他住在著名的The Place（宫殿）中。 Cedyks 是一个努力的男孩子。他每天都做着不一样的题来锻炼他的The Salt（灵魂）。 这天，他打算在他的宫殿外围修筑一道城墙，城墙上有nnn 座瞭望塔。你可以把城墙看做一条线段，瞭望塔是线段上的nnn 个点，其中111 和nnn 分别为城墙的两个端点。其中第iii 座瞭望塔和第i+1i + 1i+1 座瞭望塔的距离为wiw_iwi​，他们之间的道路是双向的。 城墙很快就修建好了，现在Cedyks 开始计划修筑他的宫殿到城墙的道路。因为这题的题目名称，Cedyks 打算用他的宫殿到每一个瞭望塔的最短道路之和来衡量一个修建计划。 现在Cedyks 手上有mmm 个设计方案，第kkk 个设计方案会在宫殿和瞭望塔之间修建TkT_kTk​ 条双向道路，第iii 条道路连接着瞭望塔aia_iai​，长度为lil_ili​。 计算到每一个瞭望塔的最短路之和是一个繁重的工程，本来Cedyks 想用广为流传的SPFA算法来求解，但是因为他的butter（缓冲区）实在是太小了，他只能转而用原始的贝尔福特曼算法来计算，算法的流程大概如下： 定义宫殿是000 号点，第iii 个瞭望塔是iii 号点，双向边(ui,vi,li)(u_i, v_i, l_i)(ui​,vi​,li​) 为一条连接uiu_iui​ 和viv_ivi​ 的双向道路。令ddd 为距离数组，最开始d0=0,di=1018(i∈[1,n])d_0 = 0, d_i = 10^{18}(i ∈ [1, n])d0​=0,di​=1018(i∈[1,n])。 令辅助数组c=dc = dc=d。依次对于每一条边(ui,vi,wi)(ui, vi,wi)(ui,vi,wi) 进行增广，cui=min(cui,dvi+wi)c_{u_i} = min(c_{u_i} , d_{v_i} + w_i)cui​​=min(cui​​,dvi​​+wi​)，cvi=min(cvi,dui+wi)c_{v_i} = min(c_{v_i} , d_{u_i} + w_i)cvi​​=min(cvi​​,dui​​+wi​)。 令ttt 为ccc 和ddd 中不一样的位置个数，即令S={i∣ci≠di}S = \\{i|c_i≠d_i\\}S={i∣ci​=di​}，则t=∣S∣t = |S|t=∣S∣。若t=0t = 0t=0，说明ddd就是最终的最短路，算法结束。否则令d=cd = cd=c，回到第二步。 因为需要计算的设计方案实在是太多了，所以Cedyks 雇佣了一些人来帮他进行计算。为了避免这些人用捏造出来的数据偷懒，他定义一个设计方案的校验值为在这个方案上运行贝尔福特曼算法每一次进入第三步ttt 的和。他会让好几个雇佣来的人计算同样的设计方案，并比对每一个人给出的校验值。 你是Cedyks 雇佣来的苦力之一，聪明的你发现在这个情形下计算最短路的长度的和是一件非常简单的事情。但是寄人篱下不得不低头，你不得不再计算出每一个方案的校验值来交差。 数据范围 测试点 nnn mmm KKK 其他约定 7,8,9,10 ≤2×105\\le 2 \\times 10^5≤2×105 ≤2×105\\le 2 \\times 10^5≤2×105 ≤2×105\\le 2 \\times 10^5≤2×105 无 对于 100%100\\%100% 的数据，保证每个设计方案 aia_iai​ 两两不同且 1≤ai≤n1\\le a_i\\le n1≤ai​≤n 。 对于 100%100\\%100% 的数据，保证 1≤wi,li≤109,1≤∑K≤2×1051\\le w_i,l_i\\le 10^9,1\\le\\sum K\\le 2\\times 10^51≤wi​,li​≤109,1≤∑K≤2×105 。 题目分析： 我们不妨将通过额外的边连接的点称为特殊点。 可以发现任意一条到点 xxx 可能的最短路径都必然是经过一条额外的边到达 yyy 然后再直接从 yyy 走到 xxx。 题目要我们求的其实就是当可走的边数逐个变多时，最短路的变化次数，可以考虑枚举每一个点，然后判断这个点的最短路变化了多少次。 具体来说就是按距离这个点的远近，从近到远地枚举每一个特殊点然后更新最短路，这样复杂度就是 O(nk)O(nk)O(nk) 十分炸裂。 既然枚举点不行，就考虑枚举特殊点，然后判断这个特殊点可以对多少个点产生贡献。 可以发现的一点就是点 iii 可以更新的点一定是包含 iii 的一段区间 [l,r][l,r][l,r]，因为如果更新点 xxx 不优，那么更新其更靠外的点一定也不优。 那么下面就是可以二分一个左右端点，问题转化为了判断点 iii 是否可以更新点 jjj。 如果点 iii 可以更新点 jjj，当且仅当距离 jjj 不超过 ∣i−j∣|i-j|∣i−j∣ 的点中，iii 是最优的点（严格最优），当然如果距离为 ∣i−j∣|i-j|∣i−j∣ 的另一个点与 iii 一样优且距离更小的点更劣，那么我们默认在左边的点统计答案。 可以将距离拆一下，即； 若 i&lt;ji &lt; ji&lt;j，则 disi,j=sufi−sufj+lidis_{i,j} = suf_i - suf_j + l_idisi,j​=sufi​−sufj​+li​ 若 i&gt;ji &gt; ji&gt;j，则 disi,j=sufj−sufi+lidis_{i,j} = suf_j - suf_i + l_idisi,j​=sufj​−sufi​+li​ 所以对于第一种情况只需要维护 sufi+lisuf_i + l_isufi​+li​ 的最小值，第二种情况只需要维护 −sufi+li-suf_i+l_i−sufi​+li​ 的最小值，然后就可以判断了。 维护可以使用线段树。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2e5+5;const int INF = 1e18+5;int n,m,dis[N],len[N],p[N];struct SGT{ int mn[20 * N],ls[20 * N],rs[20 * N],tot,rt; void modify(int &amp;now,int now_l,int now_r,int pos,int val){ if(!now) now = ++tot; if(now_l == now_r){ mn[now] = min(mn[now],val); return; } int mid = (now_l + now_r)&gt;&gt;1; if(pos &lt;= mid) modify(ls[now],now_l,mid,pos,val); if(pos &gt; mid) modify(rs[now],mid+1,now_r,pos,val); mn[now] = min(mn[now],val); } int query(int now,int now_l,int now_r,int l,int r){ if(!now) return INF; if(l &lt;= now_l &amp;&amp; now_r &lt;= r) return mn[now]; int mid = (now_l + now_r)&gt;&gt;1,ans = INF; if(l &lt;= mid) ans = min(ans,query(ls[now],now_l,mid,l,r)); if(r &gt; mid) ans = min(ans,query(rs[now],mid+1,now_r,l,r)); return ans; } void clean(int now){ mn[now] = INF; if(ls[now]) clean(ls[now]),ls[now] = 0; if(rs[now]) clean(rs[now]),rs[now] = 0; }}T1,T2;bool chk(int x,int y){ //y 是否可以更新 x int len = abs(y - x); if(y &gt; x){ int tmp = min(T1.query(T1.rt,1,n,x-len,x)-dis[x],dis[x]+T2.query(T2.rt,1,n,x,x+len-1)); if(tmp &lt;= dis[x]+T2.query(T2.rt,1,n,y,y)) return false; return true; } else{ int tmp = min(T1.query(T1.rt,1,n,x-len+1,x)-dis[x],dis[x]+T2.query(T2.rt,1,n,x,x+len-1)); if(tmp &lt;= T1.query(T1.rt,1,n,y,y)-dis[x]) return false; tmp = dis[x]+T2.query(T2.rt,1,n,x+len,x+len); if(tmp &lt; T1.query(T1.rt,1,n,y,y)-dis[x]) return false; return true; }}int get_l(int pos){ int l = 1,r = pos,ans = pos; while(l &lt;= r){ int mid = (l + r) &gt;&gt; 1; if(chk(mid,pos)) ans = mid,r = mid - 1; else l = mid + 1; } return ans;}int get_r(int pos){ int l = pos,r = n,ans = pos; while(l &lt;= r){ int mid = (l + r) &gt;&gt; 1; if(chk(mid,pos)) ans = mid,l = mid + 1; else r = mid - 1; } return ans;}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); memset(T1.mn,0x3f,sizeof(T1.mn)); memset(T2.mn,0x3f,sizeof(T2.mn)); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=1; i&lt;n; i++) scanf(&quot;%lld&quot;,&amp;dis[i]); for(int i=n-1; i&gt;=1; i--) dis[i] += dis[i+1]; while(m--){ int k;scanf(&quot;%lld&quot;,&amp;k); for(int i=1; i&lt;=k; i++){ scanf(&quot;%lld%lld&quot;,&amp;p[i],&amp;len[i]); T1.modify(T1.rt,1,n,p[i],dis[p[i]]+len[i]); //T1 就是在左边 T2.modify(T2.rt,1,n,p[i],len[i]-dis[p[i]]); //T2 就是在右边 } int ans = 0; for(int i=1; i&lt;=k; i++){ int L = get_l(p[i]); int R = get_r(p[i]); ans += R - L + 1; } printf(&quot;%lld\\n&quot;,ans); T1.clean(T1.rt);T1.rt = T1.tot = 0; T2.clean(T2.rt);T2.rt = T2.tot = 0; } return 0;}","link":"/2023/09/19/ZJOI2018-pang/"},{"title":"高斯消元","text":"从零开始的高斯消元 说在前面： 高斯消元看上去是一个很复杂的东西，但是其实只要是理解了就会发现也就那样的 算法功能： 解方程组。 没错就是如此的简单，就是去解方程组。但是高斯消元一般是用来解决含有上百个未知数的方程组。 其时间复杂度为 O(n3)O(n^3)O(n3) 算法详解： 下面我就来介绍一下高斯消元的最简单的应用，也就是解正常的一次方程组。 比如我们有以下的方程组： {3x1+4x2+x3=95x1+10x2+7x3=52x1+7x2+3x3=10\\left\\{ \\begin{array}{} 3x_1 + 4x_2 + x_3 = 9 \\\\ 5x_1 + 10x_2 + 7x_3 = 5 \\\\ 2x_1 + 7x_2 + 3x_3 = 10 \\end{array} \\right. ⎩⎪⎨⎪⎧​3x1​+4x2​+x3​=95x1​+10x2​+7x3​=52x1​+7x2​+3x3​=10​ 在高斯消元的过程中我们会将它转化为一个矩阵，矩阵里第 iii 行代表第 iii 个式子，第 jjj 列代表第 jjj 个未知数的系数，其中第 n+1n+1n+1 也就是最后一列，代表常数项，也就是等于号后面的数 那么以上的这个方程组就会被写为： [x1x2x3C34195107527310]\\begin{bmatrix} x_1 &amp; x_2 &amp; x_3 &amp; C \\\\ 3 &amp; 4 &amp; 1 &amp; 9 \\\\ 5 &amp; 10 &amp; 7 &amp; 5 \\\\ 2 &amp; 7 &amp; 3 &amp; 10 \\\\ \\end{bmatrix} ⎣⎢⎢⎢⎡​x1​352​x2​4107​x3​173​C9510​⎦⎥⎥⎥⎤​ 这个时候可能会很懵，但是一定要静下心来仔细看看这个矩阵和上面的方程组 我们高斯消元的思想就是加减消元，就是我们在小学会学习到的那个知识 加减消元的解释：（如果会了就请跳过，避免看了之后有点晕） 比如我们有以下一个二元一次方程组： {3x+2y=6(1)x+3y=2(2)\\left\\{ \\begin{array}{} 3x + 2y = 6 &amp; (1)\\\\ x + 3y = 2 &amp; (2) \\end{array} \\right. {3x+2y=6x+3y=2​(1)(2)​ 那么如何进行加减消元呢？ 我们考虑先消掉 xxx 很简单：(1)−3×(2)(1) - 3 \\times (2)(1)−3×(2) 这样就能得到 −7y=0-7y = 0 −7y=0 我们就成功地将 xxx 这个未知数消掉了，接下来就只剩下了一个未知数，很明显就可以直接算出来 y=0y = 0y=0，然后将这个值带回去，就能解出 x=2x = 2x=2 我们在高斯消元中，就是用加减消元，从第一个未知数开始一个一个地消，直到消到只剩下一个未知数就能很轻松地能将方程解出来 按我的代码习惯而言，就是将每一个式子都消掉只剩一个未知数，这样 nnn 个式子每个式子对应一个未知数就很好地能解出来 代码详解： 下面先放代码，根据代码一点点来解释 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;double a[105][105];int n;bool Gauss(){ for(int i=1; i&lt;=n; i++){ //第几个未知数/第几列 int mx = i; //先让最大值为 i; for(int j = i+1; j&lt;=n; j++){ //找到第 i 列上绝对值最大的那个数在第几行 //前 i-1 行已经有了自己的位置，就是自己有独特的保留的未知数了，再次将他设为 i 需要的值 //那么它本身的那个数就没了 if(fabs(a[j][i]) &gt; fabs(a[mx][i])){ mx = j; } } //我们认为第 i 行就是仅包含第 i 个未知数的那一行 if(mx != i){ //交换两行，需要全部交换 for(int j=1; j&lt;=n+1; j++){ swap(a[i][j],a[mx][j]); } } if(!a[i][i]){ //这一列都是 0 ，所以说这一列对未知数没有限制，也就是有可以任意取值的未知数 printf(&quot;No Solution&quot;); return false; } for(int j=1; j&lt;=n; j++){ if(j != i){ double tmp = a[j][i] / a[i][i]; //代表要减多少倍才能将这一行的第 i 个未知数消掉，因为要减一起减，所以就全部减了 for(int k = i; k&lt;=n+1; k++){ //因为前 i 列已经被之前消没了，就全是 0 了 a[j][k] -= a[i][k] * tmp; } } } } return true;}int main(){ cin&gt;&gt;n; for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=n+1; j++){ cin&gt;&gt;a[i][j]; } } if(Gauss()){ for(int i=1; i&lt;=n; i++){ printf(&quot;%.2f\\n&quot;,a[i][n + 1] / a[i][i]); } } return 0;} 我们就顺着代码一点点来看，这里的高斯消元部分也就是那个 Gauss()Gauss()Gauss() 函数（可能有点长，但是耐心读一读应该会有所收获） 首先最外层循环，枚举当前消到了哪一个未知数，也就是该消哪一个了。 注意我上文的解释，既然枚举到了这一个未知数，那么按照我的码风来说，前 i−1i-1i−1 个未知数是都被消没了的，因为如果没有消没，就不可能再将后面的式子都化为只含有一个未知数的式子 然后就继续往下看。 下面的这个 forforfor 循环就是在寻找当前未知数中绝对值最大的是谁在哪一个式子里，然后我们就要将别的式子通过加减我们找到的这个式子，来将当前的未知数消掉。 而且我们默认有一点：第 iii 个式子其最后只含有第 iii 个未知数，所以我们的 jjj 是从 iii 开始枚举，一开始第 iii 行被认为是最大的一行，也相当于枚举了，也就有了下面的 ififif 里面的交换操作。 注意对于交换完了之后第 iii 个式子就是我们找到的当前未知数绝对值最大的一个式子，那么第 iii 行的第 iii 列，也就是第 iii 个未知数绝对值最大的那个数 继续最后的一个循环，就是用第 iii 行的这个式子去消其他的式子，也就是将其他行的第 iii 个未知数消去，让他们的系数全都变成 000 其他的不用我多说，我代码里写的也很清楚，也很简单，重点在于 kkk 的范围 [i,n+1][i,n+1][i,n+1]，是不是有种很懵的感觉 不着急，我们一点点看，先看左边界 iii ，因为我们消元就是将除了第 iii 个式子之外的所有式子中含有的未知数 iii 的系数全部变成 000，那么就意味着当我们枚举到 iii 的时候前 i−1i-1i−1 个未知数，也就是前 i−1i-1i−1 行，一定都被全消成 000 了，那么此时我们再去枚举这些本来就是 000 的地方，想让他变成 000 也就没有任何意义了。 再来看右边界 n+1n+1n+1，我们考虑第 n+1n+1n+1 列存的是什么，存的是不是就是我们的常数项啊，在我们加减消元的过程中常数项也是需要加减的，因为这样才会满足等式的性质，等于号才不变 如果有感觉我哪里解释的不对或者不清楚，欢迎给我留言","link":"/2022/04/25/gao-si-xiao-yuan/"},{"title":"轻重链剖分","text":"树链剖分的部分理解，推荐阅读前有一定了解 对算法本身的部分理解 12345678if (son[now]) dfs2(son[now], topf)for (int i = head[now] i; i = e[i].nxt) { int to = e[i].to; if (to != fa[now] &amp;&amp; to != son[now]) { dfs2(to, to); }} 这是第二遍 dfsdfsdfs，定义：son[now]son[now]son[now] 为 nownownow 点的重儿子，topftopftopf 为当前的重链上深度最小的一个点也就是开始的点。我们在遍历整棵树的时候，会选择先去遍历这个点的左儿子然后再去管其他的点。我们在这一遍遍历其实就是在给他们分配线段树上的基本信息以及记录轻重链的基本信息，在我们的轻重链剖分的时候，是会将重链看作是线段树上维护的的一段连续区间，先访问重儿子可以使得其的重儿子在线段树上的维护的下标为它加一，也就是说是连续的，也就是一条重链对应连续的一段。 这是寻找 x,yx,yx,y 树上路径的相关信息，定义：top[x]top[x]top[x] 为 xxx 节点所在的重链的深度最小的节点（这里节点均为树上的编号），也就是这条重链的开始，dep[x]dep[x]dep[x] 为 xxx 节点在树上的深度，id[x]id[x]id[x] 为节点 xxx 在线段树上的编号。也就是这几行代码是在查询树上 x,yx,yx,y 节点之间的路径上经过的节点的权值和。我们一点点地去看。 首先看循环内部，第一个判断条件就是寻找一个重链的起点深度最大的一个，也就是树上最靠下的一个，然后查询这条重链的信息后就直接跳出这条重链，我们考虑跳深度大的一条链一定不会跳过头，而跳深度小的一条链可能会跳过头了，如下图所示： 我们以红色边代表重边，以黑色边代表轻边，我们看在这样的情况下如果直接去跳过 yyy 所在的这条重链，那么就会跳到节点 111 很明显这不正确，所以就会选择跳 xxx 所在的这条重链，这样不可能会跳出去我们的正确路径。 再看下边的线段树的询问，因为我们的分配线段树上的基本信息是自根到底，所以深度小的节点在线段树上的编号就小，深度大的节点在线段树上的深度就大，所以查询的区间左端点是这条重链的开始，右端点是它本身。 再看下边关于跳过这条重链的情况，我们的 xxx 跳要跳到其重链的开始的父亲节点，因为如果我们不是跳到父亲结点的话，我们一是会将其重链开始的节点的信息重复计算，二是我们可能下一次跳还是选择这一条重链，但是它的起点就是当前的 xxx 节点，所以就死循环了。 翻过来看一眼循环条件，这个循环条件相当于是在约束 x,yx,yx,y 不在同一条重链上，因为我们循环是在跳重链，所以如果它们在同一条重链上那么这条重链肯定不能直接跳过了，就应该直接在这条重链上去询问 x,yx,yx,y 的线段树上的相关信息，因为他们在同一重链，所以编号一定是连续的，直接询问那一段就可以了。 最后三行，因为深度大的节点线段树上的编号也大，所以线段树上的区间就是从深度小的节点到深度大的节点。 注意： 我们所给他们分配的线段树上维护的下标或者叫编号就相当于 dfsdfsdfs 序，所以满足 dfsdfsdfs 具有的性质。","link":"/2022/03/29/heavy-light-decomp/"},{"title":"后缀数组","text":"对于后缀数组的浅谈，推荐阅读前有一定了解 对算法本身的部分理解： 本部分可以认为是读过一位大佬的后缀数组博客的感受，加上对于某些地方我感觉大佬解释的不是很明白，所以还有一部分我自己对这一部分的理解与解释，当然只是部分我认为不是很懂的内容，只是一部分，更多还要去看这位大佬的博客。 第一行： 这就相当于对于一个字符串，其没有后 www 位，既然没有后 www 位，那就应该是排在前面 第二行： 首先不用管所谓的 sa[i]&gt;wsa[i] &gt; wsa[i]&gt;w，这只是个特判没有任何意义，其实也就是为了保证存在而已，也暂时不用考虑第一条语句所提前处理出来的一些数据。 我们现在必须搞清楚我们要求什么，求的也就是 tptptp 数组，其中 tp[i]tp[i]tp[i] 代表长度为 $2\\times w $ 的串中，只看后 www 个元素排名为 iii 的串的起始位置 对于 sa[i]−wsa[i] - wsa[i]−w 就是让原本的长度为 www 的后缀中排名为 iii 的那个的起始位置左移 www 位，那么是不是也就相当于 sa[i]−wsa[i]-wsa[i]−w 就是代表着左右长度为 2×w2 \\times w2×w 的后缀中，按后 www 个元素排序的第 iii 个串的起始位置。我们考虑 sa[i]sa[i]sa[i] 代表着长度为 www 的后缀中排名为 iii 的那个元素的排名，那么对于长度为 2×w2\\times w2×w 的串来说，sa[i]sa[i]sa[i] 其实就相当于某一个长度为 2×w2\\times w2×w 的串的后缀，那么这个串很明显就是 sa[i]−wsa[i] - wsa[i]−w 为开始的串。注意 sa[i]sa[i]sa[i] 里存的也是起始位置。 因为我们的 iii 从小到大枚举，所以我们直接计数器累加即可 我们考虑此时 sa[i]sa[i]sa[i] 就是长度为 www 的串中排名为 iii 的串起始位置，tp[i]tp[i]tp[i] 就是所有长度为 2×w2\\times w2×w 的串中后按 www 个元素排序，排名为 iii 的串的起始位置， rk[i]rk[i]rk[i] 就是所有长度为 www 的串中以 iii 为开头的串排第几。我们的基数排序就是以 rkrkrk 为第一关键字以 tptptp 为第二关键字的排序，此时这两个关键字都处理好了，所以直接排序得到新的 sasasa 数组即可 我们首先必须明确 tax[i]tax[i]tax[i] 代表按前 www 个元素排名，排名小于等于 iii 的串的个数，也就是代表着按前 www 个元素排名，排名为 iii 的元素的排名加排名为 iii 的串的个数 前三行非常好理解，就是为了得到 taxtaxtax 数组，关键在与最后一行非常难以理解。 我们先一点点地看 rak[tp[i]]rak[tp[i]]rak[tp[i]] 代表的含义就是长度为 2×w2\\times w2×w 的串中，后 www 个元素排名为 iii 的那个位置的前 www 个元素的排名 tax[rak[tp[i]]]tax[rak[tp[i]]]tax[rak[tp[i]]] 也就是代表着长度为 2×w2\\times w2×w 的串中，后 www 个元素排名为 iii 的那个位置的前 www 个元素的排名，注意这里的最后的排名是指被分到的排名 $tax[rak[tp[i]]] – $ 关于这个自减的理解，我们考虑就是对于按第一关键字也就是前 www 个元素排名相同的点，因为我们的第二关键字不一定相同所以我们的最终他们虽然第一关键字一定一样但是第二关键字不一定一样，因此被分到的排名也不一定相同（可能有点绕），注意我们的循环顺序，也就是枚举的顺序，我们是按第二关键字从大到小去枚举，也就意味着当这个长度为 $2\\times w $ 的字串的第一关键字也就是前 www 个元素排名相同时，我们第二关键字也就是按后 www 个元素的排名越大被分到的最终排名也就越大，也就符合了我们按双关键字排序的目的。 sa[tax[rak[tp[i]]]−−]=tp[i]sa[tax[rak[tp[i]]]−−] = tp[i]sa[tax[rak[tp[i]]]−−]=tp[i] 也就相当于排名为 tax[rak[tp[i]]]−−tax[rak[tp[i]]]−−tax[rak[tp[i]]]−− 的串的起始位置也就是 tp[i]tp[i]tp[i] 这个串的起始位置，也就是 tp[i]tp[i]tp[i] 这里就是对 rkrkrk 数组的更新 对于这里的 tp[i]tp[i]tp[i] 代表长度为 www 的串里起始位置为 iii 的串的排名，也就是我们之前的 rkrkrk 数组， sa[i]sa[i]sa[i] 代表长度为 2×w2\\times w2×w 的串里，排名为 iii 的串的起始位置 我们这里其实就是在判断排名为 iii 的串和排名为 i−1i-1i−1 的串的排名是否相同，第一个判断也就相当于他们前 www 个元素是相同的，第二个判断也就相当于他们的后 www 个元素是相同的，所以如果两个全部满足，也就意味着 2×w2\\times w2×w 个元素都是相同的，也就意味着 iii 与 i−1i-1i−1 的排名相同 关于 heightheightheight 数组的更新： 对于 heightheightheight 数组某大佬证明了一个定理： H[i]≥H[i−1]−1H[i]\\ge H[i-1] - 1H[i]≥H[i−1]−1 我们对 heightheightheight 数组的定义，排名为 iii 的后缀与排名为 i−1i-1i−1 的后缀的最长公共前缀的长度，即 height[i]=lcp(sa[i],sa[i−1])height[i]=lcp(sa[i],sa[i-1])height[i]=lcp(sa[i],sa[i−1]) 。 我们定义 H[i]=height[rak[i]]=lcp(sa[rak[i]],sa[rak[i]−1])=lcp(i,sa[rak[i]−1])H[i] = height[rak[i]] = lcp(sa[rak[i]],sa[rak[i]-1])=lcp(i,sa[rak[i]-1])H[i]=height[rak[i]]=lcp(sa[rak[i]],sa[rak[i]−1])=lcp(i,sa[rak[i]−1]) 也就是第 iii 号后缀与排名在第 iii 号后缀前一个的后缀的最长公共前缀的长度，这里的所谓的前一个后缀的起始位置也就是 sa[rak[i]−1]sa[rak[i] - 1]sa[rak[i]−1] ，对于 HHH 数组直接根据定义加下界去算就可以了，算完了更新 height[rak[i]]height[rak[i]]height[rak[i]] 即可","link":"/2022/03/29/hou-zhui-shu-zu/"},{"title":"金牌导航-高斯消元&#x2F;Luogu P3232 游走","text":"这应该是我们做的除模板外的第一道高斯消元吧（我是的） 题目描述： 详细分析： 我们对于编号的分配，很明显可以发现如下的分配就是期望最小的：对经过的期望次数越大的边赋予更小的编号。 那么问题就转化为了怎么求一条边的经过的期望次数，我们发现边数非常大所以肯定不好弄，所以我们就转而看很少的点。因为我们会发现如果我们能知道经过每个点的期望次数，那么这条边的期望次数很轻松就能表达出来。 比如如下的式子：（设 ans[i]ans[i]ans[i] 为经过第 iii 个点的期望次数, du[i]du[i]du[i] 为第 iii 个点的度数, res[i]res[i]res[i] 为经过第 iii 条边的期望次数） res[i]=ans[from]du[from]+ans[to]du[to]res[i] = \\dfrac{ans[from]}{du[from]} + \\dfrac{ans[to]}{du[to]} res[i]=du[from]ans[from]​+du[to]ans[to]​ 这个式子应该很好理解，就是说每个点等概率地选择和他相连的边，所以选择这一条边地期望次数就是经过它的期望次数除以它的度数，也就是与他相连的边的数量，因为这条边可以从两个端点开始走然后经过，所以应该加上两个端点的值。 上文探讨了如果知道经过所有点的期望次数如何求经过这条边的期望，那么下文就来看看如何求经过每个点的期望次数。 很明显可以列出这样的一个式子： ans[i]=∑ans[to]du[to]ans[i] = \\sum \\dfrac{ans[to]}{du[to]} ans[i]=∑du[to]ans[to]​ 注意 tototo 是指所有与 iii 有边直接相连的点，tototo 不包含 nnn 号节点，因为这个式子的含义从是 tototo 等概率地回到 iii 节点，可是 nnn 号节点就停了，也就不存在再走回来的情况了 但是其实还有一种特殊情况，就是对于 111 号节点，其作为初始节点所以一定在开始时被经过一次，所以其不仅要计算从别的点到来的期望次数，更要算其一开始的这一次 ans[1]=1+∑ans[to]du[to]ans[1] = 1 + \\sum \\dfrac{ans[to]}{du[to]} ans[1]=1+∑du[to]ans[to]​ 我们会发现上文的这个式子会出现循环依赖的情况,就是假设 AAA 的值需要 BBB 的值才能推出来，但是 BBB 也同样需要 AAA 才能推出来。而且我们考虑这个式子不含有最大值最小值的操作，所以就考虑使用高斯消元，把这个式子化成一个方程，然后求解. 那么既然要高斯消元就要考虑我们的未知数是什么,我们的系数是什么,常数是什么,这一切都是根据我上面的式子得出来的. 首先未知数肯定非常容易,就是我们不知道的数嘛,那我们不知道什么?就是 ansansans 数组啊,所以 ansansans 就是我们的未知数, ans[i]ans[i]ans[i] 就代表我们的第 iii 个未知数. 这个明白了之后剩下的就非常简单的,考虑对上面的式子进行转化 ans[i]−∑1du[to]×ans[to]=0ans[i] - \\sum \\dfrac{1}{du[to]} \\times ans[to] = 0 ans[i]−∑du[to]1​×ans[to]=0 很明显 dududu 数组我们是知道的,又发现有一个 1du[to]×ans[to]\\dfrac{1}{du[to]} \\times ans[to]du[to]1​×ans[to] 的项,所以 dududu 数组就理所应当的成为了我们的系数 会发现了常数项除了 ans[1]ans[1]ans[1] 的方程含有一个 111 ,其他的都是 000. 注意在代码里我的 aaa 数组开的二维,因为我们的高斯消元需要知道第几个方程,所以就按照第一个点的顺序给方程编了号,所以 aaa 数组的第一维就是编号,第二维才是我们的未知数,这也就与正常的高斯消元一样了 代码详解: 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-6;const int MAXN = 505;const int MAXM = 130000;struct edge{ int nxt,to; edge(int _nxt = 0,int _to = 0){ nxt = _nxt,to = _to; }}e[2 * MAXM];double a[MAXN][MAXN];double ans[MAXN],res[MAXM];int from[MAXM],to[MAXM],head[MAXN],du[MAXN];int n,m,cnt;void Gauss(int n){ //推荐里面写一个 n ，然后直接按模板敲就好了 for(int i=1; i&lt;=n; i++){ int mx = i; for(int j=i + 1; j&lt;=n; j++){ if(fabs(a[j][i]) &gt; fabs(a[mx][i])){ mx = j; } } if(mx != i) { for(int j=1; j&lt;=n+1; j++){ swap(a[i][j],a[mx][j]); } } for(int j=1; j&lt;=n; j++){ if(j != i){ double tmp = a[j][i] / a[i][i]; for(int k=i; k&lt;=n+1; k++){ a[j][k] -= tmp * a[i][k]; } } } } for(int i=1; i&lt;=n; i++){ //ans[i] 即我们最后解出来的解 ans[i] = a[i][n+1] / a[i][i]; }}void add_edge(int from,int to){ e[++cnt] = edge(head[from],to); head[from] = cnt;}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=m; i++){ cin&gt;&gt;from[i]&gt;&gt;to[i]; add_edge(from[i],to[i]); add_edge(to[i],from[i]); du[from[i]]++;du[to[i]]++; } for(int i=1; i&lt;n; i++){ //注意一点，因为到 n 就停了，所以 n 的期望等就不用算了 a[i][i] = 1; //根据我们的式子可以化出来 for(int j=head[i]; j; j = e[j].nxt){ int to = e[j].to; if(to != n){ //注意 to != n a[i][to] = -1.0/du[to]; //根据我们的式子可以化出来 } } } a[1][n] = 1; //根据式子可以化出来 Gauss(n-1); for(int i=1; i&lt;=m; i++){ if(from[i] != n){ res[i] += ans[from[i]] / du[from[i]]; //到达这个点的期望除以度数，就是从这个点到当前点的期望 } if(to[i] != n){ res[i] += ans[to[i]] / du[to[i]]; } } sort(res+1,res+m+1); //从小到大排边 //一定要相信 STL,如果自己写一个 cmp（例如我），就会造成神奇的精度问题 double h = 0; for(int i=1; i&lt;=m; i++){ //越大的期望的边给他越小的编号 h += res[i] * (m - i + 1); } printf(&quot;%.3f&quot;,h); return 0;} 我的上文对这个代码的解释应该也比较合理了,如果有任何疑问或者感觉我说的不对的地方欢迎大家留言或者私信我","link":"/2022/04/26/jinpaidaohang-gaosixiaoyuan-Luogu-P3232-youzou/"},{"title":"金牌导航 凸包-稳定凸包","text":"【题解】金牌导航-凸包-稳定凸包 题面： 做法详解： 考虑一个什么样的凸包是一个稳定的凸包（推荐自己画画图，就理解了） 若对于凸包上的每一条边，都有包含其端点在内至少三个不同位置的点，那么这就肯定是一个稳定的凸包。 考虑若只有两个点，那么在其外面在加入一个点，那么这个点与其对应的这条边可以同时被计算入新的凸包 考虑若有三个及更多的点，那么在其外面加入一个点，这条边上除了两个端点之外的那些点就不可能再计入新的凸包里了，所以这就是一个稳定的凸包 实现起来非常好搞：对于每一条凸包上的边统计有多少个点在这条边上，注意这些点不一定要是凸包上的点 小细节： （1）可能会有重复的点，那么这样的点肯定不能被算多次，所以要去重 （2）考虑若凸包就是一条线，那么肯定不会是一个稳定的凸包，因为在其延长线上再随意找一个点也可以形成一个包含所有点的新凸包 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e3+4;struct V{ int x,y; V(int _x = 0 ,int _y = 0){ x = _x,y = _y; }}q[MAXN],a[MAXN],tmp[MAXN];int head,n;V operator - (V l,V r){ return V(l.x - r.x,l.y - r.y);}int operator * (V l,V r){ return l.x * r.y - l.y * r.x;}int dot(V l,V r){ return l.x * r.x + l.y * r.y;}int len(V l){ return sqrt(l.x * l.x + l.y * l.y);}bool cmp(V l,V r){ V u = (l - a[1]),w = (r - a[1]); int h = u * w; if(h != 0){ return h &gt; 0; } if(l.x != r.x) return l.x &lt; r.x; return l.y&lt;r.y;}bool cmp_x(V l,V r){ if(l.x != r.x) return l.x &lt; r.x; return l.y &lt; r.y;}void Graham(){ int pos = 1; for(int i=2; i&lt;=n; i++){ if(a[i].x &lt; a[pos].x || (a[i].x == a[pos].x &amp;&amp; a[i].y &lt; a[pos].y)){ pos = i; } } if(pos != 1){ swap(a[pos],a[1]); } sort(a+2,a+n+1,cmp); for(int i=1; i&lt;=n; i++){ while(head &gt;= 2 &amp;&amp; (a[i] - q[head -1]) * (q[head] - q[head - 1]) &gt;= 0){ head--; } q[++head] = a[i]; } q[head + 1] = q[1];}bool in_line(V p,V from,V to){ int h = (from - p) * (to - p); if(h != 0) return false; return dot((from - p),(to - p)) &lt;= 0;}bool check_ans(V from,V to){ int res = 0; for(int i=1; i&lt;=n; i++){ if(in_line(a[i],from,to)) res++; if(res &gt;= 3) return true; } return res &gt;= 3;}int cross(V x,V y,V z){ return (y - x) * (z - x);}int Area(){ int res = 0; for(int i=1; i&lt;=head; i++){ res += q[i] * q[i+1]; } return res;}int main(){ int t; cin&gt;&gt;t; while(t--){ head = 0; int h; cin&gt;&gt;h; for(int i=1; i&lt;=h; i++){ cin&gt;&gt;tmp[i].x&gt;&gt;tmp[i].y; } sort(tmp+1,tmp+h+1,cmp_x); a[1] = tmp[1]; n = 1; for(int i=2; i&lt;=h; i++){ if(tmp[i].x != tmp[i-1].x || tmp[i].y != tmp[i-1].y) a[++n] = tmp[i]; } Graham(); bool flag = false; for(int i=1; i&lt;=head; i++){ if(!check_ans(q[i],q[i+1])){ printf(&quot;NO\\n&quot;); flag = true; break; } } if(Area() == 0 &amp;&amp; !flag){ printf(&quot;NO\\n&quot;); } else if(!flag){ printf(&quot;YES\\n&quot;); } } return 0;}","link":"/2022/04/18/jinpaidaohang-tubao-wendingtubao/"},{"title":"数学知识","text":"大概就是一个数学知识的梳理，可能会有一些地方写的并不是很全很好，未来可能会补。 模意义下的数论 欧几里得算法 gcd⁡(a,b)=gcd⁡(b,a%b)\\gcd(a,b) = \\gcd(b,a\\% b) gcd(a,b)=gcd(b,a%b) 扩展欧几里得算法 求解： ax+by=gcd⁡(a,b)ax + by = \\gcd(a,b) ax+by=gcd(a,b) 分析： 设 ax1+by1=gcd⁡(a,b)ax_1 + by_1 = \\gcd(a,b)ax1​+by1​=gcd(a,b)，bx2+(a%b)y2=gcd⁡(b,a%b)bx_2 + (a\\%b)y_2 = \\gcd(b,a\\%b)bx2​+(a%b)y2​=gcd(b,a%b)。 根据欧几里得算法则 gcd⁡(a,b)=gcd⁡(b,a%b)\\gcd(a,b) = \\gcd(b,a\\%b)gcd(a,b)=gcd(b,a%b)，也就是说： ax1+by1=bx2+(a%b)y2ax_1 + by_1 = bx_2 + (a\\%b)y_2 ax1​+by1​=bx2​+(a%b)y2​ 根据 a%b=a−⌊ab⌋×ba \\% b = a - \\lfloor \\frac{a}{b} \\rfloor \\times ba%b=a−⌊ba​⌋×b，则有： ax1+by1=bx2+(a−⌊ab⌋×b)y2ax_1 + by_1 = bx_2 + (a - \\lfloor \\frac{a}{b} \\rfloor \\times b)y_2 ax1​+by1​=bx2​+(a−⌊ba​⌋×b)y2​ 化简一下就有： ax1+by1=ay2+b(x2−⌊ab⌋×b×y2)ax_1 + by_1 = ay_2 + b(x_2 - \\lfloor \\frac{a}{b} \\rfloor \\times b \\times y_2) ax1​+by1​=ay2​+b(x2​−⌊ba​⌋×b×y2​) 必然存在一组解为 x1=y2,y1=x2−⌊ab⌋×b×y2x_1 = y_2,y_1 = x_2 - \\lfloor \\frac{a}{b} \\rfloor \\times b \\times y_2x1​=y2​,y1​=x2​−⌊ba​⌋×b×y2​ 不断递归下去，当 b=0b = 0b=0 时使用 x=1,y=0x=1,y=0x=1,y=0 作为一组解然后回溯即可。 费马小定理 对于素数 ppp，若 gcd⁡(a,p)=1\\gcd(a,p) = 1gcd(a,p)=1，则有： ap−1≡1mod pa^{p-1} \\equiv 1 \\mod p ap−1≡1modp 欧拉定理 若 gcd⁡(a,p)=1\\gcd(a,p) = 1gcd(a,p)=1，则有： aφ(p)≡1mod pa^{\\varphi(p)} \\equiv 1 \\mod p aφ(p)≡1modp 扩展欧拉定理 ab={abmod φ(p)gcd⁡(b,p)=1abgcd⁡(b,p)≠1,b&lt;φ(p)a[b%φ(p)+φ(p)]%φ(p)gcd⁡(b,p)≠1,b≥φ(p)a^b = \\begin{cases} a^{b \\mod \\varphi(p)} &amp; \\gcd(b,p) = 1\\\\ a^b &amp; \\gcd(b,p) \\not= 1,b &lt; \\varphi(p) \\\\ a^{[b \\% \\varphi(p) + \\varphi(p)]\\% \\varphi(p)} &amp; \\gcd(b,p) \\not= 1,b \\ge \\varphi(p) \\end{cases} ab=⎩⎪⎪⎨⎪⎪⎧​abmodφ(p)aba[b%φ(p)+φ(p)]%φ(p)​gcd(b,p)=1gcd(b,p)=1,b&lt;φ(p)gcd(b,p)=1,b≥φ(p)​ 中国剩余定理 问题描述： 求一组解： {x≡a1mod m1x≡a2mod m2⋯x≡anmod mn\\begin{cases} x \\equiv a_1 \\mod m_1 \\\\ x \\equiv a_2 \\mod m_2 \\\\ \\cdots \\\\ x \\equiv a_n \\mod m_n \\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​x≡a1​modm1​x≡a2​modm2​⋯x≡an​modmn​​ 其实满足 m1,m2,⋯ ,mnm_1,m_2,\\cdots,m_nm1​,m2​,⋯,mn​ 两两互质 问题分析： 令 M=∏i=1naiM = \\prod_{i=1}^n a_iM=∏i=1n​ai​。 对于第 iii 个方程，令 pi=Mmip_i = \\frac{M}{m_i}pi​=mi​M​，计算 pip_ipi​ 在模 mim_imi​ 意义下的逆元 pi−1p_i^{-1}pi−1​，令 ci=pipi−1c_i = p_ip_i^{-1}ci​=pi​pi−1​（不对 mim_imi​ 取模）。 则答案为 x=∑i=1nciaimod Mx = \\sum_{i=1}^n c_ia_i \\mod Mx=∑i=1n​ci​ai​modM 扩展中国剩余定理 考虑合并两个方程： x≡a1mod m1x≡a2mod m2x \\equiv a_1 \\mod m_1 \\\\ x \\equiv a_2 \\mod m_2 x≡a1​modm1​x≡a2​modm2​ 可以将它们转化为不定方程即： x=m1p+a1=m2q+a2x = m_1p + a_1 = m_2q + a_2 x=m1​p+a1​=m2​q+a2​ 转化一下即 m1p−m2q=a2−a1m_1p - m_2q = a_2 - a_1m1​p−m2​q=a2​−a1​，根据裴蜀定理当 a2−a1a_2 - a_1a2​−a1​ 不能被 m1−m2m_1 - m_2m1​−m2​ 整除时无解，否则可以通过扩展欧几里得算法得到一组解 p,qp,qp,q。 这样的话就可以将原方程组合并为：x≡bmod Mx \\equiv b \\mod Mx≡bmodM，其中 b=m1p+a1，M=lcm(m1,m2)b = m_1p + a_1，M = \\text{lcm}(m_1,m_2)b=m1​p+a1​，M=lcm(m1​,m2​) Wilson 定理 ppp 为素数的充要条件为 (p−1)!≡−1mod p(p-1)! \\equiv -1 \\mod p(p−1)!≡−1modp Kummer 定理 形式一：ppp 在 (nm)\\binom{n}{m}(mn​) 中的幂次，等于 ppp 进制下 n−mn - mn−m 需要的借位次数 形式二：ppp 在 (n+mm)\\binom{n+m}{m}(mn+m​) 中的幂次，等于 ppp 进制下 n+mn+mn+m 的进位次数 Lucas 定理 若有两个正整数 n,mn,mn,m 和一个素数 ppp，则有： (nm)=(nmod pmmod p)×(⌊np⌋⌊mp⌋)\\binom{n}{m} = \\binom{n \\mod p}{m \\mod p} \\times \\binom{\\lfloor \\frac{n}{p} \\rfloor}{\\lfloor \\frac{m}{p} \\rfloor} (mn​)=(mmodpnmodp​)×(⌊pm​⌋⌊pn​⌋​) 感性的理解就是拆到 ppp 进制下，然后每一位单独考虑。 阶 定义： 对于 a∈Z，m∈N∗a \\in \\mathbb{Z}，m \\in \\mathbb{N}^*a∈Z，m∈N∗，若 (a,m)=1(a,m) = 1(a,m)=1，则满足 an≡1(modm)a^n \\equiv 1 \\pmod man≡1(modm) 的最小正整数 nnn 称为 aaa 模 mmm 的阶，记为 δm(a)\\delta_m(a)δm​(a) 或 ordm(a)\\text{ord}_m(a)ordm​(a)。 性质一： a1,a2,⋯ ,aδm(a)a^1,a^2,\\cdots,a^{\\delta_m(a)}a1,a2,⋯,aδm​(a) 模 mmm 两两不同余。 证明：考虑使用反证法，若存在 i≠ji \\not= ji=j 满足 ai≡aj(modm)a^i \\equiv a^j \\pmod mai≡aj(modm)，则必然有 a∣i−j∣≡1(modm)a^{|i-j|} \\equiv 1 \\pmod ma∣i−j∣≡1(modm)，而 0&lt;∣i−j∣&lt;δm(a)0 &lt; |i-j| &lt; \\delta_m(a)0&lt;∣i−j∣&lt;δm​(a) 与定义冲突。 性质二： 若 an≡1(modm)a^n \\equiv 1 \\pmod man≡1(modm)，则必然有 δm(a)∣n\\delta_m(a) | nδm​(a)∣n。以及据此可以推出若 ap≡aqa^p \\equiv a^qap≡aq，则 p≡q(modδm(a))p \\equiv q \\pmod{\\delta_m(a)}p≡q(modδm​(a)) 性质三： δm(ab)=δm(a)δm(b)\\delta_m(ab) = \\delta_m(a) \\delta_m(b)δm​(ab)=δm​(a)δm​(b) 的充要条件为 (δm(a),δm(b))=1(\\delta_m(a),\\delta_m(b)) = 1(δm​(a),δm​(b))=1。 性质四： δm(ak)=δm(a)(δm(a),k)\\delta_m(a^k) = \\dfrac{\\delta_m(a)}{(\\delta_m(a),k)}δm​(ak)=(δm​(a),k)δm​(a)​ 所以根据上面这些性质，阶就给了人一种“循环节”的感觉。 原根 若 δm(g)=φ(m)\\delta_m(g) = \\varphi(m)δm​(g)=φ(m)，则称 ggg 为模 mmm 意义下的原根。 性质一： ggg 是模 mmm 意义下的原根的充要条件为，对于 φ(m)\\varphi(m)φ(m) 的每个质因数 ppp，都有 gφ(m)p≢1(modm)g^{\\frac{\\varphi(m)}{p}} \\not\\equiv 1 \\pmod mgpφ(m)​≡1(modm) 性质二： 若模 mmm 意义下有原根，则原根个数为 φ(φ(m))\\varphi(\\varphi(m))φ(φ(m)) 性质三： 数 mmm 存在原根当且仅当 m=2,4,pα,2pαm = 2,4,p^{\\alpha},2p^{\\alpha}m=2,4,pα,2pα，其中 ppp 为奇质数，α∈N∗\\alpha \\in \\mathbb{N}^*α∈N∗ 性质四： 最小原根的值为 O(n0.25)O(n^{0.25})O(n0.25)，可以暴力。 BSGS 满足 (a,p)=1(a,p) = 1(a,p)=1，求解下列方程的解： ax≡b(modp)a^x \\equiv b \\pmod p ax≡b(modp) 考虑按 ttt 分块，也就是将上述式子改写为： ait+j≡b(modp)a^{it + j} \\equiv b \\pmod p ait+j≡b(modp) 移一下项也就是： aj≡b×a−it(modp)a^j \\equiv b \\times a^{-it} \\pmod p aj≡b×a−it(modp) 所以就可以直接预处理 a0,a1,⋯ ,at−1a^0,a^1,\\cdots,a^{t-1}a0,a1,⋯,at−1，然后枚举 iii，通过 hash 判断预处理的数里面是否存在 b×a−itb \\times a^{-it}b×a−it 即可。 显然当 t=pt = \\sqrt{p}t=p​ 时复杂度最优，为 O(p)O(\\sqrt{p})O(p​)。 exBSGS 不满足 (a,p)=1(a,p) = 1(a,p)=1，求解下列方程的解： ax≡b(modp)a^x \\equiv b \\pmod p ax≡b(modp) 想法就是将这个方程转化为 (a,p)=1(a,p) = 1(a,p)=1。 首先这个方程显然可以转化为： ax+kp=ba^x + kp = b ax+kp=b 设 (a,p)=d(a,p) = d(a,p)=d，根据裴蜀定理这个式子有解当且仅当 d∣bd \\mid bd∣b，所以不合法直接判无解。 这样的话这个式子就可以转化为： ax−1⋅ad+k⋅pd=bda^{x-1}\\cdot \\frac{a}{d} + k\\cdot \\frac{p}{d} = \\frac{b}{d} ax−1⋅da​+k⋅dp​=db​ 此时可以令 ax−1→ax,pd→p,bd→ba^{x-1} \\to a^x,\\frac{p}{d} \\to p,\\frac{b}{d} \\to bax−1→ax,dp​→p,db​→b，这样一直递归下去，直到 (a,p)=1(a,p) = 1(a,p)=1。 设总共递归了 cntcntcnt 次，递归过程中 ddd 的乘积为 d′d'd′，则显然原式为： ax−cnt⋅acntd′≡bd′(modpd′)a^{x-cnt}\\cdot \\frac{a^{cnt}}{d'} \\equiv \\frac{b}{d'} \\pmod{\\frac{p}{d'}} ax−cnt⋅d′acnt​≡d′b​(modd′p​) 此时直接令 a′=a,b′=bd′,p′=pd′a' = a,b' = \\frac{b}{d'},p'= \\frac{p}{d'}a′=a,b′=d′b​,p′=d′p​，跑一遍 BSGS 然后将答案加 cntcntcnt 即可。 要注意此时左边式子会多一个 acntd′\\frac{a_{cnt}}{d'}d′acnt​​ 的系数，要记得乘上。 二次剩余 定义： 若 ppp 为奇质数，且 (n,p)=1(n,p) = 1(n,p)=1，使得存在一个 xxx 满足： x2≡n(modp)x^2 \\equiv n \\pmod p x2≡n(modp) 则称 nnn 为模 ppp 意义下的二次剩余，简称二次剩余，默认 n≥1n \\ge 1n≥1。（顾名思义就是二次方后剩余的数） 二次剩余的数量： 考虑对于一个二次剩余 nnn，考虑 x2≡n(modp)x^2 \\equiv n \\pmod px2≡n(modp) 有多少个解。 若存在多个解，设其中两个解为 x0,x1x_0,x_1x0​,x1​ 且满足 x0≠x1x_0 \\not= x_1x0​=x1​，则有： x02≡x12(modp)x_0^2 \\equiv x_1^2 \\pmod p x02​≡x12​(modp) 化简一下就是： (x0−x1)(x0+x1)≡0(modp)(x_0-x_1)(x_0+x_1) \\equiv 0 \\pmod p (x0​−x1​)(x0​+x1​)≡0(modp) 因为 x0≠x1x_0 \\not= x_1x0​=x1​，所以 x0−x1≠0x_0 - x_1 \\not= 0x0​−x1​=0，即要让上述式子为 000 则必然存在 x0+x1=0(modp)x_0 + x_1 = 0\\pmod px0​+x1​=0(modp) 也就是模 ppp 意义下的一对相反数对应一个二次剩余，因为 ppp 为奇质数所以任意一对 x0,x1x_0,x_1x0​,x1​ 若满足 x0+x1=0x_0 + x_1 = 0x0​+x1​=0，则必然满足 x0≠x1x_0 \\not= x_1x0​=x1​，也就是说任意一对相反数都可以对应一个二次剩余。 还可以知道的是任意两对相反数所对应的两个二次剩余均不同，所以二次剩余的数量就是 p−12\\frac{p-1}{2}2p−1​，故非二次剩余的数量就是 p−12\\frac{p-1}{2}2p−1​ 欧拉准则： 考虑怎么快速判断一个数 nnn 是不是二次剩余。 考虑费马小定理，np−1≡1(modp)n^{p-1} \\equiv 1 \\pmod pnp−1≡1(modp)，因为 ppp 为奇质数，所以有 n2⋅p−12≡1(modp)n^{2\\cdot \\frac{p-1}{2} } \\equiv 1 \\pmod pn2⋅2p−1​≡1(modp)，也就是说 np−12n^{\\frac{p-1}{2}}n2p−1​ 是 111 的开根，因为 111 的开根只有 111 或 −1-1−1，所以 np−12n^{\\frac{p-1}{2}}n2p−1​ 只可以为 111 或者 −1-1−1。 下面考虑证明 np−12≡1(modp)n^{\\frac{p-1}{2}} \\equiv 1 \\pmod pn2p−1​≡1(modp) 与 nnn 为二次剩余等价，也就是证明充分性和必要性。 充分性，也就是已知 np−12≡1(modp)n^{\\frac{p-1}{2}} \\equiv 1 \\pmod pn2p−1​≡1(modp)，设 ggg 表示模 ppp 意义下的原根，则可以令 n=gkn = g^kn=gk，则有 gk⋅p−12≡1(modp)g^{k\\cdot \\frac{p-1}{2}} \\equiv 1 \\pmod pgk⋅2p−1​≡1(modp)，有原根的性质可得 (p−1)∣k⋅p−12(p-1) \\mid k\\cdot \\frac{p-1}{2}(p−1)∣k⋅2p−1​，也就是说 kkk 一定是偶数，即我们可以将 kkk 除以 222，所以 nnn 就是可以开根的，开根后的结果就是 x=gk2x = g^{\\frac{k}{2}}x=g2k​ 必要性，也就是已知 nnn 是二次剩余，np−12=(x2)p−12=xp−1n^{\\frac{p-1}{2}} = (x^2)^{\\frac{p-1}{2}} = x^{p-1}n2p−1​=(x2)2p−1​=xp−1，因为 xφ(p)≡1(modp)x^{\\varphi(p)} \\equiv 1 \\pmod pxφ(p)≡1(modp)，所以 xp−1≡1(modp)x^{p-1} \\equiv 1 \\pmod pxp−1≡1(modp)，即 np−12≡1(modp)n^{\\frac{p-1}{2}} \\equiv 1 \\pmod pn2p−1​≡1(modp) 所以就证明了 np−12≡1(modp)n^{\\frac{p-1}{2}} \\equiv 1 \\pmod pn2p−1​≡1(modp) 与 nnn 为二次剩余等价，所以当 np−12≡−1(modp)n^{\\frac{p-1}{2}} \\equiv -1 \\pmod pn2p−1​≡−1(modp) 时 nnn 就是非二次剩余。 Cipolla： 考虑求解 x2≡n(modp)x^2 \\equiv n \\pmod px2≡n(modp) 首先找到一个 aaa 使得 a2−na^2 - na2−n 是非二次剩余，因为非二次剩余的数的个数接近 p2\\frac{p}{2}2p​ 所以期望两次找到。 定义 i2=a2−ni^2 = a^2 - ni2=a2−n，下面就是关于怎么找到这个 iii。 可以类似复数域，定义这样的一个 iii，使得每一个数都可以被表示为 A+BiA + BiA+Bi，其中 A,BA,BA,B 都是模 ppp 意义下的。 下面考虑证明下面这个结论： (a+i)p+1≡n(modp)(a+i)^{p+1} \\equiv n \\pmod p (a+i)p+1≡n(modp) 引理 111： ip≡−i(modp)i^p \\equiv -i \\pmod pip≡−i(modp) 证明：ip=i(i2)p−12=i(a2−n)p−12=−ii^p = i(i^2)^{\\frac{p-1}{2}} = i(a^2 - n)^{\\frac{p-1}{2}} = -iip=i(i2)2p−1​=i(a2−n)2p−1​=−i 引理 222： (A+B)p≡Ap+Bp(modp)(A+B)^p \\equiv A^p + B^p \\pmod p(A+B)p≡Ap+Bp(modp) 证明：(A+B)p≡∑i=0p(pi)AiBp−i≡(pp)Ap+(p0)Bp≡Ap+Bp(modp)(A+B)^p \\equiv \\sum_{i=0}^p \\binom{p}{i} A^iB^{p-i} \\equiv \\binom{p}{p} A^p + \\binom{p}{0}B^p \\equiv A^p + B^p \\pmod p(A+B)p≡∑i=0p​(ip​)AiBp−i≡(pp​)Ap+(0p​)Bp≡Ap+Bp(modp) 有了这两个引理就可以证明了： (a+i)p+1≡(ap+ip)(a+i)≡(a−i)(a+i)≡a2−i2≡n(modp)(a+i)^{p+1} \\equiv (a^p + i^p)(a+i) \\equiv (a-i)(a+i) \\equiv a^2 - i^2 \\equiv n \\pmod p (a+i)p+1≡(ap+ip)(a+i)≡(a−i)(a+i)≡a2−i2≡n(modp) 第二个等于号 ap≡a(modp)a^p \\equiv a \\pmod pap≡a(modp) 就是扩展欧拉定理。 因为 ppp 为奇质数，所以 p+1p+1p+1 为偶数，因此 nnn 开方后的数就是 (a+i)p+12(a+i)^{\\frac{p+1}{2}}(a+i)2p+1​，即 xxx 就是 (a+i)p+12(a+i)^{\\frac{p+1}{2}}(a+i)2p+1​ 可以证明 (a+i)p+12(a+i)^{\\frac{p+1}{2}}(a+i)2p+1​ 的 “虚部” 一定为 000。 使用反证法来证明这个结论，若存在 (A+Bi)2≡n(modp)(A+Bi)^2 \\equiv n \\pmod p(A+Bi)2≡n(modp) 且 B≠0B \\not= 0B=0，那么展开之后就是 A2+B2i2+2ABi≡n(modp)A^2 + B^2i^2 + 2ABi \\equiv n \\pmod pA2+B2i2+2ABi≡n(modp)，因为右边&quot;虚部&quot;为 000 所以显然左边&quot;虚部&quot;为 000，即 AB=0AB = 0AB=0，因为 B≠0B \\not= 0B=0，所以 A=0A = 0A=0，上面式子就可以化为 B2i2≡n(modp)B^2i^2 \\equiv n \\pmod pB2i2≡n(modp)，即 i2≡nB−2(modp)i^2 \\equiv nB^{-2} \\pmod pi2≡nB−2(modp)，显然 B−2B^{-2}B−2 是一个二次剩余，而 nnn 也是一个二次剩余，所以 nB−2nB^{-2}nB−2 就是一个二次剩余，即 i2i^2i2 是一个二次剩余，这与我们的假设 i2i^2i2 不是一个二次剩余违背，故此这个结论不成立。 正整数中的数论 算术基本定理 内容： 对于任意一个大于 111 的自然数 NNN，其一定可以被唯一分解为有限个质数的乘积。 标准分解式： N=∏i=1mpikiN = \\prod_{i=1}^m p_i^{k_i}N=∏i=1m​piki​​，满足 p1&lt;p2&lt;p3⋯&lt;pmp_1 &lt; p_2 &lt; p_3 \\cdots &lt; p_mp1​&lt;p2​&lt;p3​⋯&lt;pm​ 且 p1,p2,p3,⋯ ,pmp_1,p_2,p_3,\\cdots,p_mp1​,p2​,p3​,⋯,pm​ 均为质数，kik_iki​ 均为正整数，将这样的分解称为 NNN 的标准分解式。 p 进赋值序列： 记 vp(n)=max⁡{k∈n∣pk∣n}v_p(n) = \\max\\{k \\in \\mathbb{n}\\mid p^k \\mid n\\}vp​(n)=max{k∈n∣pk∣n}，则 nnn 的 ppp 进赋值序列为 {v2(n),v3(n),v5(n),v7(n),⋯ }\\{v_2(n),v_3(n),v_5(n),v_7(n),\\cdots\\}{v2​(n),v3​(n),v5​(n),v7​(n),⋯}，即要求 ppp 均为质数。 ppp 进赋值序列可以帮助我们在数论的角度下刻画正整数，在 ppp 进赋值序列下任何一个正整数都唯一对应一个高维平面上的点，该平面每一维对应一个素数。 gcd⁡\\gcdgcd 与 lcm\\text{lcm}lcm 就可以转化为高维平面上的 min⁡\\minmin 与 max⁡\\maxmax。 狄利克雷前缀和就对应高维前缀和，狄利克雷卷积就对应着高维和卷积。 莫比乌斯函数相当于高维差分的容斥系数。 素性检测和因数分解 素性检测就是在不对给定数进行质因数分解的情况下判断这个数是否为质数。 Miller–Rabin 素性测试 引理一：费马小定理 若 ppp 为素数，aaa 为整数，若 (a,p)=1(a,p) = 1(a,p)=1，则有 ap−1≡1(modp)a^{p-1} \\equiv 1 \\pmod pap−1≡1(modp) 费马小定理只是 ppp 为素数的充分条件，如不成立则 ppp 一定为合数，若成立则 ppp 不一定为素数。 引理二：二次检测定理 若 ppp 为素数，且 0&lt;x&lt;p0 &lt; x &lt; p0&lt;x&lt;p，则 x2≡1(modp)x^2 \\equiv 1 \\pmod px2≡1(modp) 的解为 x=1x=1x=1 或 x=p−1x=p-1x=p−1 证明： x2≡1(modp)⟹x2−1≡0(modp)⟹(x+1)(x−1)≡0(modp)⟹p∣(x+1)(x−1)x^2 \\equiv 1 \\pmod p \\Longrightarrow x^2 - 1 \\equiv 0 \\pmod p \\Longrightarrow (x+1)(x-1) \\equiv 0 \\pmod p \\Longrightarrow p \\mid (x+1)(x-1)x2≡1(modp)⟹x2−1≡0(modp)⟹(x+1)(x−1)≡0(modp)⟹p∣(x+1)(x−1)。 因为 ppp 为质数，所以只有 x=1x = 1x=1 或 x=p−1x = p-1x=p−1。 下面考虑给定 ppp 判断其是否为素数。 我们将 p−1p-1p−1 写成 2k×t2^k \\times t2k×t 的形式，可以考虑随机一个数 aaa，然后计算 at(modp)a^t \\pmod pat(modp) 的值。 将这个数不断自乘，然后使用二次检测定理判断，也就是若当前的数为 AAA 满足 A×A=1A \\times A = 1A×A=1 且 A≠1A \\not= 1A=1 且 A≠p−1A \\not= p-1A=p−1，则 ppp 不是素数。 这样乘 kkk 次的结果就是 ap−1a^{p-1}ap−1，这个时候只需要判断 ap−1≡1(modp)a^{p-1} \\equiv 1 \\pmod pap−1≡1(modp) 是否满足即可，如果不满足则一定不是素数。 这样检测的正确率是不低的，可以验证的是如果我们取前 121212 个素数作为 aaa 进行检测则在 [1,264)[1,2^{64})[1,264) 内的数都不会出现问题。 时间复杂度就是 O(∣a∣log3n)O(|a|log^3n)O(∣a∣log3n) 代码实现如下： 点击查看代码 12345678910111213141516bool Miller(int P) { if(P == 1) return 0; int t = P - 1, k = 0; while(!(t &amp; 1)) k++, t &gt;&gt;= 1; for(int i = 0; i &lt; 12; i++) { if(P == Test[i]) return 1; LL a = pow(Test[i], t, P), nxt = a; for(int j = 1; j &lt;= k; j++) { nxt = (a * a) % P; if(nxt == 1 &amp;&amp; a != 1 &amp;&amp; a != P - 1) return 0; a = nxt; } if(a != 1) return 0; } return 1;} Pollard-Rho 算法 首先要明确这个算法的功能就是在 O(n14)O(n^{\\frac{1}{4}})O(n41​) 的时间内找到数 nnn 的一个因子。 一个暴力的想法就是我们每次随机一个数，判断这个数是不是因子，如果是就返回如果不是就继续随机，但是这样的复杂度就炸了。 考虑构造如下的随机数序列： 定义 f(x)=(x2+c)(modN)f(x) = (x^2 + c) \\pmod Nf(x)=(x2+c)(modN)，那么我们构造的随机数序列就是 x,f(x),f(f(x)),⋯x,f(x),f(f(x)),\\cdotsx,f(x),f(f(x)),⋯。 这个序列的样子大概就是下面这个样子： 也就是一个 ρ\\rhoρ 的形状，而根据生日悖论期望随机 O(n14)O(n^{\\frac{1}{4}})O(n41​) 个数可以找到相同的数，所以这里期望环长为 O(n14)O(n^{\\frac{1}{4}})O(n41​)。 那么如果快速判环，可以使用类似龟兔赛跑的算法，也就是设置两个变量 t,rt,rt,r，每次判断是否有 gcd(∣t−r∣,n)≠1gcd(|t-r|,n) \\not= 1gcd(∣t−r∣,n)=1 且 gcd(∣t−r∣,n)≠ngcd(|t-r|,n) \\not= ngcd(∣t−r∣,n)=n，若有则 ∣t−r∣|t-r|∣t−r∣ 就是 nnn 的一个因数，如果没有我们就令 t=f(t),r=f(f(r))t = f(t),r=f(f(r))t=f(t),r=f(f(r))，可以发现这样的话 rrr 比 ttt 跑的快也就是它们在环上一定可以相遇。 这个时候就能体现出我们这个随机序列的优势了： 若 ∣i−j∣≡0(modp)|i-j| \\equiv 0 \\pmod p∣i−j∣≡0(modp)，则有 ∣fi−fj∣=(i2−j2)=(i−j)(i+j)≡0(modp)|f_i - f_j| = (i^2 - j^2) = (i-j)(i+j) \\equiv 0 \\pmod p∣fi​−fj​∣=(i2−j2)=(i−j)(i+j)≡0(modp)，所以我们只需要对两个点之间的距离 ddd 进行判断就好，不在于哪两个点而在于他们的距离，而我们上面的龟兔赛跑也显然是枚举到了每一种距离。 直接这样做就是 O(n14log⁡n)O(n^{\\frac{1}{4}}\\log n)O(n41​logn)。 优化就是减小求 gcdgcdgcd 的次数，可以考虑设一个固定的距离 CCC 然后每隔 CCC 个求一个公因数然后判断，这样的话期望的时间复杂度就是 O(n14)O(n^\\frac{1}{4})O(n41​)。 代码实现： 点击查看代码 1234567891011121314151617181920212223242526ll Pollard_Rho(ll N){ if (N == 4) return 2; if (is_prime(N)) return N; while (1) { ll c = randint(1, N - 1); auto f = [=](ll x) { return ((lll)x * x + c) % N; }; ll t = 0, r = 0, p = 1, q; do { for (int i = 0; i &lt; 128; ++i) // 令固定距离C=128 { t = f(t), r = f(f(r)); if (t == r || (q = (lll)p * abs(t - r) % N) == 0) // 如果发现环，或者积即将为0，退出 break; p = q; } ll d = gcd(p, N); if (d &gt; 1) return d; } while (t != r); }} 数论函数和筛法 此处可以查看如下几篇 blog，推荐按顺序观看： 【学习笔记】数论入门基础 【学习笔记】欧拉函数 【学习笔记】莫比乌斯反演 【学习笔记】数论之筛法 本文只在此基础上补充几个知识点。 区间筛 给定区间 [l,r][l,r][l,r] 要求区间 [l,r][l,r][l,r] 中的素数的数量。 考虑若 x≤rx \\le rx≤r 且 xxx 不为素数，则 xxx 必然拥有一个小于等于 r\\sqrt{r}r​ 的质因子，所以只需要用 [2,r][2,\\sqrt{r}][2,r​] 筛一遍区间 [l,r][l,r][l,r] 留下来的就是素数。 一些小 tip amod b=a−a×⌊ab⌋a \\mod b = a - a\\times \\lfloor \\frac{a}{b} \\rflooramodb=a−a×⌊ba​⌋ ⌊⌊ab⌋c⌋=⌊abc⌋\\lfloor {\\frac{\\lfloor\\frac{a}{b}\\rfloor}{c}} \\rfloor = \\lfloor {\\frac{a}{bc}} \\rfloor⌊c⌊ba​⌋​⌋=⌊bca​⌋ 整除分块中如果式子中多个数整除，复杂度是加而不是乘。 集合幂级数 FWT 与 FMT FWT 与 FMT 是解决如下问题的工具： ck=∑i⊕j=kaibjc_k = \\sum_{i\\oplus j = k}a_ib_j ck​=i⊕j=k∑​ai​bj​ 其中 ⊕\\oplus⊕ 为二进制下的 and or xor 三种运算之一。 下面将 FWT 与 FMT 统称为 FWT。 其解决这个问题的思路也类似 FFT，就是将序列 a,ba,ba,b 转化为某种变换 FWT(a),FWT(b)\\text{FWT}(a),\\text{FWT}(b)FWT(a),FWT(b) 然后乘起来得到 FWT(c)\\text{FWT}(c)FWT(c) 后反演得到 ccc。 OR 要求： ck=∑i∣j=kaibjc_k = \\sum_{i | j = k} a_ib_j ck​=i∣j=k∑​ai​bj​ 考虑若 i∣k=ki \\mid k = ki∣k=k 且 j∣k=kj \\mid k = kj∣k=k 则 (i∣j)∣k=k(i\\mid j) \\mid k = k(i∣j)∣k=k，就使用这个来设计变换。 即 FWTor(A)k=∑i∣k=kAi\\text{FWT}_{or}(A)_k = \\sum_{i\\mid k = k} A_iFWTor​(A)k​=∑i∣k=k​Ai​ 也就是 iii 为 kkk 的子集才可以转移。 那考虑为什么这样是对的： FWTor(A)=∑k(∑i∣k=kAi)×(∑j∣k=kBj)=∑k∑i∣k=k∑j∣k=kAiBj=∑k∑(i∣j)∣k=kAiBj\\begin{aligned} \\text{FWT}_{or}(A) &amp;= \\sum_{k} (\\sum_{i \\mid k = k}A_i) \\times (\\sum_{j \\mid k = k} B_j) \\\\ &amp;= \\sum_{k} \\sum_{i \\mid k = k}\\sum_{j \\mid k = k} A_iB_j \\\\ &amp;= \\sum_{k} \\sum_{(i \\mid j) \\mid k = k} A_iB_j \\end{aligned} FWTor​(A)​=k∑​(i∣k=k∑​Ai​)×(j∣k=k∑​Bj​)=k∑​i∣k=k∑​j∣k=k∑​Ai​Bj​=k∑​(i∣j)∣k=k∑​Ai​Bj​​ 所以这个变换就是正确的。 那么考虑如何快速进行这个变换，类似 FFT 每次合并两个长度为 2n2^n2n 的段，设不同的最高位为 111 的序列为 A1A_1A1​，为 000 的序列为 A0A_0A0​，则根据 ororor 的性质 A0A_0A0​ 可以转移到 A1A_1A1​，而 A1A_1A1​ 不能转移到 A0A_0A0​，也就是形如下面这样： FWTor(A)=(FWTor(A0),FWTor(A0)+FWTor(A1))\\text{FWT}_{or}(A) = (\\text{FWT}_{or}(A_0),\\text{FWT}_{or}(A_0) + \\text{FWT}_{or}(A_1)) FWTor​(A)=(FWTor​(A0​),FWTor​(A0​)+FWTor​(A1​)) 其中 A+BA + BA+B 是对应系数相加，(A,B)(A,B)(A,B) 就是按顺序写下 A,BA,BA,B。 逆变换就是逆着做这个操作就好了，即： IFWTor(A)=(IFWTor(A0),IFWTor(A1)−IFWTor(A0))\\text{IFWT}_{or}(A) = (\\text{IFWT}_{or}(A_0),\\text{IFWT}_{or}(A_1) - \\text{IFWT}_{or}(A_0)) IFWTor​(A)=(IFWTor​(A0​),IFWTor​(A1​)−IFWTor​(A0​)) 代码： 点击查看代码 123456789101112void Or(ll *x,int n,int op){ for(int l=1;l&lt;n;l&lt;&lt;=1){ for(int st=0;st&lt;n;st+=l*2){ for(int i=0;i&lt;l;i++){ ll u=x[st+i],v=x[st+l+i]; if(op==1) x[st+i]=u,x[st+l+i]=(v+u)%mod; else x[st+i]=u,x[st+l+i]=(v+mod-u)%mod; } } }} AND 要求： ck=∑i&amp;j=kaibjc_k = \\sum_{i \\&amp; j = k} a_ib_j ck​=i&amp;j=k∑​ai​bj​ 考虑若 i&amp;k=ki \\&amp; k = ki&amp;k=k 且 j&amp;k=kj \\&amp; k = kj&amp;k=k 则 (i&amp;j)&amp;k=k(i\\&amp;j) \\&amp; k = k(i&amp;j)&amp;k=k，所以可以构造如下的变换：FWTand(A)k=∑i&amp;k=kAi\\text{FWT}_{and}(A)_k = \\sum_{i\\&amp;k=k} A_iFWTand​(A)k​=∑i&amp;k=k​Ai​ 也就是 iii 为 kkk 的超集时产生贡献。 变化的与上文同理： FWTand(A)=(FWTand(A0)+FWTand(A1),FWTand(A1))IFWTand(A)=(IFWTand(A0)−IFWTand(A1),IFWTand(A1))\\text{FWT}_{and}(A) = (\\text{FWT}_{and}(A_0)+\\text{FWT}_{and}(A_1),\\text{FWT}_{and}(A_1)) \\\\ \\text{IFWT}_{and}(A) = (\\text{IFWT}_{and}(A_0)-\\text{IFWT}_{and}(A_1),\\text{IFWT}_{and}(A_1)) FWTand​(A)=(FWTand​(A0​)+FWTand​(A1​),FWTand​(A1​))IFWTand​(A)=(IFWTand​(A0​)−IFWTand​(A1​),IFWTand​(A1​)) 代码： 点击查看代码 123456789101112void And(ll *x,int n,int op){ for(int l=1;l&lt;n;l&lt;&lt;=1){ for(int st=0;st&lt;n;st+=l*2){ for(int i=0;i&lt;l;i++){ ll u=x[st+i],v=x[st+l+i]; if(op==1) x[st+i]=(u+v)%mod,x[st+l+i]=v; else x[st+i]=(u+mod-v)%mod,x[st+l+i]=v; } } }} XOR 要求： ck=∑i⊕j=kaibjc_k = \\sum_{i \\oplus j = k} a_ib_j ck​=i⊕j=k∑​ai​bj​ 设 d(x)d(x)d(x) 表示二进制下 xxx 的 111 的个数的奇偶性，则有如下性质：d(i&amp;k)⊕d(j&amp;k)=d((i⊕j)&amp;k)d(i\\&amp;k)\\oplus d(j\\&amp;k) = d((i\\oplus j) \\&amp; k)d(i&amp;k)⊕d(j&amp;k)=d((i⊕j)&amp;k)。 证明：因为我们是与操作，所以可以只考虑 kkk 为 111 的位。若某一位上 i,ji,ji,j 同时为 000 或 111 则显然不会有什么影响，若某一位上 i,ji,ji,j 分别为 0,10,10,1 那么左右两边都是同步变化的，所有也是一样的。 所以可以设计出以下的变换： FWTxor(A)k=∑i(−1)d(i&amp;k)Ai\\text{FWT}_{xor}(A)_k = \\sum_{i} (-1)^{d(i\\&amp;k)} A_i FWTxor​(A)k​=i∑​(−1)d(i&amp;k)Ai​ 可以乘一下看看是不是对的： FWTxor(C)=∑k(∑i(−1)d(i&amp;k)Ai)(∑j(−1)d(j&amp;k)Bj)=∑k∑i∑j(−1)d(i&amp;k)+d(j&amp;k)AiBj=∑k∑i,j(−1)d(i&amp;k)⊕d(j&amp;k)AiBj=∑k∑i,j(−1)d((i⊕j)&amp;k)AiBj\\begin{aligned} \\text{FWT}_{xor}(C) &amp;= \\sum_{k} (\\sum_{i} (-1)^{d(i\\&amp;k)} A_i) (\\sum_{j} (-1)^{d(j\\&amp;k)} B_j) \\\\ &amp;= \\sum_{k} \\sum_{i} \\sum_{j} (-1)^{d(i\\&amp;k) + d(j\\&amp;k)} A_iB_j \\\\ &amp;= \\sum_{k} \\sum_{i,j} (-1)^{d(i\\&amp;k)\\oplus d(j\\&amp;k)} A_iB_j \\\\ &amp;= \\sum_{k} \\sum_{i,j} (-1)^{d((i\\oplus j)\\&amp;k)} A_iB_j \\end{aligned} FWTxor​(C)​=k∑​(i∑​(−1)d(i&amp;k)Ai​)(j∑​(−1)d(j&amp;k)Bj​)=k∑​i∑​j∑​(−1)d(i&amp;k)+d(j&amp;k)Ai​Bj​=k∑​i,j∑​(−1)d(i&amp;k)⊕d(j&amp;k)Ai​Bj​=k∑​i,j∑​(−1)d((i⊕j)&amp;k)Ai​Bj​​ 这样就形式化对了，所以这个就是正确的。 考虑怎么快速求解，其实就是新加一位，而新加一位只有 111 贡献到 111 会导致奇偶性改变，也就是取负，其它的都没有变化。 即： FWTxor(A)=(FWTxor(A0)+FWTxor(A1),FWTxor(A0)−FWTxor(A1))\\text{FWT}_{xor}(A) = (\\text{FWT}_{xor}(A_0) + \\text{FWT}_{xor}(A_1),\\text{FWT}_{xor}(A_0) - \\text{FWT}_{xor}(A_1)) FWTxor​(A)=(FWTxor​(A0​)+FWTxor​(A1​),FWTxor​(A0​)−FWTxor​(A1​)) 逆变换其实就是考虑 A0,A1A_0,A_1A0​,A1​ 已经变成上面那个东西了，怎么还原回来的，就是： IFWTxor(A)=(IFWTxor(A0)+IFWTxor(A1)2,IFWTxor(A0)−IFWTxor(A1)2)\\text{IFWT}_{xor}(A) = (\\frac{\\text{IFWT}_{xor}(A_0) + \\text{IFWT}_{xor}(A_1)}{2},\\frac{\\text{IFWT}_{xor}(A_0) - \\text{IFWT}_{xor}(A_1)}{2}) IFWTxor​(A)=(2IFWTxor​(A0​)+IFWTxor​(A1​)​,2IFWTxor​(A0​)−IFWTxor​(A1​)​) 代码： 点击查看代码 1234567891011void Xor(ll *x,int n,int op){ for(int l=1;l&lt;n;l&lt;&lt;=1){ for(int st=0;st&lt;n;st+=l*2){ for(int i=0;i&lt;l;i++){ ll u=x[st+i],v=x[st+l+i]; if(op==1) x[st+i]=(u+v)%mod,x[st+l+i]=(u+mod-v)%mod; else x[st+i]=(u+v)%mod*inv2%mod,x[st+l+i]=(u+mod-v)%mod*inv2%mod; } } }} FWT 的一些性质 FWT 的本质是一个线性变换，也就是： FWT(A+B)=FWT(A)+FWT(B)\\text{FWT}(A+B) = \\text{FWT}(A) + \\text{FWT}(B)FWT(A+B)=FWT(A)+FWT(B)，FWT(cA)=cFWT(A)\\text{FWT}(cA) = c\\text{FWT}(A)FWT(cA)=cFWT(A) 集合幂级数 位运算是 OI 中的常考知识点，因为位运算中每一位的独立性，所以可以将其看作两个 {0,1}n\\{0,1\\}^n{0,1}n 上的向量的运算。 生成函数是刻画序列的有力工具，而集合幂级数就是处理集合（位运算）的一种特殊形式。对于序列 a0,a1,⋯ ,a2n−1a_0,a_1,\\cdots,a_{2^n-1}a0​,a1​,⋯,a2n−1​ 我们可以定义其集合幂级数 A(x)=∑i=02n−1aixiA(x) = \\sum \\limits_{i=0}^{2^n-1}a_ix^iA(x)=i=0∑2n−1​ai​xi。 定义集合幂级数的乘法操作，也就是子集卷积为如下的形式； ci=∑j∣k=ij&amp;k=0ajbk\\begin{aligned} c_i = \\sum_{j \\mid k = i \\quad j \\&amp; k = 0} a_jb_k \\end{aligned} ci​=j∣k=ij&amp;k=0∑​aj​bk​​ 组合意义就是选择两个不交的集合，可以直接枚举子集就可以做到 O(3n)O(3^n)O(3n)。 可以构造占位函数 w(x)=popcount(x)w(x) = \\text{popcount}(x)w(x)=popcount(x)，这样上述条件可以等价为 j xor k=ij \\ \\text{xor} \\ k = ij xor k=i 且 w(j)+w(k)=w(i)w(j) + w(k) = w(i)w(j)+w(k)=w(i)，这样就可以以 w(x)w(x)w(x) 来构造一个二元集合幂级数 A(x,y)=∑i=02n−1aixiyw(i)A(x,y) = \\sum \\limits_{i=0}^{2^n-1} a_ix^iy^{w(i)}A(x,y)=i=0∑2n−1​ai​xiyw(i)，而子集卷积就相当于对于第一维异或卷积，第二维和卷积，都是可以做的，所以就可以一维维来做，时间复杂度 O(n22n)O(n^22^n)O(n22n)。 因为不出意外的话我们第二维都为 O(log⁡n)O(\\log n)O(logn) 级别，所以直接暴力做和卷积就没问题，不用再写 FFT 了。 代码： 点击查看代码 1234567891011121314int main(){ m=read();n=(1&lt;&lt;m); for (int i=1;i&lt;n;i++)c[i]=c[i&gt;&gt;1]+(i&amp;1); for (int i=0;i&lt;n;i++)F[i].a[c[i]]=read(); for (int i=0;i&lt;n;i++)G[i].a[c[i]]=read(); FWT(F,n);FWT(G,n); for (int i=0;i&lt;n;i++) F[i]=F[i]*G[i]; IFWT(F,n); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,(F[i].a[c[i]]+mod)%mod); return 0;} 这个技巧就被称为占位多项式，有了这个占位多项式我们就可以对集合幂级数做各种多项式的操作，但是那东西我完全不会，就不说了。 组合计数 计数原理 加法原理： 若完成某道工序有两种方法，第一种方法的实现方式有 aaa 种，第二种方法的实现方式有 bbb 种，则完成这道工序的实现方法有 a+ba+ba+b 种。 乘法原理： 若完成某道工序有两个步骤，第一个步骤有 aaa 种实现方式，第二个步骤有 bbb 种实现方式，则完成这道工序的实现方法有 ababab 种。 其实只需要观察它们是不是相互独立的就可以判断出应使用加法原理还是乘法原理。 算两次原理（富比尼原理）： 将同一个量同两个不同角度计算两次，从而建立等量关系。 这东西看上去很玄乎，但是其实放在 OI 中就是：维度的变换（枚举下标/权值）、贡献的计算（直接计算/增量计算）等，从不同的角度解决问题，并在选取了合适的角度之后通过其它的方法解决问题。 例题 P8557 炼金术： 有 kkk 个熔炉，每个熔炉可以随机炼出 nnn 种金属中的一些，当 nnn 种金属都被炼制出来过该方案就是合法的，询问有多少种合法的方案。 考虑按每一种金属考虑，其在每一个熔炉中都可以出现或者不出现，所以方案数为 222，而其在 kkk 个熔炉中出现的情况相互独立，所以方案数为 2k2^k2k，但是这个金属必须要在某一个熔炉中出现，所以真实的方案数为 2k−12^k-12k−1。 对于不同的金属之间相互独立，所以总方案数为 (2k−1)n(2^k-1)^n(2k−1)n。 鸽巢原理： nnn 个小球放到 mmm 个抽屉中，至少有一个抽屉放了大于等于 ⌈nm⌉\\lceil \\frac{n}{m} \\rceil⌈mn​⌉ 个。 这个原理常用于结论的证明，以及一些极端情况的求解等。 组合数 组合数的计算 递推形式：(nm)=(n−1m)+(n−1m−1)\\binom{n}{m} = \\binom{n-1}{m} + \\binom{n-1}{m-1}(mn​)=(mn−1​)+(m−1n−1​)。 阶乘形式：(nm)=n!m!(n−m)!=nm‾m!\\binom{n}{m} = \\frac{n!}{m!(n-m)!} = \\frac{n^{\\underline{m}}}{m!}(mn​)=m!(n−m)!n!​=m!nm​​ Lucas 定理：(nm)=(nmod pmmod p)×(⌊np⌋⌊mp⌋)\\binom{n}{m} = \\binom{n \\mod p}{m \\mod p} \\times \\binom{\\lfloor \\frac{n}{p} \\rfloor}{\\lfloor \\frac{m}{p} \\rfloor}(mn​)=(mmodpnmodp​)×(⌊pm​⌋⌊pn​⌋​) 组合恒等式： 吸收恒等式： (nm)=nm(n−1m−1)\\binom{n}{m} = \\frac{n}{m} \\binom{n-1}{m-1}(mn​)=mn​(m−1n−1​)，移项得 m(nm)=n(n−1m−1)m\\binom{n}{m} = n\\binom{n-1}{m-1}m(mn​)=n(m−1n−1​) 证明：根据组合数的阶乘形式易得 行求和：∑i=0n(ni)=2n\\sum_{i=0}^n \\binom{n}{i} = 2^n∑i=0n​(in​)=2n 证明：根据二项式定理 (1+1)n=∑i=0n(ni)=2n(1+1)^n = \\sum_{i=0}^n \\binom{n}{i} = 2^n(1+1)n=∑i=0n​(in​)=2n 列求和：∑i=nm(in)=(m+1n+1)\\sum_{i=n}^m \\binom{i}{n} = \\binom{m+1}{n+1}∑i=nm​(ni​)=(n+1m+1​) 证明：(nn)+(n+1n)+(n+2n)+⋯+(mn)=(n+1n+1)+(n+1n)+(n+2n)+⋯+(mn)=(n+2n+1)+(n+2n)+⋯+(mn)=(mn+1)+(mn)=(m+1n+1)\\binom{n}{n} + \\binom{n+1}{n} + \\binom{n+2}{n} + \\cdots + \\binom{m}{n} = \\binom{n+1}{n+1} + \\binom{n+1}{n} + \\binom{n+2}{n} + \\cdots + \\binom{m}{n} = \\binom{n+2}{n+1} + \\binom{n+2}{n} + \\cdots + \\binom{m}{n} = \\binom{m}{n+1} + \\binom{m}{n} = \\binom{m+1}{n+1}(nn​)+(nn+1​)+(nn+2​)+⋯+(nm​)=(n+1n+1​)+(nn+1​)+(nn+2​)+⋯+(nm​)=(n+1n+2​)+(nn+2​)+⋯+(nm​)=(n+1m​)+(nm​)=(n+1m+1​)，主要是使用了组合数的递推形式。 范德蒙德卷积：∑i=0k(ni)×(mk−i)=(n+mk)\\sum_{i=0}^k \\binom{n}{i}\\times\\binom{m}{k-i} = \\binom{n+m}{k}∑i=0k​(in​)×(k−im​)=(kn+m​) 证明：考虑我们枚举的其实就是 nnn 个里面选 iii 个和 mmm 个里面选 k−ik-ik−i 个，显然可以合并起来。 组合数的应用： 隔板法：nnn 个相同的小球放到 mmm 个不同的盒子里，每个盒子里必须至少放一个小球，方案数为 (n−1m−1)\\binom{n-1}{m-1}(m−1n−1​)。 证明：考虑将 nnn 个小球放到一排，这样中间就出现了 n−1n-1n−1 个缝隙，放到 kkk 个不同的盒子中相当于划分为 kkk 段也就是选择 k−1k-1k−1 个缝隙放上隔板，方案数就是 (n−1m−1)\\binom{n-1}{m-1}(m−1n−1​)。 扩展： 如果将要求改为每个盒子可以不放小球，那么方案数就是 (n+m−1m−1)\\binom{n+m-1}{m-1}(m−1n+m−1​)，可以理解为先将所有的盒子提前放上一个小球，这样就必须至少放 111 个了。 捆绑法：有 nnn 个不同的人站队，要求其中两个人必须相邻，方案数为 (n−1)!×2!(n-1)! \\times 2!(n−1)!×2!。 证明：将这两个人视为一个人去站队方案数为 (n−1)!(n-1)!(n−1)!，而两个人内部也可以随便站方案数为 2!2!2!。 格路计数：给定一个 n×mn \\times mn×m 的网格，每次可以从 (x,y)(x,y)(x,y) 走到 (x+1,y)(x+1,y)(x+1,y) 或者 (x,y+1)(x,y+1)(x,y+1)，从 (1,1)(1,1)(1,1) 走到 (n,m)(n,m)(n,m) 的方案数为 (n+mn)\\binom{n+m}{n}(nn+m​)。 证明：我们总共要走 n+mn+mn+m 步才能走到 (n,m)(n,m)(n,m) 这其中有 nnn 步是执行 (x,y)→(x+1,y)(x,y) \\to (x+1,y)(x,y)→(x+1,y)，而且这 nnn 步可以在任意位置。 卡特兰数：见数论之生成函数基础。 prufer 序列 对于一棵有 nnn 个节点的带标号树，其 prufer 序列一定是一个长度为 n−2n-2n−2 值域为 [1,n][1,n][1,n] 的序列。 树转化为 prufer 序列： 选择树上编号最小的叶子节点，将其父亲插入到序列的末尾 删除这个选择的叶子节点 重复上述步骤直到树中只剩下两个节点 注意到我们的 prufer 序列与树构成一个双射，所以我们可以由 prufer 序列还原对应的树。 选择编号最小的一个叶子节点（即从未在序列中出现的点），其父亲就是序列第 iii 个数。（iii 初始为 111） 点 xxx 的度数为 xxx 的出现次数加 111，所以可以删除这个叶子节点，然后将其父亲的度数减 111，直到其父亲度数变为 111 就成为了叶子节点。 重复上述两步，直到序列全部被用完。 可以发现这样构造出的 prufer 序列有如下的性质： 剩下的两个节点中，一定有一个为 nnn 号节点 对于一个 nnn 度点，其会在 prufer 序列中出现 n−1n-1n−1 次 应用： 无向完全图生成树计数：若该完全图点数为 nnn，则任意一个长度为 n−2n-2n−2 的值域为 [1,n][1,n][1,n] 的序列都可以还原出一棵生成树，所以方案数即 nn−2n^{n-2}nn−2，与 Cayley 定理的结论一致。 Cayley 定理：假设图中有 mmm 个连通块，连通块内的点数为 a1,a2,⋯ ,ama_1,a_2,\\cdots,a_ma1​,a2​,⋯,am​，且满足 a1+a2+⋯+am=na_1 + a_2 + \\cdots + a_m = na1​+a2​+⋯+am​=n，则选择 m−1m-1m−1 条边将图联通的方案数为 nm−2∏i=1main^{m-2}\\prod_{i=1}^m a_inm−2∏i=1m​ai​ 广义 Cayley 定理：nnn 个有标号的点形成的包含 kkk 棵树的森林，要求给定的 kkk 个点没有两个点属于同一棵树的方案数为 k×nn−k−1k \\times n^{n-k-1}k×nn−k−1。 nnn 个点的有根树计数：因为每个点都可以作为根，所以答案为 n×nn−2=nn−1n \\times n^{n-2} = n^{n-1}n×nn−2=nn−1 容斥原理 最基本的式子就是交集与并集的转化： 设 SSS 为有限集，Ai⊆S（i∈[1,n]）A_i \\subseteq S（i \\in [1,n]）Ai​⊆S（i∈[1,n]），则有： ∣⋃i=1nAi∣=∑T⊆[1,n](−1)∣T∣−1∣⋂j∈TAj∣=∑k=1n(−1)k−1∑b1&lt;b2&lt;b3&lt;⋯&lt;bk∣⋂j=1kAbj∣\\left| \\bigcup\\limits_{i=1}^n A_i \\right| = \\sum_{T \\subseteq [1,n]} (-1)^{|T|-1} \\left| \\bigcap\\limits_{j \\in T} A_j \\right| = \\sum_{k=1}^{n} (-1)^{k-1} \\sum_{b_1 &lt; b_2 &lt; b_3 &lt; \\cdots &lt; b_k} \\left| \\bigcap\\limits_{j=1}^k A_{b_j} \\right| ∣∣∣∣∣∣​i=1⋃n​Ai​∣∣∣∣∣∣​=T⊆[1,n]∑​(−1)∣T∣−1∣∣∣∣∣∣∣​j∈T⋂​Aj​∣∣∣∣∣∣∣​=k=1∑n​(−1)k−1b1​&lt;b2​&lt;b3​&lt;⋯&lt;bk​∑​∣∣∣∣∣∣​j=1⋂k​Abj​​∣∣∣∣∣∣​ 证明：考虑元素 xxx 属于 mmm 个 AAA，则其产生的贡献就是这个式子 ∑i=1m(−1)i−1(mi)=−(∑i=1m(−1)i(mi))=−(−1+∑i=0m(−1)i(mi))=−(−1+(1−1)m)=1\\sum_{i=1}^m (-1)^{i-1} \\binom{m}{i} = -(\\sum_{i=1}^m (-1)^i \\binom{m}{i}) = -(-1 + \\sum_{i=0}^m (-1)^i \\binom{m}{i}) = -(-1 + (1-1)^m) = 1∑i=1m​(−1)i−1(im​)=−(∑i=1m​(−1)i(im​))=−(−1+∑i=0m​(−1)i(im​))=−(−1+(1−1)m)=1 直观理解这个式子就是将满足 A1A_1A1​ 或满足 A2A_2A2​ 或 ⋯\\cdots⋯ 的元素个数转化为了强制同时满足某些条件的元素个数。 当然有的时候也要有一些直观的理解，比如 [a,b][a,b][a,b] 中满足 AAA 的数的个数可以转化为 [1,b][1,b][1,b] 中满足的个数减去 [1,a−1][1,a-1][1,a−1] 中满足的个数；满足 AAA 的个数可以转化为无所谓的个数减去不满足 AAA 的个数等。 在容斥以及反演过程中常使用二项式定理证明结论。 反演 反演其实就是容斥原理的代数形式，下面就简单介绍几种反演。 通过这些反演推导的练习，相信你一定会学会如何推导容斥系数。 二项式反演 形式一： F(n)=∑i=0n(−1)i(ni)G(i) ⟺ G(n)=∑i=0n(−1)i(ni)F(i)F(n) = \\sum_{i=0}^n (-1)^i \\binom{n}{i} G(i) \\iff G(n) = \\sum_{i=0}^n (-1)^i \\binom{n}{i} F(i) F(n)=i=0∑n​(−1)i(in​)G(i)⟺G(n)=i=0∑n​(−1)i(in​)F(i) 证明： 这里只证明充分性，必要性显然成立。 也就是得到在计算 G(n)G(n)G(n) 的时候 G(i)G(i)G(i) 的系数是多少，要证明的就是后面这个式子 G(n)G(n)G(n) 的系数为 111，其余的系数为 000。 下面就是考虑计算 G(i)G(i)G(i) 的系数，一个想法就是枚举所有的 F(j)F(j)F(j) 然后将 F(j)F(j)F(j) 中 G(i)G(i)G(i) 的系数求和。 ans=∑j=in(−1)j(nj)(−1)i(ji)=(−1)i∑j=in(−1)jn!j!j!(n−j)!i!(j−i)!=(−1)i∑j=in(−1)jn!i!(n−i!)×(n−i)!(n−j)!(j−i)!=(−1)i(ni)∑j=in(−1)j(n−in−j)=(−1)i(ni)∑j=0n−i(−1)j+1(n−jn−j−i)=(−1)2i(ni)∑j=0n−i(−1)j(n−ij)=(−1)2i(ni)(1−1)n−i=[n=i]\\begin{aligned} ans &amp;= \\sum_{j=i}^n (-1)^j \\binom{n}{j} (-1)^i \\binom{j}{i} \\\\ &amp;= (-1)^i \\sum_{j=i}^n (-1)^j \\frac{n!j!}{j!(n-j)!i!(j-i)!} \\\\ &amp;= (-1)^i \\sum_{j=i}^n (-1)^j \\frac{n!}{i!(n-i!)} \\times \\frac{(n-i)!}{(n-j)!(j-i)!} \\\\ &amp;= (-1)^i \\binom{n}{i} \\sum_{j=i}^n (-1)^j \\binom{n-i}{n-j} \\\\ &amp;= (-1)^i \\binom{n}{i} \\sum_{j=0}^{n-i} (-1)^{j+1} \\binom{n-j}{n-j-i} \\\\ &amp;= (-1)^{2i} \\binom{n}{i} \\sum_{j=0}^{n-i} (-1)^j \\binom{n-i}{j} \\\\ &amp;= (-1)^{2i} \\binom{n}{i} (1-1)^{n-i} \\\\ &amp;= [n = i] \\end{aligned} ans​=j=i∑n​(−1)j(jn​)(−1)i(ij​)=(−1)ij=i∑n​(−1)jj!(n−j)!i!(j−i)!n!j!​=(−1)ij=i∑n​(−1)ji!(n−i!)n!​×(n−j)!(j−i)!(n−i)!​=(−1)i(in​)j=i∑n​(−1)j(n−jn−i​)=(−1)i(in​)j=0∑n−i​(−1)j+1(n−j−in−j​)=(−1)2i(in​)j=0∑n−i​(−1)j(jn−i​)=(−1)2i(in​)(1−1)n−i=[n=i]​ 所以系数就正确了，得证。 形式二： F(n)=∑i=0n(ni)G(i) ⟺ G(n)=∑i=0n(−1)n−i(ni)F(i)F(n) = \\sum_{i=0}^n \\binom{n}{i} G(i) \\iff G(n) = \\sum_{i=0}^n (-1)^{n-i} \\binom{n}{i}F(i) F(n)=i=0∑n​(in​)G(i)⟺G(n)=i=0∑n​(−1)n−i(in​)F(i) 证明： 考虑使用 EGF 证明； F(n)=∑i=0nn!(n−i)!i!G(i)F(n)n!=∑i=0n1(n−i)!G(i)i!F(n) = \\sum_{i=0}^n \\frac{n!}{(n-i)!i!}G(i) \\\\ \\frac{F(n)}{n!} = \\sum_{i=0}^n \\frac{1}{(n-i)!} \\frac{G(i)}{i!} F(n)=i=0∑n​(n−i)!i!n!​G(i)n!F(n)​=i=0∑n​(n−i)!1​i!G(i)​ 这个式子显然就是一个卷积的形式也就是： F=G∗ex ⟺ G=F∗e−xF = G * e^x \\iff G = F * e^{-x} F=G∗ex⟺G=F∗e−x 所以： G(n)n!=∑i=0n(−1)n−i(n−i)!F(i)i!\\frac{G(n)}{n!} = \\sum_{i=0}^n \\frac{(-1)^{n-i}}{(n-i)!} \\frac{F(i)}{i!} n!G(n)​=i=0∑n​(n−i)!(−1)n−i​i!F(i)​ 移项之后就是： G(n)=∑i=0n(−1)n−i(ni)F(i)G(n) = \\sum_{i=0}^n (-1)^{n-i} \\binom{n}{i} F(i) G(n)=i=0∑n​(−1)n−i(in​)F(i) 得证。 形式三： F(n)=∑i=n(in)G(i) ⟺ G(n)=∑i=n(−1)i−n(in)F(i)F(n) = \\sum_{i=n} \\binom{i}{n} G(i) \\iff G(n) = \\sum_{i=n} (-1)^{i-n} \\binom{i}{n} F(i) F(n)=i=n∑​(ni​)G(i)⟺G(n)=i=n∑​(−1)i−n(ni​)F(i) 形式四： F(n)=∑i=n(−1)i(in)G(i) ⟺ G(n)=∑i=n(−1)i(in)F(i)F(n) = \\sum_{i=n} (-1)^i \\binom{i}{n} G(i) \\iff G(n) = \\sum_{i=n} (-1)^i \\binom{i}{n} F(i) F(n)=i=n∑​(−1)i(ni​)G(i)⟺G(n)=i=n∑​(−1)i(ni​)F(i) 这两种形式都可以通过慢慢推的方式证明，因为形式一已经类似证明过了就不证明了。 莫比乌斯反演 请查看： 【学习笔记】数论入门基础 【学习笔记】莫比乌斯反演 Min-Max 容斥 定义全集 U={a1,a2,a3,⋯ ,an}U = \\{a_1,a_2,a_3,\\cdots,a_n\\}U={a1​,a2​,a3​,⋯,an​}，有一个集合 SSS，则 max⁡(S)=max⁡ai∈Sai\\max(S) = \\max \\limits_{a_i \\in S} a_imax(S)=ai​∈Smax​ai​，min⁡(S)=min⁡ai∈Sai\\min(S) = \\min \\limits_{a_i\\in S} a_imin(S)=ai​∈Smin​ai​。 则有如下结论： max⁡(S)=∑T⊆S(−1)∣T∣+1min⁡(T)min⁡(S)=∑T⊆S(−1)∣T∣+1max⁡(T)\\max(S) = \\sum_{T \\subseteq S} (-1)^{|T|+1} \\min(T) \\\\ \\min(S) = \\sum_{T \\subseteq S} (-1)^{|T|+1} \\max(T) max(S)=T⊆S∑​(−1)∣T∣+1min(T)min(S)=T⊆S∑​(−1)∣T∣+1max(T) 下面考虑证明第一个式子。 一样的套路，假设元素 xxx 为第 kkk 大，钦定 xxx 为集合中的最小值，那么它在后面的式子里对答案贡献的系数是什么，可以枚举大于 xxx 的数选择多少个。 =∑i=0k−1(k−1i)(−1)i+2=∑i=0k−1(k−1i)(−1)i=(1−1)k−1=[k=1]\\begin{aligned} &amp;= \\sum_{i=0}^{k-1} \\binom{k-1}{i} (-1)^{i+2} \\\\ &amp;= \\sum_{i=0}^{k-1} \\binom{k-1}{i} (-1)^i \\\\ &amp;= (1-1)^{k-1} \\\\ &amp;= [k=1] \\end{aligned} ​=i=0∑k−1​(ik−1​)(−1)i+2=i=0∑k−1​(ik−1​)(−1)i=(1−1)k−1=[k=1]​ 所以只有最大值会产生 111 的贡献，其他都会产生 000 的贡献，得证。 要注意的一点就是 Min-Max 容斥在期望意义下依然成立，即： E(max⁡(S))=∑T⊆S(−1)∣T∣+1min⁡(T)E(\\max(S)) = \\sum_{T \\subseteq S} (-1)^{|T|+1} \\min(T) E(max(S))=T⊆S∑​(−1)∣T∣+1min(T) 如果我们要求第 kkk 大也是可以容斥出来的： Kthmax⁡(S)=∑T⊆S(−1)∣T∣−k(∣T∣−1k−1)min⁡(T)K_{th}\\max(S) = \\sum_{T \\subseteq S} (-1)^{|T| - k} \\binom{|T|-1}{k-1} \\min(T) Kth​max(S)=T⊆S∑​(−1)∣T∣−k(k−1∣T∣−1​)min(T) 这个容斥系数我们是可以很简单推导出来的。 考虑设： Kthmax⁡(S)=∑T⊆SF(∣T∣)min⁡(T)K_{th}\\max(S) = \\sum_{T \\subseteq S} F(|T|) \\min(T) Kth​max(S)=T⊆S∑​F(∣T∣)min(T) 考虑若 xxx 为第 ppp 大，则由上文可知其贡献即： ∑i=0p−1(p−1i)F(i+1)\\sum_{i=0}^{p-1} \\binom{p-1}{i} F(i+1) i=0∑p−1​(ip−1​)F(i+1) 我们的目的就要让这个式子的值等于 [p=k][p=k][p=k]，也就是： ∑i=0p(pi)F(i+1)=[p=k−1]\\sum_{i=0}^{p} \\binom{p}{i} F(i+1) = [p=k-1] i=0∑p​(ip​)F(i+1)=[p=k−1] 这个就是一个二项式反演的形式，所以就有： F(p+1)=∑i=0p(−1)p−i(pi)[i=k−1]=(−1)p−k+1(pk−1)F(p+1) = \\sum_{i=0}^p (-1)^{p-i} \\binom{p}{i} [i=k-1] = (-1)^{p-k+1} \\binom{p}{k-1} F(p+1)=i=0∑p​(−1)p−i(ip​)[i=k−1]=(−1)p−k+1(k−1p​) 因此 F(∣T∣)=(−1)∣T∣−k(∣T∣−1k−1)F(|T|) = (-1)^{|T|-k}\\binom{|T|-1}{k-1}F(∣T∣)=(−1)∣T∣−k(k−1∣T∣−1​) 子集反演 莫比乌斯反演相当于在因子多重集上的子集反演，所以本质也是子集反演。 现有一个满足某些条件的元素集合 AAA。 设 f(S)f(S)f(S) 表示 A=SA=SA=S 时的答案，g(S)g(S)g(S) 表示 S⊆AS \\subseteq AS⊆A 时的答案，则有如下结论： g(S)=∑T⊆Sf(T) ⟺ f(S)=∑T⊆S(−1)∣S∣−∣T∣g(T)g(S) = \\sum_{T \\subseteq S} f(T) \\iff f(S) = \\sum_{T \\subseteq S} (-1)^{|S|-|T|}g(T) g(S)=T⊆S∑​f(T)⟺f(S)=T⊆S∑​(−1)∣S∣−∣T∣g(T) 设 f(s)f(s)f(s) 表示满足 A=SA=SA=S 时的答案，g(S)g(S)g(S) 表示 A⊆SA \\subseteq SA⊆S 时的答案，则有如下结论： g(S)=∑S⊆Tf(T) ⟺ f(S)=∑S⊆T(−1)∣T∣−∣S∣g(T)g(S) = \\sum_{S \\subseteq T} f(T) \\iff f(S) = \\sum_{S \\subseteq T} (-1)^{|T|-|S|}g(T) g(S)=S⊆T∑​f(T)⟺f(S)=S⊆T∑​(−1)∣T∣−∣S∣g(T) 斯特林反演 定义第一类斯特林数 [nm]\\begin{bmatrix}n \\\\ m\\end{bmatrix}[nm​] 表示 nnn 个不同元素形成 mmm 个圆排列的方案数。 注意 (1,2,3,4)(1,2,3,4)(1,2,3,4) 与 (2,3,4,1)(2,3,4,1)(2,3,4,1) 为同一个圆排列，但 (1,2,3,4)(1,2,3,4)(1,2,3,4) 与 (4,3,2,1)(4,3,2,1)(4,3,2,1) 不是同一个圆排列。 其满足如下递推式： [nm]=[n−1m−1]+(n−1)[n−1m]\\begin{bmatrix}n\\\\m\\end{bmatrix} = \\begin{bmatrix} n-1 \\\\ m-1 \\end{bmatrix} + (n-1) \\begin{bmatrix} n-1 \\\\ m \\end{bmatrix} [nm​]=[n−1m−1​]+(n−1)[n−1m​] 这个递推式就是考虑元素 nnn 是自己单独变成一个圆排列还是放到前 n−1n-1n−1 个数的前面。 对于任意一个排列我们如果将其变成置换的形式，就相当于划分成了若干圆排列，也就是说： ∑i=0n[ni]=n!\\sum_{i=0}^n \\begin{bmatrix} n \\\\ i \\end{bmatrix} = n! i=0∑n​[ni​]=n! 定义第二类斯特林数 {nm}\\begin{Bmatrix} n \\\\ m\\end{Bmatrix}{nm​} 表示将 nnn 个不同的元素划分到 mmm 个相同的集合中，要求集合非空的方案数。 则有如下的递推式： {nm}={n−1m−1}+m{n−1m}\\begin{Bmatrix} n \\\\ m \\end{Bmatrix} = \\begin{Bmatrix} n-1 \\\\ m-1 \\end{Bmatrix} + m\\begin{Bmatrix} n-1 \\\\ m \\end{Bmatrix} {nm​}={n−1m−1​}+m{n−1m​} 就是考虑元素 nnn 是自己新建一个集合，还是放在前面已有的集合中。 可以显然发现这个结论： [nm]≥{nm}\\begin{bmatrix} n \\\\ m\\end{bmatrix} \\ge \\begin{Bmatrix} n \\\\ m \\end{Bmatrix} [nm​]≥{nm​} 因为一个圆排列只对应一个集合，而一个集合可以对应多个圆排列。 斯特林数最关键的应用就是：普通幂、上升幂、下降幂之间的转换。 定义下降幂：xn‾=x×(x−1)×(x−2)×⋯×(x−n+1)x^{\\underline{n}} = x\\times (x-1) \\times (x-2) \\times \\cdots \\times (x-n+1)xn​=x×(x−1)×(x−2)×⋯×(x−n+1)。 定义上升幂：xn‾=x×(x+1)×(x+2)×⋯×(x+n−1)x^{\\overline{n}} = x \\times (x+1) \\times (x+2) \\times \\cdots \\times (x+n-1)xn=x×(x+1)×(x+2)×⋯×(x+n−1)。 显然若 x&lt;nx &lt; nx&lt;n，则 xn‾=0x^{\\underline{n}} = 0xn​=0。 普通幂转下降幂： xn=∑i=0n{ni}xi‾x^n = \\sum_{i=0}^n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x^{\\underline{i}} xn=i=0∑n​{ni​}xi​ 证明： 考虑使用数学归纳法，显然 n=0n=0n=0 时成立，考虑假设 [0,n−1][0,n-1][0,n−1] 成立，证明 nnn 时成立。 ∑i=0n{ni}xi‾=∑i=0n{n−1i−1}xi‾+∑i=0ni×{n−1i}xi‾=∑i=0n−1{n−1i}xi+1‾+∑i=0n−1i×{n−1i}xi‾=∑i=0n−1(x−i)×{n−1i}xi‾+∑i=0n−1i×{n−1i}xi‾=x×∑i=0n{ni}xi‾=x×xn−1=xn\\begin{aligned} &amp;\\sum_{i=0}^{n} \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= \\sum_{i=0}^{n} \\begin{Bmatrix} n-1 \\\\ i-1 \\end{Bmatrix}x^{\\underline{i}} + \\sum_{i=0}^n i \\times \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= \\sum_{i=0}^{n-1} \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i+1}} + \\sum_{i=0}^{n-1} i \\times \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= \\sum_{i=0}^{n-1} (x-i) \\times \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i}} + \\sum_{i=0}^{n-1} i \\times \\begin{Bmatrix} n-1 \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= x \\times \\sum_{i=0}^n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x^{\\underline{i}} \\\\ &amp;= x \\times x^{n-1} \\\\ &amp;= x^n \\end{aligned} ​i=0∑n​{ni​}xi​=i=0∑n​{n−1i−1​}xi​+i=0∑n​i×{n−1i​}xi​=i=0∑n−1​{n−1i​}xi+1​+i=0∑n−1​i×{n−1i​}xi​=i=0∑n−1​(x−i)×{n−1i​}xi​+i=0∑n−1​i×{n−1i​}xi​=x×i=0∑n​{ni​}xi​=x×xn−1=xn​ 上升幂转通常幂： xn‾=∑i=0n[ni]xix^{\\overline{n}} = \\sum_{i=0}^n \\begin{bmatrix} n \\\\ i \\end{bmatrix} x^i xn=i=0∑n​[ni​]xi 证明同上。 下降幂转通常幂： xn‾=∑i=0n(−1)n−i{ni}xix^{\\underline{n}} = \\sum_{i=0}^n (-1)^{n-i} \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x^i xn​=i=0∑n​(−1)n−i{ni​}xi 通常幂转上升幂： xn=∑i=0n(−1)n−i[ni]xi‾x^{n} = \\sum_{i=0}^n (-1)^{n-i} \\begin{bmatrix} n \\\\ i \\end{bmatrix} x^{\\overline{i}} xn=i=0∑n​(−1)n−i[ni​]xi 上述两个式子的证明： 首先这个式子成立： xn‾=(−1)n×(−x)n‾x^{\\underline{n}} = (-1)^n \\times (-x)^{\\overline{n}} xn​=(−1)n×(−x)n 将这个式子分别带入第一、二个公式即可得到这两个式子。 反转公式： ∑i=mn{ni}[im](−1)n−i=[m=n]∑i=mn[ni]{im}(−1)n−i=[m=n]\\sum_{i=m}^n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} \\begin{bmatrix} i \\\\ m \\end{bmatrix} (-1)^{n-i} = [m = n] \\\\ \\sum_{i=m}^n \\begin{bmatrix} n \\\\ i \\end{bmatrix} \\begin{Bmatrix} i \\\\ m \\end{Bmatrix} (-1)^{n-i}= [m = n] \\\\ i=m∑n​{ni​}[im​](−1)n−i=[m=n]i=m∑n​[ni​]{im​}(−1)n−i=[m=n] 证明： 将第三、四个公式，分别带入第一、二个公式就可以得到这个公式。 斯特林反演： f(n)=∑i=0n[ni]g(i) ⟺ g(n)=∑i=0n(−1)n−i{ni}f(i)f(n)=∑i=0n{ni}g(i) ⟺ g(n)=∑i=0n(−1)n−i[ni]f(i)f(n)=∑i=n[in]g(i) ⟺ g(n)=∑i=n(−1)i−n{in}f(i)f(n)=∑i=n{in}g(i) ⟺ g(n)=∑i=n(−1)i−n[in]f(i)f(n) = \\sum_{i=0}^n \\begin{bmatrix} n \\\\ i \\end{bmatrix} g(i) \\iff g(n) = \\sum_{i=0}^n (-1)^{n-i} \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} f(i) \\\\ f(n) = \\sum_{i=0}^n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} g(i) \\iff g(n) = \\sum_{i=0}^n (-1)^{n-i} \\begin{bmatrix} n \\\\ i \\end{bmatrix} f(i) \\\\ f(n) = \\sum_{i=n} \\begin{bmatrix} i \\\\ n \\end{bmatrix} g(i) \\iff g(n) = \\sum_{i=n} (-1)^{i-n} \\begin{Bmatrix} i \\\\ n \\end{Bmatrix} f(i) \\\\ f(n) = \\sum_{i=n} \\begin{Bmatrix} i \\\\ n \\end{Bmatrix} g(i) \\iff g(n) = \\sum_{i=n} (-1)^{i-n} \\begin{bmatrix} i \\\\ n \\end{bmatrix} f(i) \\\\ f(n)=i=0∑n​[ni​]g(i)⟺g(n)=i=0∑n​(−1)n−i{ni​}f(i)f(n)=i=0∑n​{ni​}g(i)⟺g(n)=i=0∑n​(−1)n−i[ni​]f(i)f(n)=i=n∑​[in​]g(i)⟺g(n)=i=n∑​(−1)i−n{in​}f(i)f(n)=i=n∑​{in​}g(i)⟺g(n)=i=n∑​(−1)i−n[in​]f(i) 下面只证明一下第一个式子的充分性，其余的都可以类比地推出。 g(n)=∑i=0n[i=n]g(i)=∑i=0n(∑j=in{nj}[ji](−1)n−jg(i))=∑j=0n(−1)n−j{nj}(∑i=0j[ji]g(i))=∑j=0n(−1)n−j{nj}f(j)\\begin{aligned} g(n) &amp;= \\sum_{i=0}^n [i=n] g(i) \\\\ &amp;= \\sum_{i=0}^n \\left(\\sum_{j=i}^n \\begin{Bmatrix} n \\\\ j \\end{Bmatrix} \\begin{bmatrix} j \\\\ i \\end{bmatrix} (-1)^{n-j} g(i)\\right) \\\\ &amp;= \\sum_{j=0}^n (-1)^{n-j} \\begin{Bmatrix} n \\\\ j \\end{Bmatrix} \\left(\\sum_{i=0}^j \\begin{bmatrix} j \\\\ i \\end{bmatrix} g(i)\\right) \\\\ &amp;= \\sum_{j=0}^n (-1)^{n-j} \\begin{Bmatrix} n \\\\ j \\end{Bmatrix}f(j) \\end{aligned} g(n)​=i=0∑n​[i=n]g(i)=i=0∑n​(j=i∑n​{nj​}[ji​](−1)n−jg(i))=j=0∑n​(−1)n−j{nj​}(i=0∑j​[ji​]g(i))=j=0∑n​(−1)n−j{nj​}f(j)​ 线性代数 矩阵乘法 若给定矩阵 A,BA,BA,B，使得 C=A×BC = A \\times BC=A×B，则满足：ci,j=∑k(Ai,k×Bk,j)c_{i,j} = \\sum_{k} (A_{i,k} \\times B_{k,j})ci,j​=∑k​(Ai,k​×Bk,j​) 也就是说若 A,BA,BA,B 可以进行矩阵乘法则必须要满足：AAA 的列数等于 BBB 的行数。 矩阵乘法之后的 CCC 矩阵 (i,j)(i,j)(i,j) 位置的元素，相当于 AAA 的第 iii 行与 BBB 的第 jjj 列对应相乘再相加后的结果。 矩阵乘法之后的 CCC 矩阵的行数等于 AAA 的行数，列数等于 BBB 的列数。 矩阵乘法满足结合律，但不满足交换律，即若我们要计算 AkA^kAk 也可以用类似快速幂的方法进行计算。 我们可以将矩阵乘法中的运算更换，比如换成：ci,j=max⁡k(Ai,k+Bk,j)c_{i,j} = \\max_{k} (A_{i,k} + B_{k,j})ci,j​=maxk​(Ai,k​+Bk,j​)，这个东西叫做 max⁡+\\max+max+矩乘，可以证明这种形式的矩阵乘法也满足结合律。 而我们的许多 dpdpdp 中的转移方程就可以用这种矩阵表示出来，所以就可以通过矩阵乘法在 O(log⁡n)O(\\log n)O(logn) 的时间内进行 dpdpdp 或者快速维护动态 dpdpdp。 高斯消元 请查看： 【学习笔记】高斯消元 本文只会扩展一下高斯消元的应用，主要是这种加减消元法的思想。 解异或方程组 记 ⊕\\oplus⊕ 为按位 xor 操作，解下列方程组： a1,1x1⊕a1,2x2⊕⋯a1,nxn=y1a2,1x1⊕a2,2x2⊕⋯a2,nxn=y2⋯am,1x1⊕am,2x2⊕⋯am,nxn=yma_{1,1} x_1 \\oplus a_{1,2} x_2 \\oplus \\cdots a_{1,n} x_n = y_1 \\\\ a_{2,1} x_1 \\oplus a_{2,2} x_2 \\oplus \\cdots a_{2,n} x_n = y_2 \\\\ \\cdots\\\\ a_{m,1} x_1 \\oplus a_{m,2} x_2 \\oplus \\cdots a_{m,n} x_n = y_m\\\\ a1,1​x1​⊕a1,2​x2​⊕⋯a1,n​xn​=y1​a2,1​x1​⊕a2,2​x2​⊕⋯a2,n​xn​=y2​⋯am,1​x1​⊕am,2​x2​⊕⋯am,n​xn​=ym​ 其中 ai,j∈{0,1}a_{i,j} \\in \\{0,1\\}ai,j​∈{0,1} 注意到一点 a⊕a=0a \\oplus a = 0a⊕a=0，也就是我们可以使用这点性质进行消元。 过程与高斯消元相同，因为我们每次只需要支持行的交换和行的对应异或所以可以使用 bitset 优化到 O(n3w)O(\\frac{n^3}{w})O(wn3​)。 矩阵求逆 对于方阵 AAA 若方阵 A−1A^{-1}A−1 满足 A×A−1=A−1×A=IA \\times A^{-1} = A^{-1} \\times A = IA×A−1=A−1×A=I，则称矩阵 AAA 可逆，其中 A−1A^{-1}A−1 就是它的逆矩阵。 记 InI_nIn​ 表示 n×nn\\times nn×n 的单位矩阵，则逆矩阵的求法如下： 构造一个 n×2nn \\times 2nn×2n 的矩阵 (A,In)(A,I_n)(A,In​)。 通过高斯消元将矩阵变成 (In,A−1)(I_n,A^{-1})(In​,A−1)，这样右半部分的矩阵就是 AAA 的逆矩阵 A−1A^{-1}A−1，若左边不可以化为 InI_nIn​ 则矩阵 AAA 不可逆。 行列式求值 对于一个 n×nn \\times nn×n 的行列式 AAA，其行列式的值定义为： det⁡(A)=∑σ∈Snsgn(σ)∏i=1nai,σi\\det(A) = \\sum_{\\sigma \\in S_n} \\text{sgn}(\\sigma)\\prod_{i=1}^n a_{i,\\sigma_i} det(A)=σ∈Sn​∑​sgn(σ)i=1∏n​ai,σi​​ 其中 SnS_nSn​ 定义为长度为 nnn 的全排列集合，sgn(σ)\\text{sgn}(\\sigma)sgn(σ) 定义为排列 σ\\sigmaσ 的奇偶性，若 σ\\sigmaσ 中逆序对数为偶数则 sgn(σ)=1\\text{sgn}(\\sigma) = 1sgn(σ)=1，否则 sgn(σ)=−1\\text{sgn}(\\sigma) = -1sgn(σ)=−1 行列式有如下性质： 交换两行（列）行列式的值取反 证明：若交换 x,yx,yx,y 两行，则考虑贡献是怎么变化的，如果要使得 ∏i=1nai,σi\\prod_{i=1}^n a_{i,\\sigma_i}∏i=1n​ai,σi​​ 依旧是之前的值，就相当于要交换 σx\\sigma_xσx​ 和 σy\\sigma_yσy​，此时 σx,σy\\sigma_x,\\sigma_yσx​,σy​ 是否构成逆序对的情况取反，而对于 p∈(x,y)p\\in(x,y)p∈(x,y)，σp\\sigma_pσp​ 是否与 σx,σy\\sigma_x,\\sigma_yσx​,σy​ 构成逆序对的情况要么同时改变，要么同时不变，所以不会有影响，对于 p∈[1,x)⋃(y,n]p\\in [1,x) \\bigcup (y,n]p∈[1,x)⋃(y,n]，σp\\sigma_pσp​ 是否与 σx,σy\\sigma_x,\\sigma_yσx​,σy​ 构成逆序对显然不会有任何影响。 综上逆序对恰好变化 111，也就是奇偶性会改变，会乘以 −1-1−1。 将一行（列）加到另一行（列）上行列式的值不变 证明：若将 xxx 列加入到 yyy 列上，那么对于一个排列 σ\\sigmaσ 交换 σx\\sigma_xσx​ 与 σy\\sigma_yσy​ 后可以得到一个新的排列 σ′\\sigma'σ′，显然 sgn(σ)=−sgn(σ′)\\text{sgn}(\\sigma) = -\\text{sgn}(\\sigma')sgn(σ)=−sgn(σ′)，而对于多加的贡献在两者中正好形成相反数所以相互抵消了。 若行列式只有 ai,j(i≤j)a_{i,j}(i \\le j)ai,j​(i≤j) 处有值，即一个上三角处有值，则该行列式的值为 ∏i=1nai,i\\prod_{i=1}^n a_{i,i}∏i=1n​ai,i​ 证明：此时对于一个排列 σ\\sigmaσ 要使得 ∏i=1nai,σi\\prod_{i=1}^n a_{i,\\sigma_i}∏i=1n​ai,σi​​ 不为 000，只有 σ={1,2,3,4,⋯ ,n}\\sigma = \\{1,2,3,4,\\cdots,n\\}σ={1,2,3,4,⋯,n}，而此时 sgn(σ)=1\\text{sgn}(\\sigma) = 1sgn(σ)=1，所以行列式的值就是 ∏i=1nai,i\\prod_{i=1}^n a_{i,i}∏i=1n​ai,i​ 将行列式某行（列）同时乘 kkk，则行列式的值乘 kkk 证明：相当于对于每个 σ\\sigmaσ 都将某个 ai,σia_{i,\\sigma_i}ai,σi​​ 乘以 kkk，所以最后的值就会乘以 kkk。 通过上述性质我们就可以直接通过高斯消元将行列式消成上三角，然后对角线元素的乘积就是行列式的值。 需要注意如果消的过程中交换了一次行，要将最后的答案乘以 −1-1−1。 LGV 引理 LGV 引理常用于解决 DAG 上不相交路径（权值）计数问题 记 w(P)w(P)w(P) 表示 PPP 这条路径的权值和，若为路径计数则可将权值记为 111。 记 e(u,v)e(u,v)e(u,v) 表示 uuu 到 vvv 所有路径 PPP 的 w(P)w(P)w(P) 之和。 记起点集合为 AAA，终点集合大小为 BBB，其大小均为 nnn。 则我们的答案为下列行列式的值： M=[e(A1,B1)e(A1,B2)⋯e(A1,Bn)e(A2,B1)e(A2,B2)⋯e(A2,Bn)⋯⋯⋯⋯e(An,B1)e(An,B2)⋯e(An,Bn)]M = \\begin{bmatrix} e(A_1,B_1) &amp;e(A_1,B_2) &amp;\\cdots &amp;e(A_1,B_n) \\\\ e(A_2,B_1) &amp;e(A_2,B_2) &amp;\\cdots &amp;e(A_2,B_n) \\\\ \\cdots &amp;\\cdots &amp;\\cdots &amp;\\cdots \\\\ e(A_n,B_1) &amp;e(A_n,B_2) &amp;\\cdots &amp;e(A_n,B_n) \\\\ \\end{bmatrix} M=⎣⎢⎢⎢⎡​e(A1​,B1​)e(A2​,B1​)⋯e(An​,B1​)​e(A1​,B2​)e(A2​,B2​)⋯e(An​,B2​)​⋯⋯⋯⋯​e(A1​,Bn​)e(A2​,Bn​)⋯e(An​,Bn​)​⎦⎥⎥⎥⎤​ 感觉这个如果不给例题就实在是太抽象了。 例题 CF348D Turtles： 一张 nnn 行 mmm 列的网格图，图中的有些格子上面有障碍物，但保证 (1,1)(1,1)(1,1) 和 (n,m)(n,m)(n,m) 上面都没有障碍物。在 (1,1)(1,1)(1,1) 处有两只乌龟，都想要去 (n,m)(n,m)(n,m)。乌龟每次都可以向下或者向右走一格，前提是格子上没有任何障碍物。要求两只乌龟在前往 (n,m)(n,m)(n,m) 的路途中不可以相遇，即除了起点和终点，他们的路径没有其他公共点。求出从起点到终点的不同路径对数。答案对 109+710^9+7109+7 取模。 考虑我们从 (1,1)(1,1)(1,1) 出发必然经过 (1,2)(1,2)(1,2) 和 (2,1)(2,1)(2,1) 到达 (n,m)(n,m)(n,m) 必然经过 (n−1,m)(n-1,m)(n−1,m) 和 (n,m−1)(n,m-1)(n,m−1)，所以我们的起点集合就是 A={(1,2),(2,1)}A = \\{(1,2),(2,1)\\}A={(1,2),(2,1)} 终点集合就是 B={(n−1,m),(n,m−1)}B = \\{(n-1,m),(n,m-1)\\}B={(n−1,m),(n,m−1)}。 根据 LGV 引理，我们要算四次 e(i,j)e(i,j)e(i,j) 表示从 iii 到 jjj 的路径条数，而这个东西 O(nm)O(nm)O(nm) 的 dpdpdp 做法显然，就很好做了。 矩阵树定理 矩阵树定理可以解决给定一张图，求其生成树个数，这里要求给定的图没有自环。 下面考虑无向图的情况。 给定一张图 G=(V,E)G = (V,E)G=(V,E)，mi,jm_{i,j}mi,j​ 表示直接连接 (i,j)(i,j)(i,j) 的边数，degideg_idegi​ 表示点 iii 的度数，定义它的拉普拉斯矩阵 LLL 为： Li,j={−mi,ji≠jdegii=jL_{i,j} = \\begin{cases} -m_{i,j} &amp; i\\not= j \\\\ deg_i &amp; i = j \\end{cases} Li,j​={−mi,j​degi​​i=ji=j​ 则生成树个数为 LLL 中任意删去一行一列后其行列式的值。 下面考虑有向图的情况。 记 mi,jm_{i,j}mi,j​ 表示从 iii 指向 jjj 的边数，定义出度拉普拉斯矩阵为： Li,jout={−mi,ji≠jdegiouti=jL_{i,j}^{out} = \\begin{cases} -m_{i,j} &amp; i\\not= j\\\\ deg_i^{out} &amp; i = j \\end{cases} Li,jout​={−mi,j​degiout​​i=ji=j​ 定义入度拉普拉斯矩阵为： Li,jin={−mi,ji≠jdegiini=jL_{i,j}^{in} = \\begin{cases} -m_{i,j} &amp; i\\not= j \\\\ deg_i^{in} &amp; i = j \\end{cases} Li,jin​={−mi,j​degiin​​i=ji=j​ 记图 GGG 的以 rrr 为根的根向生成树的方案数为 troot(G,r)t^{root}(G,r)troot(G,r)，记图 GGG 的以 rrr 为根的叶向生成树的方案数为 tleaf(G,r)t^{leaf}(G,r)tleaf(G,r)，则根据矩阵树定理有： troot(G,k)=det⁡Lout(1,2,3,⋯ ,k−1,k+1,⋯ ,n1,2,3,⋯ ,k−1,k+1,⋯ ,n)tleaf(G,k)=det⁡Lin(1,2,3,⋯ ,k−1,k+1,⋯ ,n1,2,3,⋯ ,k−1,k+1,⋯ ,n)t^{root}(G,k) = \\det L^{out}\\binom{1,2,3,\\cdots,k-1,k+1,\\cdots,n}{1,2,3,\\cdots,k-1,k+1,\\cdots,n} \\\\ t^{leaf}(G,k) = \\det L^{in} \\binom{1,2,3,\\cdots,k-1,k+1,\\cdots,n}{1,2,3,\\cdots,k-1,k+1,\\cdots,n} troot(G,k)=detLout(1,2,3,⋯,k−1,k+1,⋯,n1,2,3,⋯,k−1,k+1,⋯,n​)tleaf(G,k)=detLin(1,2,3,⋯,k−1,k+1,⋯,n1,2,3,⋯,k−1,k+1,⋯,n​) 其中定义 L(1,2,3,⋯ ,k−1,k+1,⋯ ,n1,2,3,⋯ ,k−1,k+1,⋯n)L\\binom{1,2,3,\\cdots,k-1,k+1,\\cdots,n}{1,2,3,\\cdots,k-1,k+1,\\cdots n}L(1,2,3,⋯,k−1,k+1,⋯n1,2,3,⋯,k−1,k+1,⋯,n​) 表示 LLL 矩阵除去第 kkk 行第 kkk 列后的矩阵。 BEST 定理 定义 troot(G,k)t^{root}(G,k)troot(G,k) 表示图 GGG 的以 kkk 为根的根向生成树个数。 在有向欧拉图 GGG 中，GGG 中不同欧拉回路的数量为： troot(G,k)∏v∈V(degv−1)!t^{root}(G,k)\\prod_{v \\in V} (deg_v - 1)! troot(G,k)v∈V∏​(degv​−1)! degvdeg_vdegv​ 既可以指出度也可以指入度，因为欧拉图中每个点的入度和出度相等。 kkk 可以为任意点，因为此时对于任意两个点 u,vu,vu,v 都有 troot(G,x)=troot(G,y)t^{root}(G,x) = t^{root}(G,y)troot(G,x)=troot(G,y)。 一种感性理解这个定理的方法： 对于一条欧拉路径，我们保留每一个点的最后一条出边，出边一定构成一棵根向树，因为如果不是就无法构成欧拉路径。 而对于其它的边发现任意排列都可以构成欧拉路径，所以就是∏v∈V(degv−1)!\\prod_{v \\in V} (deg_v-1)!∏v∈V​(degv​−1)!。 乘起来就是 BEST 定理。 多项式与生成函数 请查看： 【学习笔记】数论之生成函数基础 【学习笔记】拉格朗日插值 群论入门 请查看： 【学习笔记】Burnside 定理和 Polya 定理 计算几何 请查看： 【学习笔记】计算几何 博弈论 请查看： 【学习笔记】博弈论 ---- 非偏博弈","link":"/2023/09/14/math/"},{"title":"莫队","text":"从零开始的莫队 本篇主要是我学习了莫队算法之后的一些感受，仅包含普通莫队与普通带修改莫队相关知识，望各位大佬指点一二 首先就是非常经典的莫队适用的题型： （1）区间询问问题，且区间信息不可高效合并，即传统数据结构难以维护 （2）必须可以离线 （3）不带修改（或带简单修改） （4）（这一条可以自动忽略）若已知区间 [L1,R1][L_1,R_1][L1​,R1​] 的答案，我们可以花费 O(∣L1−L2∣)O(|L_1 - L_2|)O(∣L1​−L2​∣) 的时间将左端点移到 L2L_2L2​，花费 O(∣R1−R2∣)O(|R_1 - R_2|)O(∣R1​−R2​∣) 的时间将右端点移到 R2R_2R2​ 的位置，从而得到区间 [L2,R2][L_2,R_2][L2​,R2​] 的答案，即我们区间左右端点移动 111 的复杂度是 O(1)O(1)O(1) 的 下面就来说一下莫队的基本思想： 在我们可以 O(1)O(1)O(1) 地移动区间左右端点地前提下，莫队就是将所有的询问区间按照一定顺序排好，然后从第一个区间开始进行区间的移动，每次移动完一个区间就进行答案的统计，每一个区间的答案从上一个移动好的区间移动过去，而非从头开始重新移动，我们一开始认为已知 [0,0][0,0][0,0] 的答案 对于莫队分块的大小： 普通莫队：n\\sqrt nn​ 带修莫队：n23n^{\\frac{2}{3}}n32​ 四指针莫队：n34n^{\\frac{3}{4}}n43​ 普通莫队 看思想肯定是啥都不会的，下面就通过一道题具体来看一下什么是莫队（相信我莫队真的不难） 题目描述： 基本思路： 我们在本题中维护数组 tmp[i]tmp[i]tmp[i] 表示数 iii 出现的次数，在移动区间的过程中对这个数组进行操作，若 tmp[i]tmp[i]tmp[i] 在加入了一次 iii 之后为 111 则为出现了一个新数，同理若 tmp[i]tmp[i]tmp[i] 在删去了一个 iii 之后为 000 则为消失了一个数，然后按照莫队的基本写法写就好了 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 5e4+5;const int MAXM = 2e5+5;const int MAX_VAL = 1e6+5;struct node{ int l,r,pos,id;}q[MAXM];int a[MAXN],ans[MAXM],tmp[MAX_VAL],n,S,m,res;int bl(int x){ return (x - 1) / S + 1;}bool cmp(node l,node r){ if(bl(l.l) != bl(r.l)) return bl(l.l) &lt; bl(r.l); return l.r &lt; r.r;}void Dele(int val){ if((--tmp[val]) == 0) res--;}void Add(int val){ if((++tmp[val]) == 1) res++;}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n; S = sqrt(n); for(int i=1; i&lt;=n; i++){ cin&gt;&gt;a[i]; } cin&gt;&gt;m; for(int i=1; i&lt;=m; i++){ cin&gt;&gt;q[i].l&gt;&gt;q[i].r; q[i].pos = i; } sort(q+1,q+m+1,cmp); //按照第一关键字块内顺序，第二关键字大小顺序排序 int now_l = 0,now_r = 0; for(int i=1; i&lt;=m; i++){ while(now_l &gt; q[i].l) Add(a[--now_l]); //因为这个数我们加过了，所以加减过后的 while(now_r &lt; q[i].r) Add(a[++now_r]); while(now_l &lt; q[i].l) Dele(a[now_l++]); //因为这个数我们也要删除，所以先删再加 while(now_r &gt; q[i].r) Dele(a[now_r--]); ans[q[i].pos] = res; } for(int i=1; i&lt;=m; i++){ cout&lt;&lt;ans[i]&lt;&lt;endl; } return 0;} 代码部分说明： bl(i)bl(i)bl(i) 返回的是分块之后 iii 所在块的编号 这也就是普通莫队的写法，对于不同的题目唯一需要修改的也就是 AddAddAdd 函数和 DeleDeleDele 函数而已。 需要注意的一点（也是我之前不知道的一点）：在莫队的扩展区间要先进行 l−−l--l−−,r++r++r++ 然后再进行 l++l++l++,r−−r--r−−，为了避免出现比如 [5,3][5,3][5,3] 这种的恶心情况 带修改莫队 带修改莫队与普通莫队基本是一致的，推荐理解了普通莫队之后再进行观看。 带修莫队会比普通莫队多维护一个值：时间戳，说白了就是这个询问在第几次修改后，那么在我们进行区间移动的时候，只需要在移动完区间之后，再移动一下时间戳，使得时间戳也符合当前询问的条件就好了。 下面依旧是通过一道题来具体的看看带修莫队： 题目描述： 基本思路： 使用带修莫队，与普通莫队一样维护一个 tmptmptmp 数组， tmp[i]tmp[i]tmp[i] 表示数 iii 出现的次数，然后按上一道题的写法写就好了，就是移动区间的时候需要移动时间戳 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e4+5;const int MAXM = 1e4+5;const int MAX_VAL = 1e6+5;struct node{ int l,r,time,id;}q[MAXM];struct node2{ int pos,val;}c[MAXM];int tmp[MAX_VAL],a[MAXN],ans[MAXM],n,m,qnum,tim,S,res;int bl(int x){ return (x - 1) / S + 1;}bool cmp(node x,node y){ if(bl(x.l) != bl(y.l)) return bl(x.l) &lt; bl(y.l); if(bl(x.r) != bl(y.r)) return bl(x.r) &lt; bl(y.r); if(x.time != y.time) return x.time &lt; y.time;}void add(int x){ if((++tmp[a[x]]) == 1) res++;} void Dele(int x){ if((--tmp[a[x]]) == 0) res--;}void change(int now,int i){ if(c[now].pos &gt;= q[i].l &amp;&amp; c[now].pos &lt;= q[i].r){ if((++tmp[c[now].val]) == 1) res++; if((--tmp[a[c[now].pos]]) == 0) res--; } swap(c[now].val,a[c[now].pos]);}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n&gt;&gt;m; S = int(pow(n,0.66)); for(int i=1; i&lt;=n; i++){ cin&gt;&gt;a[i]; } for(int i=1; i&lt;=m; i++){ char opt; int x,y; cin&gt;&gt;opt&gt;&gt;x&gt;&gt;y; if(opt == 'Q'){ q[++qnum].l = x; q[qnum].r = y; q[qnum].time = tim; q[qnum].id = qnum; } else if(opt == 'R'){ c[++tim].pos = x; c[tim].val = y; } } sort(q+1,q+qnum+1,cmp); int now = 0,now_l = 0,now_r = 0; for(int i=1; i&lt;=qnum; i++){ while(q[i].l &lt; now_l) add(--now_l); while(q[i].r &gt; now_r) add(++now_r); while(q[i].l &gt; now_l) Dele(now_l++); while(q[i].r &lt; now_r) Dele(now_r--); while(q[i].time &lt; now) change(now--,i); //非常好的一句话：改多了，改回去，所以 now 点也要改回去 while(q[i].time &gt; now) change(++now,i); //改少了，改过来，now 点已经改过了，所以不用了 ans[q[i].id] = res; } for(int i=1; i&lt;=qnum; i++){ cout&lt;&lt;ans[i]&lt;&lt;endl; } return 0;} 代码部分说明： 其他的我就不多说了，我们仔细读读代码就明白了，关于 changechangechange 函数最后的 swapswapswap 操作的说明，我们在移动时间戳的时候第一次处理这个修改即会将 aaa 中对应的值改为 ccc 中对应的值，而当我们第二次要处理这个修改就是相当于我们搞回去了，也就是这个修改不要了，所以对于第二次就是将 aaa 中对应的值改回去，也就是改成交换后 ccc 里的值，交换之后再次修改就可以实现这个功能","link":"/2022/04/05/modui/"},{"title":"杂题选做（2023.9.20）","text":"主要是分析性质，然后解决问题的题。 ABC320G 题目描述： 给定 nnn 个转盘，每个转盘上都有 mmm 个 [0,9][0,9][0,9] 的数，设开始时为 000 时刻，在时刻 ttt 我们可以选择至多一个转盘按下，或者不选择，如果我们选择了一个转盘，那么这个转盘就会停留在其第 (tmod m)+1(t \\mod m) + 1(tmodm)+1 个数上面，询问最小的时刻 ttt 满足存在一种选择方案使得所有的转盘上停留下来的数字相同。 n≤100，m≤105n \\le 100，m \\le 10^5n≤100，m≤105 题目分析： 因为只有 101010 种数字，所以我们可以考虑枚举最后保留下来的相同的数字是什么。 可以观察到答案具有可二分性，所以可以二分一个时刻 ttt，然后转化为判断是否合法。 这个时候直接做好像不大行，所以考虑能不能发现一些性质。 枚举完了最后留下的数字之后，就相当于我们在每一个时刻可以选择一个转盘使得其合法，而每一个转盘也至多会被选择一次。 这个过程就是类似于匹配的过程，所以我们可以将转盘看作左部点，时刻看作右部点，这样当我们二分答案结束后，问题就转化为了左部点是否能完全匹配。 但是这样好像复杂度很爆表，因为我们左部点的个数为 O(n)O(n)O(n)，而时刻有 O(nm)O(nm)O(nm) 个，所以我们的连边可能有 O(n2m)O(n^2m)O(n2m) 条，直接做的话显然不能通过。 但是注意到一点，这些连边中有用的连边并不多，对于任意一个左部点，我们其实只会关注其前 nnn 条连边，因为只会匹配 nnn 个字符串，而我们肯定是尽可能地靠前匹配，所以最劣情况下 nnn 条边也足够了。 这样的话我们的连边数量就变成了 O(n2)O(n^2)O(n2)，可以直接上匈牙利算法，算上二分的复杂度为 O(n3log⁡(nm))O(n^3 \\log (nm))O(n3log(nm))。 要注意的细节就是二分的上界，尽可能设大一点，我就是因为上界因为一些意外设成了 nm−1nm - 1nm−1 而挂掉，虽然我真的构造不出来答案为 nmnmnm 的情况。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5+5;vector&lt;int&gt; v[200][10];int n,m;map&lt;int,int&gt; match,vis;char s[N];bool dfs(int now,int limit,int num){ for(auto x : v[now][num]){ for(int to=x; to&lt;=limit; to+=m){ if(vis[to]) continue; vis[to] = true; if(!match[to] || dfs(match[to],limit,num)){ match[to] = now; //记录左部点匹配哪一个是没有意义的 return true; } } } return false;}bool chk(int limit,int num){ match.clear(); for(int i=1; i&lt;=n; i++){ vis.clear(); if(!dfs(i,limit,num)) return false; } return true;}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++){ scanf(&quot;%s&quot;,s+1); for(int j=1; j&lt;=m; j++){ v[i][s[j]-'0'].push_back(j); } } int tmp = n * m + 1; for(int x=0; x&lt;=9; x++){ int l = 1,r = n * m + 1,ans = n * m + 1; while(l &lt;= r){ int mid = (l + r) &gt;&gt; 1; if(chk(mid,x)) ans = mid,r = mid - 1; else l = mid + 1; } tmp = min(tmp,ans); } if(tmp == n * m + 1) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;,tmp-1); //因为 0 时刻对应第一个，所以要减一 return 0;} [CQOI2018] 交错序列 题目描述： 我们称一个仅由 0、1 构成的序列为”交错序列“，当且仅当序列中没有相邻的 1(可以有相邻的 0)。例如，000,001,101,都是交错序列，而 110 则不是。 对于一个长度为 nnn 的交错序列，统计其中 0 和 1 出现的次数，分别记为 x 和 y。给定参数 a、b,定义一个交错序列的特征值为 xaybx^ay^bxayb。注意这里规定任何整数的 0 次幂都等于 1(包括 00=10^0=100=1)。 显然长度为 n 的交错序列可能有多个。我们想要知道，所有长度为 n 的交错序列的特征值的和，除以 m 的余数。(m 是一个给定的质数) 例如，全部长度为 3 的交错串为: 000、001、010、100、101。当 a=1,b=2 时，可计算: 31×02+21×12+21×12+21×12+11×22=103^1\\times0^2+2^1\\times1^2+2^1\\times1^2+2^1\\times1^2+1^1\\times2^2=1031×02+21×12+21×12+21×12+11×22=10 对于 100%100\\%100% 的数据，1≤n≤107，0≤a≤b≤45，1≤m≤1081 \\le n \\le 10^7，0 \\le a \\le b \\le 45，1 \\le m \\le 10^81≤n≤107，0≤a≤b≤45，1≤m≤108 题目分析： 做法一： 注意到 nnn 只有 10710^7107 所以我们可以考虑枚举一点东西。 因为要求 111 不能相邻，所以一个经典的想法就是枚举 111 的个数，然后认为序列里全部都是 111 之后通过将 000 插入进去得到方案数，而当 0,10,10,1 的数量确定之后特征值也确定了，所以就直接乘起来就好。 假设 111 的数量为 xxx，则 000 的数量为 y=n−xy = n-xy=n−x。 一开始就是通过 000 将 111 分开，也就是 y−(x−1)→yy - (x-1) \\to yy−(x−1)→y。 然后就是将 000 随意地插入到 111 之间的空袭中，也就是将 yyy 个小球放到 x+1x+1x+1 个盒子里，盒子允许为空地方案数，即 (x+yx)\\binom{x+y}{x}(xx+y​)。 所以这种情况下得到的特征值之和就是 (x+yy)×xa×yb\\binom{x+y}{y} \\times x^a \\times y^b(yx+y​)×xa×yb。 因为数据其实保证了 m&gt;nm &gt; nm&gt;n，也就是我们可以通过预处理阶乘的方式 O(1)O(1)O(1) 算组合数，但是其实题目并没有保证这一点，所以其实可以被卡掉。 如果快速幂算 xax^axa 大概无法通过，但是注意到当 aaa 为定值时 xax^axa 为完全积性函数，所以可以提前线性筛筛出所有 xax^axa 和 yby^byb，这样就可以 O(1)O(1)O(1) 得到答案了。 这样的总复杂度就是 O(n)O(n)O(n)。 做法二： 一个直接的想法就是 dpdpdp 去做这个问题，dpdpdp 的决策显然就是每次新插入一个 000 或者一个 111，但是注意到我们插入的时候对于特征值的变化是一个二项式定理的形式，而且还有两维，就十分不可做。 先考虑把这个变成一维的形式，说不定就可以做了。 xayb=(n−y)ayb=∑i=0a(ai)ni(−y)a−iyb=∑i=0a(ai)ni(−1)a−iya+b−ix^ay^b = (n-y)^ay^b = \\sum_{i=0}^a \\binom{a}{i} n^i (-y)^{a-i} y^b = \\sum_{i=0}^a \\binom{a}{i} n^i (-1)^{a-i} y^{a+b-i} xayb=(n−y)ayb=i=0∑a​(ia​)ni(−y)a−iyb=i=0∑a​(ia​)ni(−1)a−iya+b−i 可以发现除了 ya+b−1y^{a+b-1}ya+b−1 这一项其它的都是常数项，都可以直接忽略。 显然要使用 dpdpdp 去解决这个问题，因为我们的转移必然形如二项式定理的形式，所以为了可以转移就有了如下的状态：dp[i][j][0/1]dp[i][j][0/1]dp[i][j][0/1] 表示考虑了前 iii 个位置，最后一个位置为 0/10/10/1，所有方案的 yjy^jyj 求和的结果。 转移的话就十分显然： dp[i−1][j][0/1]→dp[i][j][0]∑k=0j(jk)dp[i−1][k][0]→dp[i][j][1]dp[i-1][j][0/1] \\to dp[i][j][0] \\\\ \\sum_{k=0}^j \\binom{j}{k} dp[i-1][k][0] \\to dp[i][j][1] dp[i−1][j][0/1]→dp[i][j][0]k=0∑j​(kj​)dp[i−1][k][0]→dp[i][j][1] 直接转移就是 O(n(a+b)2)O(n(a+b)^2)O(n(a+b)2) 不能通过，但是因为 nnn 很大，所以肯定要想办法快速转移。 注意到转移可以写成一个矩阵乘法的形式，所以可以直接构造矩阵然后矩阵快速幂转移，复杂度 O((a+b)3log⁡n)O((a+b)^3 \\log n)O((a+b)3logn)。 构造矩阵的一个小技巧就是转移矩阵的 (i,j)(i,j)(i,j) 处的值相当于转移时 f[i]f[i]f[i] 对 f[j]f[j]f[j] 的贡献系数，所以根据这个构造起来就很简单了。 代码： 做法一： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1e7+5;int n,a,b,MOD,tot;int fac[N],inv[N],pwa[N],pwb[N],prime[N];bool flag[N];int power(int a,int b){ int res = 1; while(b){ if(b &amp; 1) res = res * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; } return res;}int binom(int n,int m){ if(n &lt; m || n &lt; 0 || m &lt; 0) return 0; return fac[n] * inv[m] % MOD * inv[n-m] % MOD;}void pre_work(int n){ pwa[0] = a == 0 ? 1 : 0,pwb[0] = b == 0 ? 1 : 0; pwa[1] = 1,pwb[1] = 1; for(int i=2; i&lt;=n; i++){ if(!flag[i]){ pwa[i] = power(i,a); pwb[i] = power(i,b); prime[++tot] = i; } for(int j=1; prime[j]*i&lt;=n&amp;&amp;j&lt;=tot; j++){ pwa[prime[j]*i] = pwa[prime[j]] * pwa[i] % MOD; pwb[prime[j]*i] = pwb[prime[j]] * pwb[i] % MOD; flag[prime[j]*i] = true; if(i % prime[j] == 0) break; } }}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;a,&amp;b,&amp;MOD); pre_work(n); fac[0] = 1; for(int i=1; i&lt;=n; i++) fac[i] = fac[i-1] * i % MOD; inv[n] = power(fac[n],MOD-2); for(int i=n-1; i&gt;=0; i--) inv[i] = inv[i+1] * (i+1) % MOD; int ans = 0; for(int x=0; x&lt;=n; x++){ int y = n - x; if(y &lt; x - 1) continue; if(x != 0) y -= x-1; ans = (ans + binom(x+y,x) * pwa[n-x]%MOD * pwb[x]%MOD)%MOD; } printf(&quot;%lld\\n&quot;,ans); return 0;} 做法二： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 305;struct Matrix{ int n,m; int a[N][N]; Matrix(){ memset(a,0,sizeof(a)); }};int n,a,b,MOD,fac[N],inv[N],C[N][N];Matrix operator * (Matrix a,Matrix b){ Matrix c; c.n = a.n,c.m = b.m; for(int i=0; i&lt;c.n; i++){ for(int j=0; j&lt;c.m; j++){ for(int k=0; k&lt;a.m; k++){ c.a[i][j] = (c.a[i][j] + a.a[i][k] * b.a[k][j]%MOD)%MOD; } } } return c;}int power(int a,int b){ int res = 1; while(b){ if(b &amp; 1) res = res * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; } return res;}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;a,&amp;b,&amp;MOD); int len = a + b + 1; C[0][0] = 1; for(int i=1; i&lt;=2*len; i++){ C[i][0] = 1; for(int j=1; j&lt;=i; j++){ C[i][j] = (C[i-1][j] + C[i-1][j-1])%MOD; } } Matrix tmp; tmp.n = tmp.m = 2 * len; for(int i=0; i&lt;len; i++){ //默认 &lt; len 的位置存 0 //默认 &gt;=len 的位置存 1 tmp.a[i][i]++; tmp.a[i+len][i]++; for(int j=i; j&lt;len; j++) tmp.a[i][j+len] = (tmp.a[i][j+len] + C[j][i])%MOD; } Matrix ans; ans.a[0][0] = 1;ans.n = 1,ans.m = 2 * len; int tn = n; while(tn){ if(tn &amp; 1) ans = ans * tmp; tmp = tmp * tmp; tn &gt;&gt;= 1; } int res = 0; for(int i=0; i&lt;=a; i++){ int tmp1 = (ans.a[0][a+b-i] + ans.a[0][a+b-i+len])%MOD; tmp1 = tmp1 * C[a][i]%MOD * power(-1,a-i)%MOD * power(n,i)%MOD; res = (res + tmp1 + MOD)%MOD; } printf(&quot;%lld\\n&quot;,res); return 0;} [雅礼集训2017] 蛐蛐国的修墙方案 题目描述： 给定一个长度为 nnn 的排列 ppp，要求构造一个合法括号序列 sss。 若 sis_isi​ 为左括号，则连边 (i,pi)(i,p_i)(i,pi​)，并将两个点的度数均加 111。 要求所有点的度数均为 111. 1≤n≤1001 \\le n \\le 1001≤n≤100 题目分析: 看到这个东西，一个显然的想法就是连边 (i,pi)(i,p_i)(i,pi​) 将排列转化为置换的形式。 连完边之后可以发现对于每一个置换环，其对应的 sss 一定是满足 ()()()(⋯()()()(\\cdots()()()(⋯ 的形式，所以我们只需要确定了一个位置是什么其它的位置就都确定了，以及注意到如果一个环上有奇数个点则一定不合法。 直接这样做的复杂度就是 O(2n2)O(2^{\\frac{n}{2}})O(22n​) 比较爆炸。 但是注意到，对于一个长度为 222 的环，若其上面的两个点为 i,ji,ji,j 且满足 i&lt;ji &lt; ji&lt;j，那么我们可以直接令 si=(s_i = (si​=(,sj=)s_j = )sj​=)，这样就可以直接将这个长度为 222 的环忽略，因为这样可以直接认为 i,ji,ji,j 匹配，就可以去掉这两个点了，这样就只剩下了长度大于等于 444 的环，而这种环最多有 O(n4)O(\\frac{n}{4})O(4n​) 个，所以直接暴力枚举每一个环是什么样子的，复杂度就是 O(2n4)O(2^{\\frac{n}{4}})O(24n​) 可以通过。 代码实现比较不行，复杂度比较高，但是依旧可以通过。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 105;char s[N];bool vis[N];int n,pre[N],nxt[N];bool flag = false;void dfs(int now,int res){ if(res &lt; 0 || flag) return; if(now == n + 1){ if(res != 0) return; for(int i=1; i&lt;=n; i++) printf(&quot;%c&quot;,s[i]); flag = true; return; } if(vis[now]){ if(s[now] == '(') dfs(now+1,res+1); else dfs(now+1,res-1); return; } if(!vis[nxt[now]] &amp;&amp; !vis[pre[now]]){ vis[now] = true; s[now] = '('; dfs(now+1,res+1); s[now]=')'; dfs(now+1,res-1); vis[now] = false; } if(vis[nxt[now]] &amp;&amp; vis[pre[now]] &amp;&amp; s[nxt[now]] != s[pre[now]]) return; if(vis[nxt[now]]){ vis[now] = true; if(s[nxt[now]] == '(') s[now] = ')',dfs(now+1,res-1); else s[now] = '(',dfs(now+1,res+1); vis[now] = false; } else if(vis[pre[now]]){ vis[now] = true; if(s[pre[now]] == '(') s[now] = ')',dfs(now+1,res-1); else s[now] = '(',dfs(now+1,res+1); vis[now] = false; }}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++){ scanf(&quot;%d&quot;,&amp;nxt[i]); pre[nxt[i]] = i; } for(int i=1; i&lt;=n; i++){ if(nxt[nxt[i]] == i){ if(i &gt; nxt[i]) s[i] = ')',s[nxt[i]] = '('; else s[i] = '(',s[nxt[i]] = ')'; vis[i] = vis[nxt[i]] = true; } } dfs(1,0); return 0;} [JSOI2008] 球形空间产生器 题目描述： 有一个球形空间产生器能够在 nnn 维空间中产生一个坚硬的球体。现在，你被困在了这个 nnn 维球体中，你只知道球面上 n+1n+1n+1 个点的坐标，你需要以最快的速度确定这个 nnn 维球体的球心坐标，以便于摧毁这个球形空间产生器。 1≤n≤101 \\le n \\le 101≤n≤10 题目分析： 设球心坐标为 (x1,x2,x3,⋯ ,xn)(x_1,x_2,x_3,\\cdots,x_n)(x1​,x2​,x3​,⋯,xn​)，球的半径为 rrr。 则球上一个点对这个东西的限制就是： (x1′−x1)2+(x2′−x2)2+⋯+(xn′−xn)2=r2(x_1'-x_1)^2 + (x_2'-x_2)^2 + \\cdots + (x_n'-x_n)^2 = r^2 (x1′​−x1​)2+(x2′​−x2​)2+⋯+(xn′​−xn​)2=r2 但是我们关于解方程组只会高斯消元这种东西，可以发现的一点就是如果我们将 n+1n+1n+1 个点的坐标都写出来，对于相邻的两个式子相减，就可以得到这样的一个 nnn 元一次方程，这样构造出 n+1n+1n+1 个方程就可以做了。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 20;int n;double ans[MAXN],f[MAXN][MAXN];double c[MAXN][MAXN];void Gauss(){ for(int i=1; i&lt;=n; i++){ int mx = i; for(int j=i+1; j&lt;=n; j++){ if(fabs(f[j][i]) &gt; fabs(f[mx][i])) mx = j; } if(mx != i){ for(int j=i; j&lt;=n+1; j++){ swap(f[i][j],f[mx][j]); } } for(int j=i+1; j&lt;=n; j++){ double tmp = f[j][i] / f[i][i]; for(int k=i; k&lt;=n+1; k++){ f[j][k] -= f[i][k] * tmp; } } } for(int i=n; i&gt;=1; i--){ double t = f[i][n+1]; for(int j=n; j&gt;i; j--){ t-=ans[j] * f[i][j]; } ans[i] = t /f[i][i]; }} int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n; for(int i=0; i&lt;=n; i++){ for(int j=1; j&lt;=n; j++){ cin&gt;&gt;c[i][j]; } } for(int i=1; i&lt;=n; i++){ for(int k=1; k&lt;=n; k++){ f[i][k] = (c[i][k] - c[i-1][k]) * 2; f[i][n+1] += c[i][k] * c[i][k] - c[i-1][k] * c[i-1][k]; } } Gauss(); for(int i=1; i&lt;=n; i++){ printf(&quot;%.3lf &quot;,ans[i]); } return 0;} [CTSC2011] 幸福路径 题目描述： 有向图 GGG 有 nnn 个顶点 1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n，点 iii 的权值为 w(i)w(i)w(i)。现在有一只蚂蚁，从给定的起点 v0v_0v0​ 出发，沿着图 GGG 的边爬行。开始时，它的体力为 111。每爬过一条边，它的体力都会下降为原来的 ρ\\rhoρ 倍，其中 ρ\\rhoρ 是一个给定的小于 111 的正常数。而蚂蚁爬到某个顶点时的幸福度，是它当时的体力与该点权值的乘积。 我们把蚂蚁在爬行路径上幸福度的总和记为 HHH。很显然，对于不同的爬行路径，HHH 的值也可能不同。小 Z 对 HHH 值的最大可能值很感兴趣，你能帮助他计算吗？注意，蚂蚁爬行的路径长度可能是无穷的。 答案精确到小数点后 111 位。 对于 100%100\\%100% 的数据， n≤100，m≤1000，ρ≤1–10−6，w≤100n \\le 100， m \\le 1000， \\rho \\le 1 – 10^{-6}， w \\le 100n≤100，m≤1000，ρ≤1–10−6，w≤100。 题目分析： 做法一： 我们并没有找到什么性质，就是硬做。 一个想法就是注意到我们只需要一个近似的最优解就可以了，只要小数点后 111 位是对的即可，而 ρ108\\rho^{10^8}ρ108 就已经是一个极小的数了，所以可以直接钦定走 10810^8108 步找最优解。 直接一步步走肯定不行，所以可以直接倍增这样的话复杂度就很对了。 做法二： 最优的路径可能是无限长的，而无限长必然意味着我们在一个环上绕圈，所以可以发现我们的最优路径必然是先正常走一段路，然后跑到某个环上绕圈。 那么为什么不绕圈到一半再走出来呢，注意我们走出来意味着我们认为绕圈得到的收益不如出来多，而我们每次绕圈都会使得 ρ\\rhoρ 减小，所以为什么要绕圈而非直接走出去呢。 对于前面正常走一段路我们就可以考虑暴力一步步地走，然后更新。 对于绕圈我们就是要对于每一个点找到一个最优的环，而我们发现按照上面的暴力一步步走，如果走出来的是一个环，则必然是这个长度下最优的环，所以直接做就好了。 如果一个环上点的权值分别是 a1,a2,a3,⋯ ,ana_1,a_2,a_3,\\cdots,a_na1​,a2​,a3​,⋯,an​，默认我们一开始就绕圈，那么无限绕圈对应的权值就是 a1+a2ρ+a3ρ2+⋯+anρn−1+a1ρn+⋯a_1 + a_2\\rho + a_3\\rho^2 + \\cdots + a_n\\rho^{n-1} + a_1\\rho^{n} + \\cdotsa1​+a2​ρ+a3​ρ2+⋯+an​ρn−1+a1​ρn+⋯，设 S=a1+a2ρ+a3ρ2+⋯+anρn−1S = a_1 + a_2\\rho + a_3\\rho^2 + \\cdots + a_n\\rho^{n-1}S=a1​+a2​ρ+a3​ρ2+⋯+an​ρn−1，则这个贡献就相当于 S+ρnS+ρ2nS+⋯S + \\rho^{n} S + \\rho^{2n}S + \\cdotsS+ρnS+ρ2nS+⋯ 使用等比数列求和公式这个东西的值就等于 S1−ρn\\frac{S}{1-\\rho^n}1−ρnS​，如果不是一开始就绕圈，那么乘以对应的 ρx\\rho^xρx 即可。 每走一步复杂度为 O(n+m)O(n+m)O(n+m)，而我们一开始处理最优环的时候是让每个点都走了 O(n)O(n)O(n) 步，所以总时间复杂度为 O(n2(n+m))O(n^2(n+m))O(n2(n+m)) （这份代码目前是洛谷上的最优解代码） 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4+5;const int INF = 1e9;int n,m,s;double p,w[N],dis[N],diss[N],cir[N];vector&lt;int&gt; G[N];double get(int x){ for(int i=1; i&lt;=n; i++) dis[i] = -INF; dis[x] = w[x]; double ans = 0,tmp = p; for(int i=1; i&lt;=100; i++){ for(int now=1; now&lt;=n; now++) diss[now] = dis[now]; for(int now=1; now&lt;=n; now++){ for(int to : G[now]){ diss[to] = max(diss[to],dis[now] + w[to] * tmp); } } for(int now=1; now&lt;=n; now++) dis[now] = diss[now]; ans = max(ans,(dis[x] - w[x] * tmp) / (1.0 - tmp)); tmp = tmp * p; } return ans;}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(&quot;%lf&quot;,&amp;w[i]); scanf(&quot;%d&quot;,&amp;s); scanf(&quot;%lf&quot;,&amp;p); for(int i=1; i&lt;=m; i++){ int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); G[u].push_back(v); } for(int i=1; i&lt;=n; i++) cir[i] = get(i); double ans = 0; for(int i=1; i&lt;=n; i++) dis[i] = -INF; double tmp = p;dis[s] = w[s]; for(int i=1; i&lt;=100; i++){ for(int now=1; now&lt;=n; now++) diss[now] = dis[now]; for(int now=1; now&lt;=n; now++){ for(int to : G[now]){ diss[to] = max(diss[to],dis[now] + w[to] * tmp); } } for(int now=1; now&lt;=n; now++) dis[now] = diss[now]; for(int now=1; now&lt;=n; now++) ans = max(ans,dis[now] - w[now] * tmp + cir[now] * tmp); tmp = tmp * p; } printf(&quot;%.1f&quot;,ans); return 0;}","link":"/2023/09/21/practice-2023-9-20/"},{"title":"杂题选做（2023.9.25 - 2023.9.26）","text":"杂题选做（2023.9.25 - 2023.9.26） GYM100837F Controlled Tournament 题目描述： 有 nnn 个人进行淘汰赛，已知 Ri,jR_{i,j}Ri,j​ 表示第 iii 个人和第 jjj 个人比赛的胜负情况。 每一时刻内可以安排任意多场比赛，但是一个人一个时刻最多只能打一场比赛。 给定 mmm，要求在花费时间最小的前提下，使得 mmm 获胜的方案数。 也就是说，如果在花费时间最小的时候，不存在任意一种方案使得 mmm 可以获胜，则答案为 000。 题目分析： 既然花费时间最小，也就是肯定是 ⌈log⁡n⌉\\lceil \\log n \\rceil⌈logn⌉ 个时刻。 所以不妨假设 f[i][j][S]f[i][j][S]f[i][j][S] 表示考虑了前 iii 个时刻，考虑了 SSS 内的人，获胜者为 jjj 的方案数。 转移其实就是考虑是哪两个状态合并到这个状态的。 直接做的话复杂度会比较高，但是如果使用记忆化搜索的方式就能少掉很多无用的状态，就可以通过此题了。 需要注意的一点细节就是：nnn 不一定可以表示为 2k2^k2k 的形式，所以我们单独的一个人，可能可以在任意一个时刻被加入到 dpdpdp 中，这个也就是 dpdpdp 的初值。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 17;int n,m,dp[6][N][1&lt;&lt;N],tot[1&lt;&lt;N];int R[N][N];void add(int &amp;a,int b){ a = (a + b);}int get(int x,int y,int S){ if(~dp[x][y][S]) return dp[x][y][S]; if((1&lt;&lt;x) &lt; tot[S]) return dp[x][y][S] = 0; if(S == (1&lt;&lt;(y-1))) return dp[x][y][S] = 1; int tmp = 0; for(int i=1; i&lt;=n; i++){ if(!R[y][i]) continue; for(int T=S; T; T=(T-1)&amp;S){ if(((T &gt;&gt; (y-1)) &amp; 1) &amp;&amp; (((S^T) &gt;&gt; (i-1)) &amp; 1)) tmp += get(x-1,y,T) * get(x-1,i,S^T); } } return dp[x][y][S] = tmp;}signed main(){// freopen(&quot;f.in&quot;,&quot;r&quot;,stdin);// freopen(&quot;f.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=n; j++){ scanf(&quot;%d&quot;,&amp;R[i][j]); } } for(int i=0; i&lt;(1&lt;&lt;n); i++) tot[i] = __builtin_popcount(i); memset(dp,-1,sizeof(dp)); int t = ceil(log2(n)); get(t,m,(1&lt;&lt;n)-1); if(dp[t][m][(1&lt;&lt;n)-1] == -1) dp[t][m][(1&lt;&lt;n)-1] = 0; printf(&quot;%d\\n&quot;,dp[t][m][(1&lt;&lt;n)-1]); return 0;} [NOI2021] 轻重边 题目描述 小 W 有一棵 nnn 个结点的树，树上的每一条边可能是轻边或者重边。接下来你需要对树进行 mmm 次操作，在所有操作开始前，树上所有边都是轻边。操作有以下两种： 给定两个点 aaa 和 bbb，首先对于 aaa 到 bbb 路径上的所有点 xxx（包含 aaa 和 bbb），你要将与 xxx 相连的所有边变为轻边。然后再将 aaa 到 bbb 路径上包含的所有边变为重边。 给定两个点 aaa 和 bbb，你需要计算当前 aaa 到 bbb 的路径上一共包含多少条重边。 【数据范围】 对于所有测试数据：T≤3T \\le 3T≤3，1≤n,m≤1051 \\le n, m \\le {10}^51≤n,m≤105。 题目分析： 可以考虑将对链 (a,b)(a,b)(a,b) 的修改，变成将链 (a,b)(a,b)(a,b) 染上一个之前从未出现过的颜色。 这样一条重边也就是意味着连接的两个点颜色相同，一条轻边也就是连接的两个点颜色不同。 可以使用树链剖分维护，因为树链剖分是将一条树上的路径剖分为了若干个儿子到祖先的链，所以可以直接维护 (sum,l,r)(sum,l,r)(sum,l,r) 表示这条链的重链个数，左右端点的颜色，就可以支持高效合并了。 以及注意当我们树剖开始划分 lcalcalca 所在链的时候，要注意区间左右端点的交换问题，因为我们一直默认同一条儿子到祖先的链中 depdepdep 小的为左端点。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5+5;const int INF = 1e9 + 5;struct edge{ int nxt,to; edge(){} edge(int _nxt,int _to){ nxt = _nxt,to = _to; }}e[2 * N];struct node{ int l_col,r_col,sum;}T[4 * N];node operator + (node a,node b){ node c; c.l_col = a.l_col; c.r_col = b.r_col; c.sum = a.sum + b.sum + (a.r_col == b.l_col); return c;}int n,m,cnt,tot,head[N],dep[N],fa[N],dfn[N],son[N],sz[N],top[N],tag[4 * N];void add_edge(int from,int to){ e[++cnt] = edge(head[from],to); head[from] = cnt;}void dfs1(int now,int fath){ dep[now] = dep[fath] + 1; fa[now] = fath;sz[now] = 1;son[now] = 0; for(int i=head[now]; i; i=e[i].nxt){ int to = e[i].to; if(to == fath) continue; dfs1(to,now); if(sz[to] &gt; sz[son[now]]) son[now] = to; sz[now] += sz[to]; }}void dfs2(int now,int topf){ top[now] = topf;dfn[now] = ++tot; if(son[now]) dfs2(son[now],topf); for(int i=head[now]; i; i=e[i].nxt){ int to = e[i].to; if(to == fa[now] || to == son[now]) continue; dfs2(to,to); }}void build(int now,int now_l,int now_r){ T[now].l_col = -now_l;//赋成这个值就是为了避免认为初值相等，也是重边 T[now].r_col = -now_r; T[now].sum = 0; tag[now] = 0; if(now_l == now_r) return; int mid = (now_l + now_r)&gt;&gt;1; build(now&lt;&lt;1,now_l,mid);build(now&lt;&lt;1|1,mid+1,now_r);}void update(int now,int now_l,int now_r,int col){ T[now].l_col = T[now].r_col = col; T[now].sum = now_r - now_l; tag[now] = col;}void pushdown(int now,int now_l,int now_r){ if(!tag[now]) return; int mid = (now_l + now_r) &gt;&gt; 1; update(now&lt;&lt;1,now_l,mid,tag[now]); update(now&lt;&lt;1|1,mid+1,now_r,tag[now]); tag[now] = 0;}void modify(int now,int now_l,int now_r,int l,int r,int col){ if(l &lt;= now_l &amp;&amp; now_r &lt;= r){ update(now,now_l,now_r,col); return; } pushdown(now,now_l,now_r); int mid = (now_l + now_r)&gt;&gt;1; if(l &lt;= mid) modify(now&lt;&lt;1,now_l,mid,l,r,col); if(r &gt; mid) modify(now&lt;&lt;1|1,mid+1,now_r,l,r,col); T[now] = T[now&lt;&lt;1] + T[now&lt;&lt;1|1];}node query(int now,int now_l,int now_r,int l,int r){ if(l &lt;= now_l &amp;&amp; now_r &lt;= r) return T[now]; pushdown(now,now_l,now_r); int mid = (now_l + now_r)&gt;&gt;1; if(r &lt;= mid) return query(now&lt;&lt;1,now_l,mid,l,r); else if(l &gt; mid) return query(now&lt;&lt;1|1,mid+1,now_r,l,r); return query(now&lt;&lt;1,now_l,mid,l,r) + query(now&lt;&lt;1|1,mid+1,now_r,l,r);}int query(int x,int y){ node L,R; L.l_col = -INF; L.r_col = -INF+2; //赋成这个值就是为了避免认为初值相等，也是重边 R.l_col = -INF+3; R.r_col = -INF+4; L.sum = R.sum = 0; while(top[x] != top[y]){ if(dep[top[x]] &lt; dep[top[y]]) swap(x,y),swap(L,R); L = query(1,1,n,dfn[top[x]],dfn[x]) + L; x = fa[top[x]]; } if(dep[x] &lt; dep[y]) swap(x,y),swap(L,R); L = query(1,1,n,dfn[y],dfn[x]) + L; swap(R.l_col,R.r_col); L = R + L; return L.sum;}void modify(int x,int y,int col){ while(top[x] != top[y]){ if(dep[top[x]] &lt; dep[top[y]]) swap(x,y); modify(1,1,n,dfn[top[x]],dfn[x],col); x = fa[top[x]]; } if(dep[x] &lt; dep[y]) swap(x,y); modify(1,1,n,dfn[y],dfn[x],col);}int main(){// freopen(&quot;edge.in&quot;,&quot;r&quot;,stdin);// freopen(&quot;edge.out&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;n; i++){ int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add_edge(u,v); add_edge(v,u); } dfs1(1,0); dfs2(1,1); build(1,1,n); int col = 0; //最开始的颜色默认为 0 while(m--){ int opt,x,y;scanf(&quot;%d%d%d&quot;,&amp;opt,&amp;x,&amp;y); if(opt == 1){ modify(x,y,++col); } else{ printf(&quot;%d\\n&quot;,query(x,y)); } } cnt = 0,tot = 0; memset(head,0,sizeof(head)); } return 0;} [COCI2018-2019#1] Strah 题目描述： Mirko 最害怕的是寻找合适的土地来种植草莓。他的土地可以用一个 N×MN \\times MN×M 的矩阵来表示。土地中有些田地适合种植草莓，而有些不适合，因为那里杂草丛生。 Mirko 正在寻找一块合适矩形。当土地中有一块矩形区域包含的所有田地均适合种植草莓，则该矩形被称为合适矩形。 Mirko 还对所有田地的潜力值感兴趣。一块田地的潜力值定义为包含该田地的合适矩形的个数。 求 Mirko 所有田地的潜力值之和。 对于 100%100\\%100% 的数据，1≤N,M≤20001 \\le N,M \\le 20001≤N,M≤2000。 题目分析： 首先做一步转化：最终的答案等于所有合法矩形的面积和。 先考虑一些暴力的方法观察一下贡献。 枚举下边界 ddd，左边界 lll，右边界 rrr，设 uuu 表示符合条件的矩形的最高高度。 则答案为： (r−l+1)×∑i=1u−d+1i(r-l + 1) \\times \\sum_{i=1}^{u-d+1} i (r−l+1)×i=1∑u−d+1​i 所以想要快速维护一个想法就是不枚举左边界，要快速维护难算的只有 uuu，而可以发现如果我们直接维护一个单调栈，那么对于单调栈内相邻两个点中间的区间，其 uuu 必然是相同的，所以就很好计算了。 就是当 aaa 插入单调栈的时候，找到第一个小于它的位置，访问过的位置的 uuu 都被 aaa 所限制，其贡献形如： ∑i=1p∑j=1qi×j\\sum_{i=1}^p \\sum_{j=1}^q i \\times j i=1∑p​j=1∑q​i×j 可以拆开，就是两个等差数列求和，然后再相乘。 可是对于 aaa 插入到的位置的左边这些位置，依旧可以产生合法的矩形，但是我们如果暴力扫一遍单调栈复杂度就爆了，所以可以考虑在前面的位置打标记，当弹出前面这些位置的时候，就统计以前面这些位置为左边界，以打过标记的点为右边界的矩形面积之和。 如果两个右边界与对应的位置的距离分别为 u,vu,vu,v，那么这两个右边界在对应位置打标记之后，弹出这个位置时额外的贡献其实就是： ∑i=1p[(i+u)+(i+v)]∑j=1qj\\sum_{i=1}^p [(i+u) + (i+v)] \\sum_{j=1}^q j i=1∑p​[(i+u)+(i+v)]j=1∑q​j 这个东西也是类似于两个等差数列数列求和，再相乘，也可以快速维护。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2005;char s[N][N];int U[N][N],a[N],top,sum[N],sz[N];pair&lt;int,int&gt; st[N];int get(int l,int r){ return (l + r) * (r - l + 1) / 2;}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n,m;scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(&quot;%s&quot;,s[i]+1); for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=m; j++){ if(s[i][j] == '#') U[i][j] = 0; else U[i][j] = U[i-1][j] + 1; } } int ans = 0; for(int i=1; i&lt;=n; i++){ //枚举下边界 top = 0; st[++top] = {-1,0}; for(int j=1; j&lt;=m; j++) a[j] = U[i][j]; for(int j=1; j&lt;=m; j++){ //枚举右边界 while(top &amp;&amp; a[j] &lt;= st[top].first){ sum[top-1] += sum[top];sz[top-1] += sz[top]; if(sz[top]) ans += ((sum[top] - sz[top] * st[top].second) * (st[top].second - st[top-1].second) + get(1,st[top].second - st[top-1].second) * sz[top]) * get(1,st[top].first); --top; } ans += get(1,j - st[top].second) * get(1,a[j]); sum[top] += j,sz[top] ++; ++top;st[top] = {a[j],j};sum[top] = sz[top] = 0; } for(int j=top; j&gt;1; j--){ sum[j-1] += sum[j];sz[j-1] += sz[j]; if(sz[j]) ans += ((sum[j] - sz[j] * st[j].second) * (st[j].second - st[j-1].second) + get(1,st[j].second - st[j-1].second) * sz[j]) * get(1,st[j].first); } } printf(&quot;%lld\\n&quot;,ans); return 0;} CF1879E Interactive Game with Coloring 题目描述： 本题为交互题。 给定一棵 nnn 个点的有根树，节点 111 为根，要求你对每一条边进行染色。 交互库会有点 xxx，你可以知道点 xxx 周围连边的颜色数的情况，你可以每次选择一种颜色，使得 xxx 沿着对应颜色的边走一步，如果有多条边为所选择的颜色，则会任意选择一条边走。 设点 xxx 的深度为 ddd，则你必须在 ddd 步之内将 xxx 移动到根节点，也就是必须每一步都移动向父亲节点。 询问一种合法的染色方案，并且要求所用的颜色数最小。 你还要与交互库交互，使得 xxx 可以在 ddd 步之内移动到根节点。 题目分析： 首先我们必须在任何一个节点都可以判断出其父边是哪一条，而且父边的颜色必须不和其它的边颜色一样。 一个想法就是按对应的深度作为颜色，这样父亲边就是深度最小的那一条边，但是这样明显颜色数量过多。 可以发现我们不用将所有的深度记录下来，我们只需要记录深度模 333 就可以根据颜色判断父边了。 这样其实就是我们可以构造答案为 333 的了，那么 111 和 222 的怎么办呢。 对于答案为 111 也就是所有的边都是一种颜色，这必然要满足最深的节点的深度不超过 111，不然一步肯定走不出。 对于答案为 222 因为我们要求父边与其它连边颜色不同，所以本质就是对于节点 111 的每一棵子树分别二分图黑白染色。 可以发现的一点就是，如果一个点 xxx 的儿子个数不低于 222 个，那么其所连边中颜色数量最少的那种边就是父边，也就是这种点不会对我们黑白染色的情况产生影响。 而如果一个点 xxx 的儿子数量为 000，那么其只有父边，也不会对我们的黑白染色情况产生影响。 如果一个点 xxx 的儿子数量为 111，我们就无法根据数量和颜色来判断正确的决策是什么，就必须钦定一种决策，比如父边必须为黑边，这样就可以了，所以只有这一种边会对黑白染色产生限制。 所以可以直接根据限制倒推出来每一条边应该为什么颜色，就做完了。 这里我采取的写法就是，将所有的限制向上传递，传递到与 111 直接相连的边上，当然如果与 111 相连的这棵子树内没有限制，那么这一条边随便染一个颜色即可，这样就可以直接从 111 开始向下传递限制，就会好写很多。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1005;int n,dep[N],a[N],fa[N],deg[N],ans[N],col[N];vector&lt;int&gt; son[N];void pushup(int now,int tmp){ if(now == 1) return; col[now] = tmp; pushup(fa[now],tmp == 1 ? 2 : 1);}void pushdown(int now,int tmp){ for(auto to : son[now]){ col[to] |= (tmp == 1 ? 2 : 1); pushdown(to,col[to]); }}bool check(){ for(int i=2; i&lt;=n; i++){ if(deg[i] != 1) continue; col[i] |= 1; for(auto j : son[i]) col[j] |= 2; } for(int i=2; i&lt;=n; i++) if(col[i]) pushup(i,col[i]); for(auto i : son[1]){ if(!col[i]) col[i] = 1; } for(int i=2; i&lt;=n; i++){ pushdown(i,col[i]); } for(int i=2; i&lt;=n; i++){ if(deg[i] == 1 &amp;&amp; deg[fa[i]] == 1 &amp;&amp; (deg[fa[fa[i]]] == 1 || fa[fa[i]] == 1)) return false; if(col[i] == 3) return false; } return true;}int main(){ scanf(&quot;%d&quot;,&amp;n); int mx = 0; dep[1] = 0; for(int i=2; i&lt;=n; i++){ scanf(&quot;%d&quot;,&amp;fa[i]);deg[fa[i]]++; son[fa[i]].push_back(i); dep[i] = (dep[fa[i]] + 1) % 3; mx = max(mx,dep[fa[i]] + 1); } if(mx != 1 &amp;&amp; check()){ printf(&quot;2\\n&quot;),fflush(stdout); for(int i=2; i&lt;=n; i++) printf(&quot;%d &quot;,col[i]),fflush(stdout); while(1){ int opt;scanf(&quot;%d&quot;,&amp;opt); if(opt == 1 || opt == -1) break; int tot = 0; for(int i=1; i&lt;=2; i++) scanf(&quot;%d&quot;,&amp;a[i]),tot += a[i]; if(tot == 1){ for(int i=1; i&lt;=2; i++){ if(a[i]) printf(&quot;%d\\n&quot;,i),fflush(stdout); } } else{ if(a[1] == 1 &amp;&amp; a[2] == 1) printf(&quot;%d\\n&quot;,1),fflush(stdout); else{ if(a[1] == 1) printf(&quot;%d\\n&quot;,1),fflush(stdout); else printf(&quot;%d\\n&quot;,2),fflush(stdout); } } } return 0; } printf(&quot;%d\\n&quot;,mx),fflush(stdout); for(int i=2; i&lt;=n; i++) printf(&quot;%d &quot;,dep[fa[i]] + 1),fflush(stdout); while(1){ int opt;scanf(&quot;%d&quot;,&amp;opt); if(opt == 1 || opt == -1) break; for(int i=1; i&lt;=mx; i++) scanf(&quot;%d&quot;,&amp;a[i]); int tot = 0; for(int i=1; i&lt;=mx; i++) if(a[i] != 0) ++tot; if(tot == 1){ for(int i=1; i&lt;=mx; i++){ if(a[i]) printf(&quot;%d\\n&quot;,i),fflush(stdout); } } else{ if(a[1] &amp;&amp; a[2]) printf(&quot;1\\n&quot;),fflush(stdout); if(a[2] &amp;&amp; a[3]) printf(&quot;2\\n&quot;),fflush(stdout); if(a[3] &amp;&amp; a[1]) printf(&quot;3\\n&quot;),fflush(stdout); } fflush(stdout); } return 0;} CF1879F Last Man Standing 题目描述： 有 nnn 个人，每个人有一个血量 hih_ihi​ 和护甲值 aia_iai​。 我们可以钦定一个数 xxx 表示攻击力，攻击会进行多轮，直到所有的人 hhh 均为 000，在每一轮攻击中如果 x&lt;aix &lt; a_ix&lt;ai​，则将 aia_iai​ 减去 xxx，否则将 hih_ihi​ 减 111 并将 aia_iai​ 恢复为一开始的值。 定义一个人的得分为其独自存活的轮数，要求得出当 x∈[1,∞)x \\in [1,\\infty)x∈[1,∞) 每个人得分的最大值是多少。 多测 1≤t≤101 \\le t \\le 101≤t≤10，1≤n,hi,ai≤2⋅1051 \\le n,h_i,a_i \\le 2\\cdot 10^51≤n,hi​,ai​≤2⋅105 题目分析： 做题的第一步先看数据范围，观察到 hi,ai≤2⋅105h_i,a_i \\le 2 \\cdot 10^5hi​,ai​≤2⋅105 也就是说有用的 xxx 只需要枚举到 max⁡ai=2⋅105\\max a_i = 2\\cdot 10^5maxai​=2⋅105 即可，因为再高了就是每个人都是一刀破防，就情况相同了。 显然的一点就是如果给定 xxx，那么第 iii 个人存活的轮数就是： h×⌈aix⌉h \\times \\left\\lceil \\frac{a_i}{x} \\right\\rceil h×⌈xai​​⌉ 既然可以枚举 xxx 那么显然的想法就是用 xxx 的倍数将序列分段，这样每一段内的 ⌈aix⌉\\lceil \\frac{a_i}{x} \\rceil⌈xai​​⌉ 都相同，而我们只关心存活轮数中的最大值和次大值，所以这个东西就可以使用 ST 表快速维护。 因为 ST 表在求解的时候区间会有交集，所以如果最大值在交集的部位就可能被统计两次从而作为次大值出现，因为我们肯定在维护值的同时还会维护位置，所以直接对于最大值和次大值直接去重，然后对于剩下的寻找一下即可。 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;#define PII pair&lt;int,int&gt;using namespace std;const int N = 5e5+5;PII st1[N][20],st2[N][20],b[5];int h[N],a[N],L[N],R[N];long long ans[N];inline int read(){ int x=0,f=1;char ch=getchar(); while (ch&lt;'0'||ch&gt;'9'){if (ch=='-') f=-1;ch=getchar();} while (ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-48;ch=getchar();} return x*f;}void get(int l,int r){ int len = log2(r - l + 1); b[1] = st1[l][len],b[2] = st1[r-(1&lt;&lt;len)+1][len]; b[3] = st2[l][len],b[4] = st2[r-(1&lt;&lt;len)+1][len]; PII tmp1 = {0,0},tmp2 = {0,0}; for(int j=1; j&lt;=4; j++){ if(b[j] &gt; tmp1) swap(tmp1,tmp2),tmp1 = b[j]; else if(b[j] != tmp1 &amp;&amp; b[j] &gt; tmp2) tmp2 = b[j]; } b[1] = tmp1,b[2] = tmp2;}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;T=read(); while(T--){ int n;n=read(); for(int i=1; i&lt;=n; i++) h[i]=read(); int mx = 0; for(int i=1; i&lt;=n; i++){ a[i]=read();mx = max(mx,a[i]); if(st1[a[i]][0].first &lt; h[i]){ swap(st1[a[i]][0],st2[a[i]][0]); st1[a[i]][0] = {h[i],i}; } else if(st2[a[i]][0].first &lt; h[i]) st2[a[i]][0] = {h[i],i}; } for(int i=1; i&lt;=18; i++){ for(int j=1; j+(1&lt;&lt;i)-1 &lt;= mx + 1; j++){ b[1] = st1[j][i-1],b[2] = st1[j+(1&lt;&lt;(i-1))][i-1]; b[3] = st2[j][i-1],b[4] = st2[j+(1&lt;&lt;(i-1))][i-1]; for(int k=1; k&lt;=4; k++){ if(b[k] &gt; st1[j][i]) swap(st1[j][i],st2[j][i]),st1[j][i] = b[k]; else if(b[k] &gt; st2[j][i]) st2[j][i] = b[k]; } } } for(int x=1; x&lt;=mx+1; x++){ int tot = 0; int nl = 1,nr = x; while(nr &lt;= mx + 1){ ++tot; L[tot] = nl;R[tot] = nr; nl = nr + 1;nr = nl + x - 1; } if(R[tot] != mx + 1) ++tot,L[tot] = R[tot-1] + 1,R[tot] = mx + 1; pair&lt;long long,int&gt; ans1 = {0,0},ans2 = {0,0}; for(int i=1; i&lt;=tot; i++){ get(L[i],R[i]); for(int j=1; j&lt;=2; j++){ if(1ll * b[j].first * i &gt; ans1.first) swap(ans1,ans2),ans1 = b[j],ans1.first = 1ll * ans1.first * i; else if(1ll * b[j].first * i &gt; ans2.first) ans2 = b[j],ans2.first = 1ll * ans2.first * i; } } ans[ans1.second] = max(ans[ans1.second],ans1.first - ans2.first); } for(int i=1; i&lt;=n; i++) printf(&quot;%lld &quot;,ans[i]),ans[i] = 0; printf(&quot;\\n&quot;); for(int i=0; i&lt;=mx+1; i++){ for(int j=0; j&lt;=18; j++){ st1[i][j] = st2[i][j] = {0,0}; } } } return 0;} [COCI2018-2019#2] Sunčanje 题目描述： Slavko 做了一个不寻常的梦。在一个晴朗的早上，NNN 个白色的矩形一个接着一个爬上了 Slavko 家的屋顶，并在屋顶上晒太阳。每个矩形在屋顶都选定了一个位置，使得它的边与屋顶的棱角平行。有些矩形可能会覆盖在其它矩形所在的位置上。每个矩形的长、宽分别为 Ai,BiA_i,B_iAi​,Bi​，其与屋顶左方和下方的棱角的距离分别为 Xi,YiX_i,Y_iXi​,Yi​。 日落后，矩形们从屋顶上下来，并睡了一觉。次日，它们发现，有些矩形变成了黄色，而有些仍为白色。变为黄色的矩形都是完全暴露在阳光下的。 请判断每个矩形是否变为了黄色。 对于 100%100\\%100% 的数据，1≤N≤1051 \\le N \\le 10^51≤N≤105，0≤Xi,Yi≤1090 \\le X_i,Y_i \\le 10^90≤Xi​,Yi​≤109，1≤Ai,Bi≤1091 \\le A_i,B_i \\le 10^91≤Ai​,Bi​≤109。 题目分析： 其实就是要求对于每一个矩形，判断比它出现时间晚的矩形中有没有可以覆盖它的。 做法一： 一个想法就是直接维护矩形加矩形求和，但是这样未免太大材小用了，我们只需要判断是否存在，而不用得知具体的值。 所以我们可以使用线段树套 set，在外层线段树维护 xxx 这一维，然后使用 set 维护 x∈[l,r]x \\in [l,r]x∈[l,r] 时，哪些 yyy 被覆盖了，就是一个类似的区间染色。 然后你如果愿意打暴力的话，会发现如果你直接将 set 换成 vector 对于每一个节点暴力存所有染色的区间，然后每次查询暴力遍历每一个可能的区间，就可以获得最优解的好成绩。 做法二： 我们可以考虑容斥判断与当前矩形不交的矩形个数。 这个分讨是很简单的，就是完全在上面、下面、左面、右边的矩形个数，减去在左上角、右上角、右下角、左下角的矩形个数。 就是四遍二维偏序，四遍三维偏序，可以通过。 CF1635F Closest Pair 题目描述： 给定 n(2≤n≤3×105)n(2 \\le n \\le 3\\times 10^5)n(2≤n≤3×105) 个二元组 (xi,wi)(x_i,w_i)(xi​,wi​)，其中 ∣xi∣≤109|x_i|\\le 10^9∣xi​∣≤109，1≤wi≤1091\\le w_i \\le 10^91≤wi​≤109。 输入中二元组按照 xix_ixi​ 严格递增排序给出。 给出 q(1≤q≤3×105)q(1\\le q \\le 3\\times 10^5)q(1≤q≤3×105) 次询问，每次询问给出 l,r(1≤l&lt;r≤n)l,r(1\\le l&lt;r \\le n)l,r(1≤l&lt;r≤n)，你需要输出： min⁡l≤i&lt;j≤r∣xi−xj∣⋅(wi+wj)\\min_{l\\le i&lt;j\\le r} |x_i-x_j| \\cdot (w_i+w_j) l≤i&lt;j≤rmin​∣xi​−xj​∣⋅(wi​+wj​) 题目分析： 这东西看上去就有一种支配对的感觉，所以我们就考虑若 i&lt;j&lt;ki &lt; j &lt; ki&lt;j&lt;k，那么这个支配关系是怎么样的。 因为匹配是可以双向匹配的，但是我们可以强制让它变成单向匹配，这样显然是不劣的，也就是若 iii 匹配 jjj 则必然满足 wi≥wjw_i \\ge w_jwi​≥wj​。 如果要使得 j,kj,kj,k 均为 iii 可以匹配的数，即满足 wi≥max⁡(wj,wk)w_i \\ge \\max(w_j,w_k)wi​≥max(wj​,wk​)，考虑由匹配 jjj 变成匹配 kkk 贡献的变化，如果这个东西大于 000 则显然 (i,j)(i,j)(i,j) 更优，否则如果小于 000 看似是 (i,k)(i,k)(i,k) 更优，但是我们可以让 (j,k)(j,k)(j,k) 这样是一组比 (i,k)(i,k)(i,k) 优的答案，所以我们只需要对于每一个 iii 找到 iii 左边/右边第一个满足 wj≤wiw_j \\le w_iwj​≤wi​ 的点然后匹配即可。 这样的话对于一个询问 [l,r][l,r][l,r] 就相当于询问包含于 [l,r][l,r][l,r] 的匹配的权值的最小值，相当于一个二维偏序，按左端点从大到小排序之后，只需要满足右端点小于询问的右端点即可。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;#define int long long#define PII pair&lt;int,int&gt;using namespace std;const int N = 2e6+5;const int INF = 4e18+5;struct node{ int l,r,opt,val; node(){} node(int _l,int _r,int _opt,int _val){ l = _l,r = _r,opt = _opt,val = _val; }}a[N];int n,q,mn[N],x[N],w[N],ans[N],L[N],R[N];int calc(int l,int r){ if(x[l] &lt; x[r]) return (x[r] - x[l]) * (w[l] + w[r]); return (x[l] - x[r]) * (w[l] + w[r]);}bool cmp(node a,node b){ if(a.l != b.l) return a.l &gt; b.l; return a.opt &gt; b.opt;}int lowbit(int x){ return x &amp; (-x);}void modify(int x,int val){ for(;x &lt;= n; x += lowbit(x)) mn[x] = min(mn[x],val);}int query(int x){ int ans = INF; for(;x; x -= lowbit(x)) ans = min(ans,mn[x]); return ans;}signed main(){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;q); for(int i=1; i&lt;=n; i++) scanf(&quot;%lld%lld&quot;,&amp;x[i],&amp;w[i]); stack&lt;PII&gt; st; while(!st.empty()) st.pop(); st.push({0,0}); for(int i=1; i&lt;=n; i++){ while(!st.empty() &amp;&amp; st.top().second &gt; w[i]) st.pop(); L[i] = st.top().first;st.push(make_pair(i,w[i])); } while(!st.empty()) st.pop(); st.push({n+1,0}); for(int i=n; i&gt;=1; i--){ while(!st.empty() &amp;&amp; st.top().second &gt; w[i]) st.pop(); R[i] = st.top().first;st.push(make_pair(i,w[i])); } int tot = 0; for(int i=1; i&lt;=q; i++){ int l,r;scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r); a[++tot] = node(l,r,1,i); } for(int i=1; i&lt;=n; i++){ if(L[i]) a[++tot] = node(L[i],i,2,calc(L[i],i)); if(R[i] &lt;= n) a[++tot] = node(i,R[i],2,calc(i,R[i])); } memset(mn,0x3f,sizeof(mn)); sort(a+1,a+tot+1,cmp); for(int i=1; i&lt;=tot; i++){ if(a[i].opt == 1){ ans[a[i].val] = query(a[i].r); } else if(a[i].opt == 2){ modify(a[i].r,a[i].val); } } for(int i=1; i&lt;=q; i++) printf(&quot;%lld\\n&quot;,ans[i]); return 0;}","link":"/2023/09/27/practice-2023-9-23-9-25-26/"},{"title":"杂题选做（2023.9.28-2023.10.1）","text":"杂题选做（2023.9.28-2023.10.1） ARC106E Medals 题目描述： 你有 nnn 个朋友，他们会来你家玩，第 iii 个人 1⋯Ai1\\cdots A_i1⋯Ai​ 天来玩，然后 Ai+1⋯2AiA_i+1 \\cdots 2A_iAi​+1⋯2Ai​ 天不来，然后 2Ai+1⋯3Ai2A_i+1 \\cdots 3A_i2Ai​+1⋯3Ai​ 又会来，以此类推。 每天你会选一个来玩的人，给他颁个奖，如果没人来玩，你就不颁奖。 你要给每个人都颁 KKK 个奖，问至少需要多少天 1 ≤ N ≤ 181\\ \\le\\ N\\ \\le\\ 181 ≤ N ≤ 18 1 ≤ K ≤ 1051\\ \\le\\ K\\ \\le\\ 10^51 ≤ K ≤ 105 1 ≤ Ai ≤ 1051\\ \\le\\ A_i\\ \\le\\ 10^51 ≤ Ai​ ≤ 105 题目分析： 每天只能选择一个人，每个人需要被选择 kkk 次，有一种匹配的感觉。 可以将每一个人拆成 KKK 个点，然后每个拆出来的点都向其在的天连边，这样如果图有完美匹配那么就是合法的。 注意到一点就是我们的答案不会很大，每一个人花费 2×K2 \\times K2×K 天就可以颁奖完成。 证明可以考虑分类讨论：如果 k≤aik \\le a_ik≤ai​ 显然成立，如果 k&gt;aik &gt; a_ik&gt;ai​，则我们可以用第三轮的去补第一轮不够的，时间也是满足条件的。 所以做法就是考虑二分答案，然后建图，判断图是否有完美匹配。 但是如果我们直接建边的话复杂度就肯定爆了，可以考虑使用霍尔定理判断是否合法。 霍尔定理即：若一个二分图有完美匹配，当且仅当对于任意一个左部点的点集 SSS，设与其相连的右部点的点集为 TTT，满足 ∣S∣≤∣T∣|S| \\le |T|∣S∣≤∣T∣。 因为每一个人拆成的 KKK 个点可以视为一体，所以在枚举左部点的点集的时候就可以做到 2N2^N2N 的复杂度。 判断与其相邻的右部点的点集大小，可以考虑对于每一个时刻找出 SiS_iSi​ 表示 SiS_iSi​ 这些人可以在时刻 iii 到达，这样的话第 iii 天若与集合 TTT 里的某些人有连边，当且仅当 SiS_iSi​ 与 TTT 交集不为空。 但是交集不为空这个东西就很难以表示，所以就容斥一下，可以考虑维护 TiT_iTi​ 表示 TiT_iTi​ 这些人不可以在时刻 iii 到达，这样对于不可以到达的集合就是 TiT_iTi​ 的所有子集，贡献可以使用高维后缀和维护。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+5;int n,k,S[40 * N],f[N],a[N];bool chk(int mid){ for(int i=0; i&lt;(1&lt;&lt;n); i++) f[i] = 0; for(int i=1; i&lt;=mid; i++) f[((1&lt;&lt;n)-1) ^ S[i]]++; for(int i=1; i&lt;=n; i++){ for(int j=0; j&lt;(1&lt;&lt;n); j++){ if(!((j &gt;&gt; (i-1)) &amp; 1)) f[j] += f[j^(1&lt;&lt;(i-1))]; } } for(int i=0; i&lt;(1&lt;&lt;n); i++){ if(mid - f[i &lt; __builtin_popcount(i) * k) return false; } return true;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=2*n*k; i++){ for(int j=1; j&lt;=n; j++){ if(((i + a[j] - 1) / a[j]) % 2 == 1) S[i] |= (1&lt;&lt;(j-1)); } } int l = 1,r = 2 * n * k,ans = 1; while(l &lt;= r){ int mid = (l + r) &gt;&gt; 1; if(chk(mid)) ans = mid,r = mid - 1; else l = mid + 1; } printf(&quot;%d\\n&quot;,ans); return 0;} [POI2007] ZAP-Queries 题目描述： 密码学家正在尝试破解一种叫 BSA 的密码。 他发现，在破解一条消息的同时，他还需要回答这样一种问题： 给出 a,b,da,b,da,b,d，求满足 1≤x≤a1 \\leq x \\leq a1≤x≤a，1≤y≤b1 \\leq y \\leq b1≤y≤b，且 gcd⁡(x,y)=d\\gcd(x,y)=dgcd(x,y)=d 的二元组 (x,y)(x,y)(x,y) 的数量。 因为要解决的问题实在太多了，他便过来寻求你的帮助。 对于全部的测试点，保证 1≤n≤5×1041 \\leq n \\leq 5 \\times 10^41≤n≤5×104，1≤d≤a,b≤5×1041 \\leq d \\leq a,b \\leq 5 \\times 10^41≤d≤a,b≤5×104。 题目分析： （一道莫反的板子题） 话不多说，考虑推式子： ans=∑x=1n∑y=1m[gcd⁡(x,y)=d]=∑x=1⌊nd⌋∑y=1⌊md⌋[gcd⁡(x,y)=1]=∑k=1⌊min⁡(a,b)d⌋μ(k)∑x=1⌊ndk⌋∑y=1⌊mdk⌋1=∑k=1⌊min⁡(a,b)d⌋μ(k)⌊ndk⌋⌊mdk⌋\\begin{aligned} ans &amp;= \\sum_{x=1}^n \\sum_{y=1}^m [\\gcd(x,y)=d] \\\\ &amp;= \\sum_{x=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{y=1}^{\\lfloor \\frac{m}{d} \\rfloor} [\\gcd(x,y) = 1] \\\\ &amp;= \\sum_{k=1}^{\\lfloor \\frac{\\min(a,b)}{d} \\rfloor} \\mu(k) \\sum_{x=1}^{\\lfloor \\frac{n}{dk} \\rfloor} \\sum_{y=1}^{\\lfloor \\frac{m}{dk} \\rfloor} 1 \\\\ &amp;= \\sum_{k=1}^{\\lfloor \\frac{\\min(a,b)}{d} \\rfloor} \\mu(k) \\lfloor \\frac{n}{dk} \\rfloor \\lfloor \\frac{m}{dk} \\rfloor \\end{aligned} ans​=x=1∑n​y=1∑m​[gcd(x,y)=d]=x=1∑⌊dn​⌋​y=1∑⌊dm​⌋​[gcd(x,y)=1]=k=1∑⌊dmin(a,b)​⌋​μ(k)x=1∑⌊dkn​⌋​y=1∑⌊dkm​⌋​1=k=1∑⌊dmin(a,b)​⌋​μ(k)⌊dkn​⌋⌊dkm​⌋​ 对最后的这个式子直接整除分块，使用线性筛预处理 μ\\muμ 的前缀和。 设所有数均同阶，则复杂度为 O(nn)O(n\\sqrt{n})O(nn​) 代码： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;int mu[N],prime[N],s[N],tot;bool flag[N];void pre_work(int n){ mu[1] = 1; for(int i=2; i&lt;=n; i++){ if(!flag[i]){ prime[++tot] = i; mu[i] = -1; } for(int j=1; j&lt;=tot &amp;&amp; i * prime[j] &lt;= n; j++){ flag[i * prime[j]] = true; if(i % prime[j] == 0){ mu[i * prime[j]] = 0; break; } else mu[i * prime[j]] = -mu[i]; } } for(int i=1; i&lt;=n; i++) s[i] = s[i-1] + mu[i];}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); pre_work(50000); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int a,b,k;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;k); a /= k,b /= k; int ans = 0; for(int l=1,r=0; l&lt;=min(a,b); l = r + 1){ r = min(a/(a/l),b/(b/l)); ans += (s[r] - s[l-1]) * (a/l) * (b/l); } printf(&quot;%d\\n&quot;,ans); } return 0;} AGC038C LCMs 题目描述： 给定一个长度为 NNN 的数列 A1,A2,A3,…,ANA_1, A_2, A_3, \\ldots, A_NA1​,A2​,A3​,…,AN​。 请你求出 ∑i=1N∑j=i+1Nlcm(Ai,Aj)\\sum_{i=1}^{N}\\sum_{j=i+1}^{N}\\mathrm{lcm}(A_i,A_j)∑i=1N​∑j=i+1N​lcm(Ai​,Aj​) 的值模 998244353998244353998244353 的结果。 1≤N≤2×1051 \\leq N \\leq 2 \\times 10^51≤N≤2×105，1≤Ai≤1061 \\leq A_i \\leq 10^61≤Ai​≤106。 1 ≤ N ≤ 2⋅1041\\ \\leq\\ N\\ \\leq\\ 2\\cdot 10^41 ≤ N ≤ 2⋅104 1 ≤ Ai ≤ 1⋅1061\\ \\leq\\ A_i\\ \\leq\\ 1\\cdot 10^61 ≤ Ai​ ≤ 1⋅106 题目分析： 显然要使用莫比乌斯反演来解决这个问题。 首先因为 jjj 的下界为 i+1i+1i+1 就很烦人，可以考虑将式子化成以下的形式： ∑i=1n∑j=1nlcm(Ai,Aj)−∑i=1nlcm(Ai,Ai)2\\frac{\\sum \\limits_{i=1}^n \\sum \\limits_{j=1}^n \\textup{lcm}(A_i,A_j) - \\sum \\limits_{i=1}^n \\textup{lcm}(A_i,A_i)}{2} 2i=1∑n​j=1∑n​lcm(Ai​,Aj​)−i=1∑n​lcm(Ai​,Ai​)​ 下面我们的问题就显然是求前面这一坨，因为我们直接对下标做就很麻烦，所以考虑对于值域套莫反，也就是设 bib_ibi​ 表示值为 iii 的数的个数，则有： ans=∑i=1V∑j=1Vbi×bj×i×jgcd⁡(i,j)=∑d=1V∑i=1⌊Vd⌋∑j=1⌊Vd⌋[gcd⁡(i,j)=1]1dbid×bjd×id×jd=∑d=1V1d∑k=1⌊Vd⌋μ(k)∑i=1⌊Vdk⌋∑j=1⌊Vdk⌋bikd×bjkd×ikd×jkd=∑d=1Vd∑k=1⌊Vd⌋k2μ(k)∑i=1⌊Vdk⌋∑j=1⌊Vdk⌋bikd×bjkd×i×j\\begin{aligned} ans &amp;= \\sum_{i=1}^V \\sum_{j=1}^V b_i \\times b_j \\times \\frac{i \\times j}{\\gcd(i,j)} \\\\ &amp;= \\sum_{d=1}^V \\sum_{i=1}^{\\lfloor \\frac{V}{d} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{V}{d} \\rfloor} [\\gcd(i,j)=1] \\frac{1}{d} b_{id} \\times b_{jd} \\times id \\times jd \\\\ &amp;= \\sum_{d=1}^V \\frac{1}{d} \\sum_{k=1}^{\\lfloor \\frac{V}{d} \\rfloor} \\mu(k) \\sum_{i=1}^{\\lfloor \\frac{V}{dk} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{V}{dk} \\rfloor} b_{ikd} \\times b_{jkd} \\times ikd \\times jkd \\\\ &amp;= \\sum_{d=1}^V d \\sum_{k=1}^{\\lfloor \\frac{V}{d} \\rfloor} k^2\\mu(k) \\sum_{i=1}^{\\lfloor \\frac{V}{dk} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{V}{dk} \\rfloor} b_{ikd} \\times b_{jkd} \\times i \\times j \\end{aligned} ans​=i=1∑V​j=1∑V​bi​×bj​×gcd(i,j)i×j​=d=1∑V​i=1∑⌊dV​⌋​j=1∑⌊dV​⌋​[gcd(i,j)=1]d1​bid​×bjd​×id×jd=d=1∑V​d1​k=1∑⌊dV​⌋​μ(k)i=1∑⌊dkV​⌋​j=1∑⌊dkV​⌋​bikd​×bjkd​×ikd×jkd=d=1∑V​dk=1∑⌊dV​⌋​k2μ(k)i=1∑⌊dkV​⌋​j=1∑⌊dkV​⌋​bikd​×bjkd​×i×j​ 可以考虑令 T=dkT = dkT=dk，则有： ans=∑T=1VT∑d∣TTdμ(Td)(∑i=1⌊VT⌋biT×i)2\\begin{aligned} ans &amp;= \\sum_{T=1}^V T \\sum_{d | T} \\frac{T}{d}\\mu(\\frac{T}{d}) (\\sum_{i=1}^{\\lfloor \\frac{V}{T} \\rfloor} b_{iT} \\times i)^2 \\end{aligned} ans​=T=1∑V​Td∣T∑​dT​μ(dT​)(i=1∑⌊TV​⌋​biT​×i)2​ 这样的话对于：∑d∣TTdμ(Td)\\sum_{d|T} \\frac{T}{d} \\mu(\\frac{T}{d})∑d∣T​dT​μ(dT​) 可以预处理 μ\\muμ 后类似埃氏筛对于每一个 TTT 处理出这一些的贡献，复杂度 O(Vlog⁡V)O(V \\log V)O(VlogV) 对于 ∑i=1⌊VT⌋biT×i\\sum_{i=1}^{\\lfloor \\frac{V}{T} \\rfloor} b_{iT} \\times i∑i=1⌊TV​⌋​biT​×i 可以直接枚举 iii 然后计算答案，复杂度是一个调和级数的，也为 O(Vlog⁡V)O(V \\log V)O(VlogV)。 所以总时间复杂度就是 O(Vlog⁡V)O(V \\log V)O(VlogV) 可以通过。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2e6+5;const int MOD = 998244353;int tot,a[N],b[N],prime[N],mu[N],f[N];bool flag[N];void add(int &amp;a,int b){ a = ((a + b)%MOD+MOD)%MOD;}int power(int a,int b){ int res = 1; while(b){ if(b &amp; 1) res = res * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; } return res;}void pre_work(int n){ mu[1] = 1; for(int i=2; i&lt;=n; i++){ if(!flag[i]){ prime[++tot] = i; mu[i] = -1; } for(int j=1; j&lt;=tot &amp;&amp; i * prime[j] &lt;= n; j++){ flag[i * prime[j]] = true; if(i % prime[j] == 0){ mu[i * prime[j]] = 0; break; } else mu[i * prime[j]] = -mu[i]; } } for(int i=1; i&lt;=n; i++){ for(int j=i; j&lt;=n; j+=i){ add(f[j],mu[i] * i % MOD); } }}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); pre_work(1000000); int n;scanf(&quot;%lld&quot;,&amp;n); for(int i=1; i&lt;=n; i++){ scanf(&quot;%lld&quot;,&amp;a[i]); b[a[i]]++; } int ans = 0; int V = 1e6; for(int T=1; T&lt;=V; T++){ int tmp = 0; for(int i=1; i&lt;=V/T; i++) tmp = (tmp + b[i * T] * i % MOD)%MOD; tmp = tmp * tmp % MOD; ans = ((ans + f[T] * T %MOD * tmp%MOD)%MOD+MOD)%MOD; } for(int i=1; i&lt;=n; i++) ans = ((ans - a[i])%MOD + MOD)%MOD; printf(&quot;%lld\\n&quot;,ans * power(2,MOD-2) % MOD); return 0;} [SDOI2014] 数表 题目描述： 有一张 n×mn\\times mn×m 的数表，其第 iii 行第 jjj 列（1≤i≤n1\\le i\\le n1≤i≤n，1≤j≤m1\\le j\\le m1≤j≤m）的数值为能同时整除 iii 和 jjj 的所有自然数之和。给定 aaa，计算数表中不大于 aaa 的数之和。 对于全部数据，1≤n,m≤1051\\le n,m\\le 10^51≤n,m≤105，1≤Q≤2×1041\\le Q\\le 2\\times 10^41≤Q≤2×104。 题目分析： 这个东西直觉上是莫反，但是有一个小于等于 aaa 的限制就很烦人，考虑先不管这个限制，看看莫反推出来的是什么。 下文推导默认 n&lt;mn &lt; mn&lt;m，如果不是则交换 n,mn,mn,m 就可以做到。 ans=∑i=1n∑j=1mσ1(gcd⁡(i,j))=∑d=1n∑i=1⌊nd⌋∑j=1⌊md⌋[gcd⁡(i,j)=1]σ1(d)=∑d=1nσ1(d)∑k=1⌊nd⌋μ(k)⌊ndk⌋⌊mdk⌋\\begin{aligned} ans &amp;=\\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1(\\gcd(i,j)) \\\\ &amp;= \\sum_{d=1}^n \\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{d} \\rfloor} [\\gcd(i,j)=1] \\sigma_1(d) \\\\ &amp;= \\sum_{d=1}^n \\sigma_1(d) \\sum_{k=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\mu(k) \\lfloor \\frac{n}{dk} \\rfloor \\lfloor \\frac{m}{dk} \\rfloor \\end{aligned} ans​=i=1∑n​j=1∑m​σ1​(gcd(i,j))=d=1∑n​i=1∑⌊dn​⌋​j=1∑⌊dm​⌋​[gcd(i,j)=1]σ1​(d)=d=1∑n​σ1​(d)k=1∑⌊dn​⌋​μ(k)⌊dkn​⌋⌊dkm​⌋​ 可以考虑设 T=dkT = dkT=dk，则有： ans=∑T=1n⌊nT⌋⌊mT⌋∑d∣Tσ1(d)μ(Td)\\begin{aligned} ans &amp;= \\sum_{T=1}^n \\lfloor \\frac{n}{T} \\rfloor \\lfloor \\frac{m}{T} \\rfloor \\sum_{d \\mid T} \\sigma_1(d) \\mu(\\frac{T}{d}) \\end{aligned} ans​=T=1∑n​⌊Tn​⌋⌊Tm​⌋d∣T∑​σ1​(d)μ(dT​)​ 如果我们可以维护好后面这一坨的值我们就可以直接整除分块。 可以考虑离线，将询问按照 aaa 的大小从小到大排序，并将 σ1(d)\\sigma_1(d)σ1​(d) 从小到大排序，然后一个个地插入符合条件的 σ1(d)\\sigma_1(d)σ1​(d)，具体来说就是如果此时 σ1(d)≤a\\sigma_1(d) \\le aσ1​(d)≤a，那么就可以直接枚举 ddd 的所有倍数 TTT，然后将 σ1(d)μ(Td)\\sigma_1(d) \\mu(\\frac{T}{d})σ1​(d)μ(dT​) 贡献到 TTT 的后面这个式子上，因为整除分块必定要支持区间查询后面这个式子的值的和，所以可以考虑使用树状数组维护。 复杂度 O(qnlog⁡n+nlog⁡2n)O(q \\sqrt{n} \\log n + n \\log^2 n)O(qn​logn+nlog2n)，可以通过。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define int long long#define PII pair&lt;int,int&gt;using namespace std;const int N = 2e5+5;const int MOD = 1ll&lt;&lt;31;struct node{ int n,m,a,id;}p[N];int prime[N],tot,ans[N],sum[N],mu[N];bool flag[N];PII w[N];void pre_work(int n){ mu[1] = 1; for(int i=2; i&lt;=n; i++){ if(!flag[i]){ prime[++tot] = i; mu[i] = -1; } for(int j=1; j&lt;=tot &amp;&amp; i * prime[j] &lt;= n; j++){ flag[i * prime[j]] = true; if(i % prime[j] == 0){ mu[i * prime[j]] = 0; break; } else mu[i * prime[j]] = -mu[i]; } } for(int i=1; i&lt;=n; i++){ w[i].second = i; for(int j=i; j&lt;=n; j+=i){ w[j].first += i; } }}bool cmp(node a,node b){ return a.a &lt; b.a;}bool cmp2(PII a,PII b){ return a.first &lt; b.first;}int lowbit(int x){ return x &amp; (-x);}void modify(int x,int val){// printf(&quot;(%d,%d)\\n&quot;,x,val); for(;x &lt;= 100000; x+=lowbit(x)) sum[x] += val;}int query(int x){// printf(&quot;%d\\n&quot;,x); int ans = 0; for(;x; x -= lowbit(x)) ans += sum[x]; return ans;}int query(int l,int r){ return query(r) - query(l-1);}signed main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); pre_work(100000); sort(w+1,w+100000+1,cmp2); int now = 1; int q;scanf(&quot;%lld&quot;,&amp;q); for(int i=1; i&lt;=q; i++) scanf(&quot;%lld%lld%lld&quot;,&amp;p[i].n,&amp;p[i].m,&amp;p[i].a),p[i].id = i; sort(p+1,p+q+1,cmp); for(int i=1; i&lt;=q; i++){ while(now &lt;= 100000 &amp;&amp; w[now].first &lt;= p[i].a){ int tmp = w[now].second; for(int j=tmp; j&lt;=100000; j+=tmp){ modify(j,w[now].first * mu[j/tmp]); } ++now; } if(p[i].n &gt; p[i].m) swap(p[i].n,p[i].m); int n = p[i].n,m = p[i].m; for(int l=1,r=0; l&lt;=n; l=r+1){ r = min(n/(n/l),m/(m/l)); ans[p[i].id] = (ans[p[i].id] + (n/l) * (m/l) * query(l,r));// printf(&quot;%lld\\n&quot;,ans[p[i].id]); } } for(int i=1; i&lt;=q; i++) printf(&quot;%lld\\n&quot;,(ans[i] + MOD)%MOD); return 0;} CF1010D Mars rover 题目描述： 给定一棵有根树，令根节点为 111，有 nnn 个节点。 每个节点有五种形式：AND 表示对两个子节点进行与运算，OR 表示对两个子节点进行或运算，XOR 表示对两个子节点进行异或运算，NOT 表示对子节点（只有一个）进行非运算。特殊地，IN 表示这个节点是叶子节点，它的初值（0/10/10/1）由读入决定。 现在，你要依次对每个叶子节点进行改变，改变其 0/10/10/1 状态，并按叶节点编号顺序，分别输出改变叶节点的状态后，根节点的值是 000 还是 111。 2≤n≤1062 \\le n \\le 10^62≤n≤106 题目分析： 若当前节点为 XOR 或 NOT，则叶子节点只要改变当前节点的值必然改变。 若当前节点为 AND，则只有两个叶子节点同时为 111 时改变其中一个，或者为 0,10,10,1 改变那个 000 才会改变当前节点的值。 若当前节点为 OR，则只有两个叶子节点同时为 000 时改变其中一个，或者为 0,10,10,1 改变那个 111 才会改变当前节点的值。 如果改变节点 xxx 的值会使得 111 节点的值改变，也就是 xxx 到 111 路径上的每一个节点都必然是上述几种情况之一。 可以按照是否合法的情况从上到下传递标记，也就是对于每一个节点维护 fif_ifi​ 表示节点 iii 改变是否会影响到根节点。 具体实现就是先从下到上 dfs 获得每一个节点的值，然后从上到达 dfs 得到 fif_ifi​ 的值。 时间复杂度 O(n)O(n)O(n)。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e6+5;int ls[N],rs[N],val[N],opt[N];char s[N];bool flag[N];void dfs1(int now){ if(ls[now]) dfs1(ls[now]); if(rs[now]) dfs1(rs[now]); if(opt[now] == 1) val[now] = val[ls[now]] &amp; val[rs[now]]; if(opt[now] == 2) val[now] = val[ls[now]] | val[rs[now]]; if(opt[now] == 3) val[now] = val[ls[now]] ^ val[rs[now]]; if(opt[now] == 4) val[now] = val[ls[now]] ^ 1;}void dfs2(int now){ flag[now] = true; if(opt[now] == 1){ if(val[ls[now]] == 1 &amp;&amp; val[rs[now]] == 1) dfs2(ls[now]),dfs2(rs[now]); if(val[ls[now]] == 0 &amp;&amp; val[rs[now]] == 1) dfs2(ls[now]); if(val[ls[now]] == 1 &amp;&amp; val[rs[now]] == 0) dfs2(rs[now]); } if(opt[now] == 2){ if(val[ls[now]] == 0 &amp;&amp; val[rs[now]] == 0) dfs2(ls[now]),dfs2(rs[now]); if(val[ls[now]] == 0 &amp;&amp; val[rs[now]] == 1) dfs2(rs[now]); if(val[ls[now]] == 1 &amp;&amp; val[rs[now]] == 0) dfs2(ls[now]); } if(opt[now] == 3) dfs2(ls[now]),dfs2(rs[now]); if(opt[now] == 4) dfs2(ls[now]);}int main(){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++){ scanf(&quot;%s&quot;,s+1); if(s[1] == 'A'){ opt[i] = 1; scanf(&quot;%d%d&quot;,&amp;ls[i],&amp;rs[i]); } else if(s[1] == 'O'){ opt[i] = 2; scanf(&quot;%d%d&quot;,&amp;ls[i],&amp;rs[i]); } else if(s[1] == 'X'){ opt[i] = 3; scanf(&quot;%d%d&quot;,&amp;ls[i],&amp;rs[i]); } else if(s[1] == 'N'){ opt[i] = 4; scanf(&quot;%d&quot;,&amp;ls[i]); } else if(s[1] == 'I'){ opt[i] = 5;scanf(&quot;%d&quot;,&amp;val[i]); } } dfs1(1); dfs2(1); for(int i=1; i&lt;=n; i++){ if(opt[i] == 5){ if(flag[i]) printf(&quot;%d&quot;,val[1] ^ 1); else printf(&quot;%d&quot;,val[1]); } } return 0;} CF117C Cycle 题目描述： 一个 tournament\\texttt{tournament}tournament 是一个没有自环的有向图，同时，任意两个点之间有一条边连接。这就是说，对于两个点 u,v(u≠v)u,v (u\\neq v)u,v(u=v)，有一条从 uuu 到 vvv 的边或一条从 vvv 到 uuu 的边。 给你一个 tournament\\texttt{tournament}tournament，请找出一个长度为 333 的环。 1≤n≤50001 \\le n \\le 50001≤n≤5000 题目分析： 注意到这是一张竞赛图，也就是说若存在环则必然存在三元环。 这个结论可以通过数学归纳法证明，可以自行画图证明。 所以可以直接跑一遍 dfsdfsdfs，每次判断点 uuu，点 uuu 的父亲 faufa_ufau​，出点 vvv 是否构成三元环即可。 因为我们访问过一个点之后就没有必要再访问一次，所以时间复杂度为 O(n+m)O(n+m)O(n+m)。 题目描述： 点击查看代码 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5005;int n,sz = -1,a[N];char G[N][N];bool flag = false,vis[N],tag[N];bool chk(int a,int b,int c){ if(G[a][b] == '1' &amp;&amp; G[b][c] == '1' &amp;&amp; G[c][a] == '1') return true; return false;}void dfs(int now,int fath){ if(flag) return; vis[now] = tag[now] = true; for(int i=1; i&lt;=n; i++){ if(G[now][i] == '0') continue; if(!tag[i]) dfs(i,now); else if(vis[i]){ printf(&quot;%d %d %d\\n&quot;,now,i,fath); flag = true; } if(flag) return; } vis[now] = false;}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%s&quot;,G[i]+1); for(int i=1; i&lt;=n; i++) if(!tag[i]) dfs(i,0); if(!flag) printf(&quot;-1\\n&quot;); return 0;} CF303B Rectangle Puzzle II 题目描述： 在 (0,0)∼(n,m)(0, 0) \\sim (n, m)(0,0)∼(n,m) 中找一个最大子矩形，使其包含定点 (x,y)(x, y)(x,y)，而且 x2−x1y2−y1=ab\\frac{x_2 - x_1}{y_2 - y_1} = \\frac{a}{b}y2​−y1​x2​−x1​​=ba​。如果有多个解，输出最接近 (x,y)(x, y)(x,y) 的矩形。如果仍有多个解决方案，按 (x1,y1,x2,y2)(x_1,y_1,x_2,y_2)(x1​,y1​,x2​,y2​) 顺序排列的字典序最小解决方案。 题目分析： 首先可以将 a,ba,ba,b 同时除以 gcd⁡(a,b)\\gcd(a,b)gcd(a,b)，这样一个满足条件的矩形的边长必然为 (a,b)(a,b)(a,b) 的倍数。 设为 ttt 倍，则显然最大的子矩形满足 t=min⁡(⌊na⌋,⌊mb⌋)t = \\min(\\lfloor \\frac{n}{a} \\rfloor,\\lfloor \\frac{m}{b} \\rfloor)t=min(⌊an​⌋,⌊bm​⌋) 所以为了让中心点尽可能靠近 (x,y)(x,y)(x,y) 我们可以使用扩展的想法。 也就是每次从 (x,y)(x,y)(x,y) 分别向左右/上下扩展 111，这样就可以保证 (x,y)(x,y)(x,y) 在中心点上。 有可能存在边长为奇数的情况，这种情况为了使得排列的字典序最小，要尽可能地先扩展 x1,y1x_1,y_1x1​,y1​。 因为必然有解，所以如果某一边不能扩展了，那么就把剩下的边长放到另一边即可。 因为注意到横纵坐标的处理方式相同，所以可以直接写一个函数分别处理即可。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define PII pair&lt;int,int&gt;using namespace std;int n,m,x,y,a,b;PII get(int x,int a,int n){ int x1 = 0,x2 = 0; if(x - (a/2) &gt;= 0 &amp;&amp; x + (a / 2) &lt;= n){ x1 = x - (a / 2); x2 = x + (a / 2); if(a % 2 == 1){ if(x1 != 0) x1--; else x2++; } } else{ if(x - (a / 2) &lt; 0) x1 = 0,a -= x,x2 = x + a; else if(x + (a / 2) &gt; n) x2 = n,a -= (n - x),x1 = x - a; } return {x1,x2};}int main(){ scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;m,&amp;x,&amp;y,&amp;a,&amp;b); int g = __gcd(a,b);a /= g,b /= g; //分横竖分别做，情况本质相同 int tmp = min(n/a,m/b); PII X = get(x,tmp * a,n); PII Y = get(y,tmp * b,m); printf(&quot;%d %d %d %d\\n&quot;,X.first,Y.first,X.second,Y.second); return 0;} CF1874C Jellyfish and EVA 题目描述： 怪物们又入侵了小镇！明日香邀请好友水母一起驾驶 EVA。 小镇上有 nnn 座城市。所有的怪兽都在 nnn 城市。水母和明日香目前在城市 111，需要前往城市 nnn 打败怪兽。 这里有 mmm 条路。其中第 iii 条路可以从城市 aia_iai​ 前往城市 bib_ibi​。所有道路都是有向的。也就是说，使用第 iii 号道路无法从 bib_ibi​ 号城市前往 aia_iai​ 号城市。有趣的是，所有道路都满足ai&lt;bia_i &lt; b_iai​&lt;bi​。 驾驶 EVA 需要两人合作。然而，明日香和水母之前并没有一起接受过任何训练。 假设 EVA 目前在城市 uuu。水母和明日香都会选择一条从城市 uuu 开始的未被破坏的道路。假设水母和明日香分别选择了以城市 v1v_1v1​ 和 v2v_2v2​ 为终点的道路。如果 v1=v2v_1 = v_2v1​=v2​，EVA成功移动到城市 v1v_1v1​。否则，EVA 会停留在城市 uuu，并且他们选择的两条道路都会被摧毁。 EVA 目前可能在城市 uuu （u≠nu \\neq nu=n）中，而从城市 uuu 开始没有未被摧毁的道路，在这种情况下，任务将会失败。否则，如果最终到达城市 nnn，则任务成功。 每次选择道路时，水母都知道明日香会随机选择一条道路。现在，水母想知道，如果她最优化地选择道路，任务成功的最大概率是多少。 2≤n≤50002 \\le n \\le 50002≤n≤5000，0≤m≤min⁡(2⋅105,n(n−1)2)0 \\le m \\le \\min(2 \\cdot 10^5,\\frac{n(n-1)}{2})0≤m≤min(2⋅105,2n(n−1)​) 题目分析： 一个显然的想法就是要预处理出来 f[i]f[i]f[i] 表示从 iii 开始最大成功率是多少。 显然对于一条边我们越早选择其成功走过去的概率越大，所以若当前枚举到了点 iii，对于其出点我们就可以按照 fff 从大到小选择。 所以我们现在其实就是要求求解：dp[i][j]dp[i][j]dp[i][j] 表示有 iii 条出边，最终成功选择了按 fff 排序后的第 jjj 大的概率，有了这个东西我们的 fff 就很好转移了。 首先无论我们最终选择了什么，按照上文的策略，我们此时选择的边必然是按 fff 排序后第 111 大的。 所以要对 dp[i][1]dp[i][1]dp[i][1] 转移特殊考虑。 对于其他的转移，就是考虑当前随机选择了哪一条边，然后算一下概率即可。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5005;vector&lt;int&gt; G[N],IG[N];int n,deg[N];double f[N],dp[N][N];bool cmp(int a,int b){ return f[a] &gt; f[b];}void get_ans(){ f[n] = 1; queue&lt;int&gt; q; for(int i=1; i&lt;=n; i++){ if(!deg[i]) q.push(i); } while(!q.empty()){ int now = q.front();q.pop(); sort(G[now].begin(),G[now].end(),cmp); for(int i=0; i&lt;(int)G[now].size(); i++){ int to = G[now][i]; f[now] += 1.0 * dp[G[now].size()][i+1] * f[to]; } for(auto to : IG[now]){ deg[to]--; if(!deg[to]) q.push(to); } }}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++){ int from,to;scanf(&quot;%d%d&quot;,&amp;from,&amp;to); G[from].push_back(to); IG[to].push_back(from);deg[from]++; } dp[1][1] = 1; for(int i=2; i&lt;=n; i++){ //选择到了 1；没有选择到 1 dp[i][1] += 1.0 / i + 1.0 * (i-1) / i * 0; for(int j=2; j&lt;=i; j++){ //j 之前，但是选择到了 1 dp[i][j] += 1.0 / i * 0; //j 之前，且没有选择到 1 dp[i][j] += 1.0 * (j-2) / i * dp[i-2][j-2]; //选择到了 j dp[i][j] += 1.0 / i * 0; //j 之后 dp[i][j] += 1.0 * (i-j) / i * dp[i-2][j-1]; }// for(int j=1; j&lt;=i; j++){// printf(&quot;dp[%d][%d] = %.5f\\n&quot;,i,j,dp[i][j]);// } } get_ans(); printf(&quot;%.9f\\n&quot;,f[1]); for(int i=0; i&lt;=n; i++){ f[i] = 0;deg[i] = 0;G[i].clear();IG[i].clear(); for(int j=0; j&lt;=n; j++){ dp[i][j] = 0; } } } return 0;} CF710F String Set Queries 题目描述： 维护一个字符串集合，支持三种操作： 加字符串 删字符串 查询集合中的所有字符串在给出的模板串中出现的次数 操作数 m≤3×105m \\leq 3 \\times 10^5m≤3×105，输入字符串总长度 ∑∣si∣≤3×105\\sum |s_i| \\leq 3\\times 10^5∑∣si​∣≤3×105。 本题强制在线，应该在每次输出后调用fflush(stdout)。你只有在输出上一个询问的答案后才能读入下一组询问。 题目分析： 这里写一种很让人震撼的做法。 考虑根号分治，先设置一个阈值 BBB，若插入的字符串长度小于等于 BBB 则我们将这个字符串插入到 Trie 树中，否则就先放到一边不管。 若现在有一个查询操作。 对于长度小于等于 BBB 的串，我们可以暴力枚举这个字符串的后缀，然后把这个后缀放到 Trie 树上匹配，因为 Trie 树的深度最多为 BBB，所以这个部分的复杂度为 O(B∣S∣)O(B|S|)O(B∣S∣)。 对于长度大于 BBB 的串，因为串最多有 ∣S∣B\\frac{|S|}{B}B∣S∣​ 个，所以可以考虑暴力做 KMP 算法，复杂度 O(∣S∣2B)O(\\frac{|S|^2}{B})O(B∣S∣2​)。 若取 B=∣S∣B = \\sqrt{|S|}B=∣S∣​，则时间复杂度就为 O(∣S∣∣S∣)O(|S|\\sqrt{|S|})O(∣S∣∣S∣​)。 代码： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5+5;struct trie{ int ch[N][27],val[N]; int rt = 1,tot = 1; void insert(string s,int p){ int now = rt; for(int i=0; i&lt;(int)s.size(); i++){ if(!ch[now][s[i]-'a']) ch[now][s[i]-'a'] = ++tot; now = ch[now][s[i]-'a']; } val[now] += p; } int find(char *s,int len){ int now = rt,ans = val[now]; for(int i=0; i&lt;len; i++){ if(!ch[now][s[i]-'a']) break; now = ch[now][s[i]-'a']; ans += val[now]; } return ans; }}Trie;int nxt[N],sz;char s[N];string v[N];int g[N];int search(string S,string T){ //查询 S 在 T 中的出现次数 S = 'a' + S; //这样的话下标就从 1 开始了 T = 'a' + T; int n = S.size(),m = T.size(); int ans = 0; nxt[1] = 0; for(int i=2,j=0; i&lt;n; i++){ while(j &amp;&amp; S[i] != S[j+1]) j = nxt[j]; if(S[j+1] == S[i]) ++j; nxt[i] = j; } for(int i=1,j=0; i&lt;m; i++){ while(j &amp;&amp; S[j+1] != T[i]) j = nxt[j]; if(S[j+1] == T[i]) ++j; if(j == n-1){ j = nxt[j]; ++ans; } } return ans;}int main(){// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int m;scanf(&quot;%d&quot;,&amp;m); while(m--){ string S = &quot;&quot;; int t;scanf(&quot;%d&quot;,&amp;t);cin&gt;&gt;S; int len = S.size(); for(int i=0; i&lt;len; i++) s[i+1] = S[i]; if(t == 1 || t == 2){ if(len &lt;= 1000) Trie.insert(S,t == 1 ? 1 : -1); else v[++sz] = S,g[sz] = (t == 1 ? 1 : -1); } else{ int ans = 0; for(int i=1; i&lt;=len; i++) ans += Trie.find(s+i,len-i+1); for(int i=1; i&lt;=sz; i++){ if(v[i].size() &lt;= S.size()) ans += g[i] * search(v[i],S); } printf(&quot;%d\\n&quot;,ans),fflush(stdout); } } return 0;} CF1868C Travel Plan 题目描述： 给定一颗 nnn 个节点的二叉树，每个点有权值 ai∈[1,m]a_i \\in [1,m]ai​∈[1,m]，定义从 iii 到 jjj 的路径的权值 si,js_{i,j}si,j​ 为路径上的最大点权。 注意给定树相当于一棵完美二叉树，按顺序编号，从某一个结点开始其余的节点全部扔掉后形成的二叉树。 求所有树（mnm^nmn 种点权）的 ∑i=1n∑j=insi,j\\sum_{i=1}^n \\sum_{j=i}^n s_{i,j}∑i=1n​∑j=in​si,j​ 的和，模 998244353998244353998244353。 1≤n≤1018，1≤∑m≤1051 \\le n \\le 10^{18}，1 \\le \\sum m \\le 10^51≤n≤1018，1≤∑m≤105，多测 t≤200t \\le 200t≤200。 题目分析： 既然是对于所有的路径计数，一个显然的想法就是枚举 LCALCALCA。 这样对于一条长度为 lenlenlen 的路径，若我们钦定其最大值为 mxmxmx，则其造成的贡献就是 mx×[mxlen−(mx−1)len]×mn−lenmx \\times [mx^{len} - (mx-1)^{len}] \\times m^{n-len}mx×[mxlen−(mx−1)len]×mn−len。 所以其实我们只要知道了长度为 lenlenlen 的路径条数我们就可以直接计算出答案。 但是注意到如果这是一棵完美二叉树我们是会算的，所以就考虑能不能把这个看上去就很有性质的二叉树转化为完美二叉树。 注意到其实节点 nnn 就很有分界点的感觉，所以考虑将 111 到 nnn 的这一条链整体断掉之后，剩余的所有子树都是完美二叉树。 所以剩余子树内部的贡献我们就可以直接通过预处理完美二叉树的对应的贡献算出，而剩余子树之间必然会以 111 到 nnn 的这一条链为 LCALCALCA，所以可以直接自底向上枚举链上的点，然后算出以当前枚举的点为根的子树内的贡献，一层层合并即可。 预处理完美二叉树的贡献就是考虑一棵深度为 depdepdep 的完美二叉树必然有两棵深度为 dep−1dep-1dep−1 的完美二叉树合并而来，所以两棵子树内部的贡献可以通过先前预处理的东西得到，我们只需要知道以新合并出来的根为 LCALCALCA 的答案即可，这个可以通过简单的分讨解决。 注意的一点就是我们在知道了路径条数之后统计答案的时候，不能直接使用快速幂计算，因为原本的复杂度就有点爆炸，现在又多了一个 O(log⁡n)O(\\log n)O(logn) 的复杂度就更爆炸了，但是这个快速幂显然可以简单地递推解决掉。 代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1000+5;const int MOD = 998244353;int f[N][N],pw2[100005][300],pw[N],tmp[N],ans[N],pre[N];//f[i][j] 代表大小为 2^i-1 的完美二叉树当中，结点个数为 j 的路径条数 void add(int &amp;a,int b){ a = (a + b) % MOD;}int get(int a,int b){ int tot = 0; while(a &lt;= b){ a &lt;&lt;= 1; ++tot; } return tot;}int get2(int x){ if(x == 0) return 1; return pw[x-1];}int power(int a,int b){ int res = 1; while(b){ if(b &amp; 1) res = res * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; } return res;}signed main(){ pw[0] = 1; for(int i=1; i&lt;=100; i++) pw[i] = pw[i-1] * 2 % MOD; for(int i=1; i&lt;=100000; i++){ pw2[i][0] = 1; for(int j=1; j&lt;=200; j++) pw2[i][j] = pw2[i][j-1] * i% MOD; } f[0][0] = 1; for(int i=1; i&lt;=100; i++){ f[i][0] = 1; for(int j=0; j&lt;i; j++){ //这里均为小于 i 的原因是：两个子树的大小为 2^{i-1}-1 for(int k=0; k&lt;i; k++){ add(f[i][j+k+1],get2(j) * get2(k) % MOD); } } for(int j=1; j&lt;=2*i; j++) add(f[i][j],2 * f[i-1][j] % MOD); } int T;scanf(&quot;%lld&quot;,&amp;T); while(T--){ int n,m;scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); int now = n,len = 2; pre[0] = 1,pre[1] = 1; ans[1] = 1; while(now &gt; 1){ ++len; //ans 记录路径条数，pre 记录祖先后代链条数 int bro = now ^ 1; int dep = get(bro,n); //bro 是一个大小为 2^dep - 1 的完美二叉树 for(int l=0; l&lt;=len; l++){ if(!pre[l]) break; for(int r=0; r&lt;=dep; r++){ add(ans[l+r+1],pre[l] * get2(r)); } } for(int i=0; i&lt;=2*dep; i++) add(ans[i],f[dep][i]); for(int l=0; l&lt;=len; l++) add(tmp[l+1],pre[l]); for(int r=0; r&lt;=dep; r++){ int t = 0; if(r == 0) t = 1; else t = pw[r - 1]; add(tmp[r+1],t); } tmp[1] = 1;tmp[0] = 1; for(int i=0; i&lt;=len; i++) pre[i] = tmp[i],tmp[i] = 0; now &gt;&gt;= 1; } int res = 0; int tt = power(m,n),inv = power(m,MOD-2); for(int i=1; i&lt;=200; i++){ tt = tt * inv % MOD; for(int mx=1; mx&lt;=m; mx++){ if(ans[i]){ add(res,mx * ans[i] %MOD * (pw2[mx][i] - pw2[mx-1][i]) %MOD * tt % MOD); } } } for(int i=0; i&lt;=200; i++) ans[i] = pre[i] = tmp[i] = 0; printf(&quot;%lld\\n&quot;,(res + MOD) % MOD); } return 0;}","link":"/2023/10/01/practice-2023-9-28-2023-10-1/"},{"title":"基(奇)本(技)套(淫)路(巧)","text":"本篇是关于我做题时遇到的很神奇的技巧和思路的总结，会不定时更新。 以后就记录一些小 trick 以及一些知识点的小套路 Tricks 对于乘除法我们可以直接取对数转化为加减法 对于 ⌈ab⌉\\lceil \\dfrac{a}{b} \\rceil⌈ba​⌉ 可以转化为 ⌊a+(b−1)b⌋\\lfloor \\dfrac{a + (b-1)}{b} \\rfloor⌊ba+(b−1)​⌋ 来快速求解 对于两个点 x,yx,yx,y，若 lca(x,y)lca(x,y)lca(x,y) 为 xxx，则意味着 xxx 在 yyy 到根的路径上。 区间内有无重复元素：记录上一次出现的位置，然后转化为区间取 min⁡\\minmin 将 DP 的转移分为几块，每一块分开处理分开考虑 区间问题转化为差分或前缀和后考虑 对于存在查询很优以及修改很优的做法，就可以考虑使用分块平衡复杂度 边权转点权：每条边额外建一个点，连接这条边的两个端点 枚举每一个数的约数可以逆向转化为枚举每一个数的倍数，就可以让复杂度 O(nn)→O(nlog⁡n)O(n\\sqrt{n}) \\to O(n \\log n)O(nn​)→O(nlogn) 预处理前后缀信息，通过前后缀信息合并得到答案 与子树相对深度相关的有关的题，将贡献改为与子树绝对深度相关的信息 与某个极大数的组合数相关的题，考虑卢卡斯定理 SAM 中两个前缀的 LCS 是它们在 parent 树上的 lca 的最长串 后缀的 LCP 可以建反串转化为前缀的 LCS 广义 SAM 中一般可以考虑使用线段树合并维护当前点属于的模板串的集合，也可以用来维护 endpos 集合 ⌊j−ik⌋=⌊jk⌋−⌊ik⌋−[(j%k)&lt;(i%k)]\\lfloor \\frac{j-i}{k} \\rfloor = \\lfloor \\frac{j}{k} \\rfloor - \\lfloor \\frac{i}{k} \\rfloor - [(j \\% k) &lt; (i \\% k)]⌊kj−i​⌋=⌊kj​⌋−⌊ki​⌋−[(j%k)&lt;(i%k)] 树形背包的优化做法的复杂度是 O(nm)O(nm)O(nm)，其中 nnn 是节点数，mmm 是背包大小 自动机要考虑对模式串建或者询问串建，都考虑一下 链加+单点查询 -&gt; 单点加+子树查询：好写而且复杂度低 对于某些操作或者什么的，可以考虑想想终止状态是什么 期望次数可以理解为 1概率\\frac{1}{\\text{概率}}概率1​ 路径最大值/最小值：Kruskal 重构树；路径最大值最小/最小值最大：最小生成树、二分答案 字符串匹配使用 bitset 维护文本串每一个字符出现的位置，然后模式串求一个并集就好了 计数问题想不出来就考虑容斥一下，容斥原理或者统计不合法的方案数 没啥想法就随便枚举几个值试试 带环 DP：高斯消元、二分一个值 对于两个不同的数，二进制分组之后一定至少有一次它们在不同组中 设 p[i]p[i]p[i] 表示为 iii 的概率，P[i]P[i]P[i] 表示大于等于 iii 的概率，那么期望可以理解为：∑i=1ni×p[i]=∑i=1nP[i]\\sum_{i=1}^n i \\times p[i] = \\sum_{i=1}^n P[i]∑i=1n​i×p[i]=∑i=1n​P[i] ∑j=0i(ij)=2i\\sum_{j=0}^i \\binom{i}{j} = 2^i∑j=0i​(ji​)=2i 平衡树的翻转标记：只要下面有用到他的儿子就下传 树上两条路径如果有公共点，则交集必然满足点数等于边数加一 非必要情况，否则使用树剖求 lcalcalca 根据条件去求满足条件的点，或者枚举点判断是否符合条件 Kruskal 重构树的节点个数为 2×n−12\\times n - 12×n−1，千万别直接把 nnn 拿上去了。 在图论中看到只经过小于等于或者大于等于某个值的条件时，想到 Kruskal 重构树，转化为子树询问 期望 dpdpdp 一般可以考虑设到最终状态的期望，也可以是走一步的期望 对于选 kkk 个元素最优的题，那么对于任意一种最优方案，对于任意一个区间 [l,r][l,r][l,r] 若区间内选了 ppp 个，那么这 ppp 个一定是区间 [l,r][l,r][l,r] 选择 ppp 个的最优方案之一。 set 里 count 的复杂度是假的，不如直接用 map 1 int = 4b 调题的时候不要着急，要分析问题性质而不是对着错误的数据在那里打补丁。 某类数数题考虑最终的状态满足什么条件时合法，然后统计这些条件就变简单了。 树上 mmm 个点的 LCALCALCA 等于 dfsdfsdfs 最小的点和最大的点的 LCALCALCA。 可以根据 dpdpdp 进行的决策倒推 dpdpdp 的状态是什么，也就是为了完成这个决策需要知道什么，以及知道了什么之后才能转移。 矩阵乘法优化 dpdpdp 中，如果 dpdpdp 是一行左乘的话，转移矩阵的 (i,j)(i,j)(i,j) 的值其实相当于 dp[i]dp[i]dp[i] 到 dp[j]dp[j]dp[j] 的转移系数。 考试犯的傻逼错误： xxxx;xxxx; 却没打大括号 交错源代码 平衡树新建节点一定要把所有的信息都赋初值，不能感觉可以不赋就不赋 注意题目中是说：经过边的数量还是经过点的数量 字符串题注意串的字符串的首地址需要不需要加一 不要轻易否定自己的解法，如果感觉不对就构造一组，跑一遍 hack 掉就好了 网络流里不能随便建双向边，很多题在实际的建模里需要从 S -&gt; T （大致方向）建边。 建文件夹一定只包含数字和字母 可以手模的样例一定要手模 多测一定要清空，是将本次更改的全部改回去，而不是将下次可能用到的改回去，非必要情况，请使用 memsetmemsetmemset 清空 一定不要读形式化题面，只给了一坨抽象的式子完全不如慢慢读文字题面 数组中长度小的维度放在前面，可能可以让速度快很多倍 一定要认真读数据范围，特别关注看上去就很不正常的地方 预处理阶乘的逆元一定要记得处理 000 的啊。 平衡树不要和线段树混了，记得 nownownow 也是一个独立的点啊 无法调试或者灵异事件不要着急：观察一下基本的配置、观察一下文件（夹）名 传参数不要直接传一个 vectorvectorvector multiset 删除一定要反复检查是不是直接 erase(x) 状压或枚举状态的时候一定要注意从 000 开始还是从 111 开始，就是需不需要减一 写复杂的数据结构一定要从内层到外层慢慢来，千万不要从外层到内层去写 一些主函数比较难写的数据结构，就先把数据结构用暴力实现，直到主函数改对再去写数据结构 多测清空的时候注意：是不是之前的一些特判直接跳过了清空环节 要先有一个正确性有保证的做法，然后再有一个复杂度有保证的做法","link":"/2022/06/24/tricks/"}],"tags":[{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"pages":[]}